[{"title":"Network Requests","content":"#\n\n\nIntroduction#\n\nMocking network requests is an essential part of testing React Native\napplications. By mocking network requests, you can control the data that is\nreturned from the server and test how your application behaves in different\nscenarios, such as when the request is successful or when it fails.\n\nIn this guide, we will show you how to mock network requests and guard your test\nsuits from unwanted and unmocked/unhandled network requests\n\nINFO\n\nTo simulate a real-world scenario, we will use the Random User Generator API\nthat provides random user data.\n\n\nPhonebook Example#\n\nLet's assume we have a simple phonebook application that uses fetch for fetching\nData from a server. In our case, we have a list of contacts and favorites that\nwe want to display in our application.\n\nThis is how the root of the application looks like:\n\n\n\n\n\n\n\n\n\nexport default () => {\n  const [usersData, setUsersData] = useState([]);\n  const [favoritesData, setFavoritesData] = useState([]);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const _getAllContacts = async () => {\n      const _data = await getAllContacts();\n      setUsersData(_data);\n    };\n    const _getAllFavorites = async () => {\n      const _data = await getAllFavorites();\n      setFavoritesData(_data);\n    };\n\n    const run = async () => {\n      try {\n        await Promise.all([_getAllContacts(), _getAllFavorites()]);\n      } catch (e) {\n        const message = isErrorWithMessage(e) ? e.message : 'Something went wrong';\n        setError(message);\n      }\n    };\n\n    void run();\n  }, []);\n\n  if (error) {\n    return An error occurred: {error};\n  }\n\n  return (\n    <>\n      \n      \n    </>\n  );\n};\n\n\nWe fetch the contacts from the server using the getAllFavorites function that\nutilizes fetch.\n\n\n\nexport default async (): Promise => {\n  const res = await fetch('https://randomuser.me/api/?results=25');\n  if (!res.ok) {\n    throw new Error(`Error fetching contacts`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n\n\nWe have similar function for fetching the favorites, but this time limiting the\nresults to 10.\n\n\n\nexport default async (): Promise => {\n  const res = await fetch('https://randomuser.me/api/?results=10');\n  if (!res.ok) {\n    throw new Error(`Error fetching favorites`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n\n\nOur FavoritesList component is a simple component that displays the list of\nfavorite contacts and their avatars horizontally.\n\n\n\n\n\n\nexport default ({users}: { users: User[] }) => {\n  const renderItem: ListRenderItem = useCallback(({item: {picture}}) => {\n    return (\n      \n        \n      \n    );\n  }, []);\n\n  if (users.length === 0) return (\n    \n      Figuring out your favorites...\n    \n  );\n\n  return (\n    \n      ⭐My Favorites\n      \n        horizontal\n        showsHorizontalScrollIndicator={false}\n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    \n  );\n};\n\n// Looking for styles?\n// Check examples/cookbook/app/advanced/components/FavoritesList.tsx\nconst styles =\n...\n\n\nOur ContactsList component is similar to the FavoritesList component, but it\ndisplays the list of all contacts vertically.\n\n\n\n\n\n\nexport default ({ users }: { users: User[] }) => {\n  const renderItem: ListRenderItem = useCallback(\n    ({ item: { name, email, picture, cell }, index }) => {\n      const { title, first, last } = name;\n      const backgroundColor = index % 2 === 0 ? '#f9f9f9' : '#fff';\n      return (\n        \n          \n          \n            \n              Name: {title} {first} {last}\n            \n            Email: {email}\n            Mobile: {cell}\n          \n        \n      );\n    },\n    [],\n  );\n\n  if (users.length === 0) return ;\n\n  return (\n    \n      \n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    \n  );\n};\n\n// Looking for styles or FullScreenLoader component?\n// Check examples/cookbook/app/advanced/components/ContactsList.tsx\nconst FullScreenLoader = () => ...\nconst styles = ...\n\n\n\nStart testing with a simple test#\n\nIn our initial test we would like to test if the PhoneBook component renders the\nFavoritesList and ContactsList components correctly. We will need to mock the\nnetwork requests and their corresponding responses to ensure that the component\nbehaves as expected. To mock the network requests we will use MSW (Mock Service\nWorker).\n\nNOTE\n\nWe recommend using the Mock Service Worker (MSW) library to declaratively mock\nAPI communication in your tests instead of stubbing fetch, or relying on\nthird-party adapters.\n\nINFO\n\nYou can install MSW by running npm install msw --save-dev or yarn add msw --dev.\nMore info regarding installation can be found in MSW's getting started guide.\n\nPlease make sure you're also aware of MSW's setup guide. Please be minded that\nthe MSW's setup guide is potentially incomplete and might contain\ndiscrepancies/missing pieces.\n\n\n\n\n\n\n\n\n// Define request handlers and response resolvers for random user API.\n// By default, we always return the happy path response.\nconst handlers = [\n  http.get('https://randomuser.me/api/*', () => {\n    return HttpResponse.json(DATA);\n  }),\n];\n\n// Setup a request interception server with the given request handlers.\nconst server = setupServer(...handlers);\n\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\ndescribe('PhoneBook', () => {\n  it('fetches all contacts and favorites successfully and renders lists in sections correctly', async () => {\n    await render();\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(await screen.findByText('Name: Mrs Ida Kristensen')).toBeOnTheScreen();\n    expect(await screen.findByText('Email: ida.kristensen@example.com')).toBeOnTheScreen();\n    expect(await screen.findAllByText(/name/i)).toHaveLength(3);\n    expect(await screen.findByText(/my favorites/i)).toBeOnTheScreen();\n    expect(await screen.findAllByLabelText('favorite-contact-avatar')).toHaveLength(3);\n  });\n});\n\nconst DATA: { results: User[] } = {\n  results: [\n    {\n      name: {\n        title: 'Mrs',\n        first: 'Ida',\n        last: 'Kristensen',\n      },\n      email: 'ida.kristensen@example.com',\n      id: {\n        name: 'CPR',\n        value: '250562-5730',\n      },\n      picture: {\n        large: 'https://randomuser.me/api/portraits/women/26.jpg',\n        medium: 'https://randomuser.me/api/portraits/med/women/26.jpg',\n        thumbnail: 'https://randomuser.me/api/portraits/thumb/women/26.jpg',\n      },\n      cell: '123-4567-890',\n    },\n    // For brevity, we have omitted the rest of the users, you can still find them in\n    // examples/cookbook/app/network-requests/__tests__/test-utils.ts\n    ...\n  ],\n};\n\n\nINFO\n\nMore info regarding how to describe the network using request handlers,\nintercepting a request and handling its response can be found in the MSW's\ndocumentation.\n\n\nTesting error handling#\n\nAs we are dealing with network requests, and things can go wrong, we should also\ncover the case when the API request fails. In this case, we would like to test\nhow our application behaves when the API request fails.\n\nINFO\n\nThe nature of the network can be highly dynamic, which makes it challenging to\ndescribe it completely in a fixed list of request handlers..use() API. More info\ncan be found in MSW's Network behavior overrides documentation\n\nMSW provides us the means to override any particular network behavior using the\ndesignated\n\n...\n\nconst mockServerFailureForGetAllContacts = () => {\n  server.use(\n    http.get('https://randomuser.me/api/', ({ request }) => {\n      // Construct a URL instance out of the intercepted request.\n      const url = new URL(request.url);\n      // Read the \"results\" URL query parameter using the \"URLSearchParams\" API.\n      const resultsLength = url.searchParams.get('results');\n      // Simulate a server error for the get all contacts request.\n      // We check if the \"results\" query parameter is set to \"25\"\n      // to know it's the correct request to mock, in our case get all contacts.\n      if (resultsLength === '25') {\n        return new HttpResponse(null, { status: 500 });\n      }\n      // Return the default response for all other requests that match URL and verb. (in our case get favorites)\n      return HttpResponse.json(DATA);\n    }),\n  );\n};\n\ndescribe('PhoneBook', () => {\n...\n  it('fails to fetch all contacts and renders error message', async () => {\n    mockServerFailureForGetAllContacts();\n    await render();\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(\n      await screen.findByText(/an error occurred: error fetching contacts/i),\n    ).toBeOnTheScreen();\n  });\n});\n\n\n\n\nGlobal guarding against unwanted API requests#\n\nAs mistakes may happen, we might forget to mock a network request in one of our\ntests in the future. To prevent us from happening, and alert when a certain\nnetwork request is left unhandled, you may choose to move MSW's server\nmanagement from PhoneBook.test.tsx to Jest's setup file via setupFilesAfterEnv.\n\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\n// ... rest of your setup file\n\n\nThis setup will ensure you have the MSW server running before any test suite\nstarts and stops it after all tests are done. Which will result in a warning in\nthe console if you forget to mock an API request in your test suite.\n\n[MSW] Warning: intercepted a request without a matching request handler:\n • GET https://randomuser.me/api/?results=25?results=25\n\n\n\nConclusion#\n\nTesting a component that makes network requests in combination with MSW takes\nsome initial preparation to configure and describe the overridden networks. We\ncan achieve that by using MSW's request handlers and intercepting APIs.\n\nOnce up and running we gain full grip over the network requests, their\nresponses, statuses. Doing so is crucial to be able to test how our application\nbehaves in different scenarios, such as when the request is successful or when\nit fails.\n\nWhen global configuration is in place, MSW's will also warn us when an unhandled\nnetwork requests has occurred throughout a test suite.\n\n\nFurther Reading and Alternatives#\n\nExplore more advanced scenarios for mocking network requests with MSW:\n\n * MSW's Basics - Intercepting requests and/or Mocking responses\n * MSW's Network behavior - how to describe REST and/or GraphQL APIs","routePath":"/14.x/cookbook/advanced/network-requests","lang":"en","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":3},{"text":"Phonebook Example","id":"phonebook-example","depth":2,"charIndex":568},{"text":"Start testing with a simple test","id":"start-testing-with-a-simple-test","depth":2,"charIndex":4116},{"text":"Testing error handling","id":"testing-error-handling","depth":2,"charIndex":7195},{"text":"Global guarding against unwanted API requests","id":"global-guarding-against-unwanted-api-requests","depth":2,"charIndex":9019},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":10041},{"text":"Further Reading and Alternatives","id":"further-reading-and-alternatives","depth":2,"charIndex":10663}],"frontmatter":{},"version":"14.x"},{"title":"Async Events","content":"#\n\n\nSummary#\n\nIn RNTL v14, all tests are async since render(), fireEvent(), and other core\nAPIs return Promises. Beyond the basic async APIs, there are additional async\nutilities for handling events that complete over time:\n\n 1. Waiting for elements to appear: Use findBy* queries when elements appear\n    after some delay (e.g., after data fetching).\n 2. Waiting for conditions: Use waitFor() to wait for arbitrary conditions to be\n    met.\n 3. Waiting for elements to disappear: Use waitForElementToBeRemoved() when\n    elements should be removed after some action.\n\nThese utilities help you write reliable tests that properly handle timing in\nyour application.\n\n\nExample#\n\nConsider a test for a user signing in with correct credentials:\n\ntest('User can sign in with correct credentials', async () => {\n  // Typical test setup\n  const user = userEvent.setup();\n  await render(<App />);\n\n  // No need to use async here, components are already rendered\n  expect(screen.getByRole('header', { name: 'Sign in to Hello World App!' })).toBeOnTheScreen();\n\n  // Using await as User Event requires it\n  await user.type(screen.getByLabelText('Username'), 'admin');\n  await user.type(screen.getByLabelText('Password'), 'admin1');\n  await user.press(screen.getByRole('button', { name: 'Sign In' }));\n\n  // Using await as sign in operation is asynchronous\n  expect(await screen.findByRole('header', { name: 'Welcome admin!' })).toBeOnTheScreen();\n\n  // Follow-up assertions do not need to be async, as we already waited for sign in operation to complete\n  expect(\n    screen.queryByRole('header', { name: 'Sign in to Hello World App' })\n  ).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Username')).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Password')).not.toBeOnTheScreen();\n});\n\n\n\nAsync utilities#\n\nThere are several asynchronous utilities you might use in your tests.\n\n\nfindBy* queries#\n\nThe most common are the findBy* queries. These are useful when waiting for a\nmatching element to appear. They can be understood as a getBy* queries used in\nconjunction with a waitFor function.\n\nThey accept the same predicates as getBy* queries like findByRole, findByTest,\netc. They also have a multiple elements variant called findAllBy*.\n\nfunction findByRole: (\n  role: TextMatch,\n  queryOptions?: {\n    // Query specific options\n  }\n  waitForOptions?: {\n    timeout?: number;\n    interval?: number;\n    // ..\n  }\n): Promise<HostElement>;\n\n\nEach query has a default timeout value of 1000 ms and a default interval of 50\nms. Custom timeout and check intervals can be specified if needed, as shown\nbelow:\n\nExample#\n\nconst button = await screen.findByRole(\n  'button',\n  { name: 'Start' },\n  { timeout: 1000, interval: 50 }\n);\n\n\nAlternatively, a default global timeout value can be set using the configure\nfunction:\n\nconfigure({ asyncUtilTimeout: timeout });\n\n\n\nwaitFor function#\n\nThe waitFor function is another option, serving as a lower-level utility in more\nadvanced cases.\n\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T>;\n\n\nIt accepts an expectation to be validated and repeats the check every defined\ninterval until it no longer throws an error. Similarly to findBy* queries they\naccept timeout and interval options and have the same default values of 1000ms\nfor timeout, and a checking interval of 50 ms.\n\nExample#\n\nawait waitFor(() => expect(mockAPI).toHaveBeenCalledTimes(1));\n\n\nIf you want to use it with getBy* queries, use the findBy* queries instead, as\nthey essentially do the same, but offer better developer experience.\n\n\nwaitForElementToBeRemoved function#\n\nA specialized function, waitForElementToBeRemoved, is used to verify that a\nmatching element was present but has since been removed.\n\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T> {}\n\n\nThis function is, in a way, the negation of waitFor as it expects the initial\nexpectation to be true (not throw an error), only to turn invalid (start\nthrowing errors) on subsequent runs. It operates using the same timeout and\ninterval parameters as findBy* queries and waitFor.\n\nExample#\n\nawait waitForElementToBeRemoved(() => getByText('Hello World'));\n\n\n\nFake Timers#\n\nAsynchronous tests can take long to execute due to the delays introduced by\nasynchronous operations. To mitigate this, fake timers can be used. These are\nparticularly useful when delays are mere waits, such as the 130 milliseconds\nwait introduced by the UserEvent press() event due to React Native runtime\nbehavior or simulated 1000 wait in a API call mock. Fake timers allow for\nprecise fast-forwarding through these wait periods.\n\nHere are the basics of using Jest fake timers:\n\n * Enable fake timers with: jest.useFakeTimers()\n * Disable fake timers with: jest.useRealTimers()\n * Advance fake timers forward with: jest.advanceTimersByTime(interval)\n * Run all timers to completion with: jest.runAllTimers()\n * Run currently pending timers to completion with: jest.runOnlyPendingTimers()\n\nBe cautious when running all timers to completion as it might create an infinite\nloop if these timers schedule follow-up timers. In such cases, it's safer to use\njest.runOnlyPendingTimers() to avoid ending up in an infinite loop of scheduled\ntasks.\n\nYou can use both built-in Jest fake timers, as well as Sinon.JS fake timers.\n\nNote: you do not need to advance timers by hand when using User Event API, as\nit's automatically.","routePath":"/14.x/cookbook/basics/async-events","lang":"en","toc":[{"text":"Summary","id":"summary","depth":2,"charIndex":3},{"text":"Example","id":"example","depth":3,"charIndex":665},{"text":"Async utilities","id":"async-utilities","depth":2,"charIndex":1797},{"text":"`findBy*` queries","id":"findby-queries","depth":3,"charIndex":-1},{"text":"Example","id":"example-1","depth":4,"charIndex":2611},{"text":"`waitFor` function","id":"waitfor-function","depth":3,"charIndex":-1},{"text":"Example","id":"example-2","depth":4,"charIndex":3390},{"text":"`waitForElementToBeRemoved` function","id":"waitforelementtoberemoved-function","depth":3,"charIndex":-1},{"text":"Example","id":"example-3","depth":4,"charIndex":4209},{"text":"Fake Timers","id":"fake-timers","depth":2,"charIndex":4287}],"frontmatter":{},"version":"14.x"},{"title":"Custom `render` function","content":"Custom render function#\n\n\nSummary#\n\nRNTL exposes the render function as the primary entry point for tests. If you\nmake complex, repeating setups for your tests, consider creating a custom render\nfunction. The idea is to encapsulate common setup steps and test wiring inside a\nrender function suitable for your tests.\n\n\nExample#\n\n// ...\n\ninterface RenderWithProvidersProps {\n  user?: User | null;\n  theme?: Theme;\n}\n\nexport async function renderWithProviders(\n  ui: React.ReactElement,\n  options?: RenderWithProvidersProps\n) {\n  return await render(\n    \n      {ui}\n    \n  );\n}\n\n\n\n\n// ...\n\ntest('renders WelcomeScreen with user', async () => {\n  await renderWithProviders(, { user: { name: 'Jar-Jar' } });\n  expect(screen.getByText(/hello Jar-Jar/i)).toBeOnTheScreen();\n});\n\ntest('renders WelcomeScreen without user', async () => {\n  await renderWithProviders(, { user: null });\n  expect(screen.getByText(/hello stranger/i)).toBeOnTheScreen();\n});\n\n\nExample full source code.\n\n\nMore info#\n\nAdditional params#\n\nA custom render function might accept additional parameters to allow for setting\nup different start conditions for a test, e.g., the initial state for global\nstate management.\n\ntest('renders SomeScreen for logged in user', async () => {\n  await renderScreen(, { state: loggedInState });\n  // ...\n});\n\n\nMultiple functions#\n\nDepending on the situation, you may declare more than one custom render\nfunction. For example, you have one function for testing application flows and a\nsecond for testing individual screens.\n\nfunction renderNavigator(ui, options);\nfunction renderScreen(ui, options);\n\n\nAsync setup#\n\nSince render is async, your custom render function should be marked as async and\nuse await render(). This pattern also makes it easy to add additional async\nsetup if needed:\n\nasync function renderWithData(ui: React.ReactElement) {\n  const data = await fetchTestData();\n  return await render({ui});\n}\n\ntest('renders SomeScreen', async () => {\n  await renderWithData();\n  // ...\n});\n","routePath":"/14.x/cookbook/basics/custom-render","lang":"en","toc":[{"text":"Summary","id":"summary","depth":3,"charIndex":25},{"text":"Example","id":"example","depth":3,"charIndex":318},{"text":"More info","id":"more-info","depth":3,"charIndex":976},{"text":"Additional params","id":"additional-params","depth":4,"charIndex":988},{"text":"Multiple functions","id":"multiple-functions","depth":4,"charIndex":1310},{"text":"Async setup","id":"async-setup","depth":4,"charIndex":1601}],"frontmatter":{},"version":"14.x"},{"title":"Introduction","content":"#\n\nWelcome to the React Native Testing Library (RNTL) Cookbook! This app is your\ngo-to resource for learning how to effectively test React Native applications.\nIt provides a collection of best practices, ready-made recipes, and tips &\ntricks to simplify and improve your testing workflow. Whether you’re a beginner\njust getting started or a seasoned developer looking to sharpen your skills, the\nCookbook has something for everyone.\n\n\nWhat's Inside the Cookbook?#\n\nThe Cookbook is currently organized into three main chapters:\n\n * Basic Recipes: A great starting point, covering essential testing scenarios\n   such as async operations and custom render functions.\n * Advanced Recipes: More complex scenarios like network requests and in the\n   future, navigation testing and more.\n * State Management Recipes: Best practices for testing state management\n   libraries\n\nEach recipe includes a clear explanation along with a corresponding code example\nto help you get hands-on with testing. Checkout the Cookbook App to see the\nrecipes in action.\n\n\nWhat's Next?#\n\nJoin the conversation on GitHub here to discuss ideas, ask questions, or provide\nfeedback.","routePath":"/14.x/cookbook/","lang":"en","toc":[{"text":"What's Inside the Cookbook?","id":"whats-inside-the-cookbook","depth":2,"charIndex":434},{"text":"What's Next?","id":"whats-next","depth":2,"charIndex":1045}],"frontmatter":{},"version":"14.x"},{"title":"Jotai","content":"#\n\n\nIntroduction#\n\nJotai is a global state management library for React that uses an atomic\napproach to optimize renders and solve issues like extra re-renders and the need\nfor memoization. It scales from simple state management to complex enterprise\napplications, offering utilities and extensions to enhance the developer\nexperience.\n\n\nTask List Example#\n\nLet's assume we have a simple task list component that uses Jotai for state\nmanagement. The component has a list of tasks, a text input for typing new task\nname and a button to add a new task to the list.\n\n\n\n\n\n\n\nexport function TaskList() {\n  const [tasks, setTasks] = useAtom(tasksAtom);\n  const [newTaskTitle, setNewTaskTitle] = useAtom(newTaskTitleAtom);\n\n  const handleAddTask = () => {\n    setTasks((tasks) => [\n      ...tasks,\n      {\n        id: nanoid(),\n        title: newTaskTitle,\n      },\n    ]);\n    setNewTaskTitle('');\n  };\n\n  return (\n    \n      {tasks.map((task) => (\n        \n          {task.title}\n        \n      ))}\n\n      {!tasks.length ? No tasks, start by adding one... : null}\n\n       setNewTaskTitle(text)}\n      />\n\n      \n        Add Task\n      \n    \n  );\n}\n\n\n\nStarting with a Simple Test#\n\nWe can test our TaskList component using React Native Testing Library's (RNTL)\nregular render function. Although it is sufficient to test the empty state of\nthe TaskList component, it is not enough to test the component with initial\ntasks present in the list.\n\n\n\n\n\n\n\n\njest.useFakeTimers();\n\ntest('renders an empty task list', async () => {\n  await render();\n  expect(screen.getByText(/no tasks, start by adding one/i)).toBeOnTheScreen();\n});\n\n\n\nCustom Render Function to populate Jotai Atoms with Initial Values#\n\nTo test the TaskList component with initial tasks, we need to be able to\npopulate the tasksAtom with initial values. We can create a custom render\nfunction that uses Jotai's useHydrateAtoms hook to hydrate the atoms with\ninitial values. This function will accept the initial atoms and their\ncorresponding values as an argument.\n\n\n\n\n\n\n// Jotai types are not well exported, so we will make our life easier by using `any`.\nexport type AtomInitialValueTuple = [PrimitiveAtom, T];\n\nexport interface RenderWithAtomsOptions {\n  initialValues: AtomInitialValueTuple[];\n}\n\n/**\n * Renders a React component with Jotai atoms for testing purposes.\n *\n * @param component - The React component to render.\n * @param options - The render options including the initial atom values.\n * @returns The render result from `@testing-library/react-native`.\n */\nexport async function renderWithAtoms(\n  component: React.ReactElement,\n  options: RenderWithAtomsOptions\n) {\n  return await render(\n    {component}\n  );\n}\n\nexport type HydrateAtomsWrapperProps = React.PropsWithChildren<{\n  initialValues: AtomInitialValueTuple[];\n}>;\n\n/**\n * A wrapper component that hydrates Jotai atoms with initial values.\n *\n * @param initialValues - The initial values for the Jotai atoms.\n * @param children - The child components to render.\n * @returns The rendered children.\n\n */\nfunction HydrateAtomsWrapper({ initialValues, children }: HydrateAtomsWrapperProps) {\n  useHydrateAtoms(initialValues);\n  return children;\n}\n\n\n\nTesting the TaskList Component with initial tasks#\n\nWe can now use the renderWithAtoms function to render the TaskList component\nwith initial tasks. The initialValues property will contain the tasksAtom,\nnewTaskTitleAtom and their initial values. We can then test the component to\nensure that the initial tasks are rendered correctly.\n\nINFO\n\nIn our test, we populated only one atom and its initial value, but you can add\nother Jotai atoms and their corresponding values to the initialValues array as\nneeded.\n\nconst INITIAL_TASKS: Task[] = [{ id: '1', title: 'Buy bread' }];\n\ntest('renders a to do list with 1 items initially, and adds a new item', async () => {\n  await renderWithAtoms(, {\n    initialValues: [\n      [tasksAtom, INITIAL_TASKS],\n      [newTaskTitleAtom, ''],\n    ],\n  });\n\n  expect(screen.getByText(/buy bread/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(1);\n\n  const user = userEvent.setup();\n  await user.type(screen.getByPlaceholderText(/new task/i), 'Buy almond milk');\n  await user.press(screen.getByRole('button', { name: /add task/i }));\n\n  expect(screen.getByText(/buy almond milk/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(2);\n});\n\n\n\nModifying atom outside of React components#\n\nIn several cases, you might need to change an atom's state outside a React\ncomponent. In our case, we have a set of functions to get tasks and set tasks,\nwhich change the state of the task list atom.\n\n\n\n\nexport const tasksAtom = atom([]);\nexport const newTaskTitleAtom = atom('');\n\n// Available for use outside React components\nexport const store = createStore();\n\n// Selectors\nexport function getAllTasks(): Task[] {\n  return store.get(tasksAtom);\n}\n\n// Actions\nexport function addTask(task: Task) {\n  store.set(tasksAtom, [...getAllTasks(), task]);\n}\n\n\n\nTesting atom outside of React components#\n\nYou can test the getAllTasks and addTask functions outside the React component's\nscope by setting the initial to-do items in the store and then checking if the\nfunctions work as expected. No special setup is required to test these\nfunctions, as store.set is available by default by Jotai.\n\n\n\n//...\n\ntest('modify store outside of React component', () => {\n  // Set the initial to do items in the store\n  store.set(tasksAtom, INITIAL_TASKS);\n  expect(getAllTasks()).toEqual(INITIAL_TASKS);\n\n  const NEW_TASK = { id: '2', title: 'Buy almond milk' };\n  addTask(NEW_TASK);\n  expect(getAllTasks()).toEqual([...INITIAL_TASKS, NEW_TASK]);\n});\n\n\n\nConclusion#\n\nTesting a component or a function that depends on Jotai atoms is straightforward\nwith the help of the useHydrateAtoms hook. We've seen how to create a custom\nrender function renderWithAtoms that sets up atoms and their initial values for\ntesting purposes. We've also seen how to test functions that change the state of\natoms outside React components. This approach allows us to test components in\ndifferent states and scenarios, ensuring they behave as expected.","routePath":"/14.x/cookbook/state-management/jotai","lang":"en","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":3},{"text":"Task List Example","id":"task-list-example","depth":2,"charIndex":337},{"text":"Starting with a Simple Test","id":"starting-with-a-simple-test","depth":2,"charIndex":1145},{"text":"Custom Render Function to populate Jotai Atoms with Initial Values","id":"custom-render-function-to-populate-jotai-atoms-with-initial-values","depth":2,"charIndex":1620},{"text":"Testing the `TaskList` Component with initial tasks","id":"testing-the-tasklist-component-with-initial-tasks","depth":2,"charIndex":-1},{"text":"Modifying atom outside of React components","id":"modifying-atom-outside-of-react-components","depth":2,"charIndex":4409},{"text":"Testing atom outside of React components","id":"testing-atom-outside-of-react-components","depth":2,"charIndex":5010},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":5691}],"frontmatter":{},"version":"14.x"},{"title":"Testing environment","content":"#\n\nINFO\n\nThis document is intended for a more advanced audience who want to understand\nthe internals of our testing environment better, e.g., to contribute to the\ncodebase. You should be able to write integration or component tests without\nreading this.\n\nReact Native Testing Library allows you to write integration and component tests\nfor your React Native app or library. While the JSX code used in tests closely\nresembles your React Native app, things are not as simple as they might appear.\nThis document will describe the key elements of our testing environment and\nhighlight things to be aware of when writing more advanced tests or diagnosing\nissues.\n\n\nReact renderers#\n\nReact allows you to write declarative code using JSX, write function or class\ncomponents, or use hooks like useState. You need to use a renderer to output the\nresults of your components. Every React app uses some renderer:\n\n * React Native is a renderer for mobile apps,\n * React DOM is a renderer for web apps,\n * There are other more specialized renderers that can e.g., render to console\n   or HTML canvas.\n\nWhen you run your tests in the React Native Testing Library, somewhat contrary\nto what the name suggests, they are actually not using React Native renderer.\nThis is because this renderer needs to be run on an iOS or Android operating\nsystem, so it would need to run on a device or simulator.\n\n\nTest Renderer#\n\nInstead, RNTL uses Test Renderer, a modern, actively maintained renderer that\nallows rendering to pure JavaScript objects without access to mobile OS and can\nrun in a Node.js environment using Jest (or any other JavaScript test runner).\nTest Renderer replaces the deprecated react-test-renderer package and provides\nbetter compatibility with React 19 and improved type safety.\n\nUsing Test Renderer has pros and cons.\n\nBenefits:\n\n * tests can run on most CIs (Linux, etc) and do not require a mobile device or\n   emulator\n * faster test execution\n * light runtime environment\n\nDisadvantages:\n\n * Tests do not execute native code\n * Tests are unaware of the view state that would be managed by native\n   components, e.g., focus, unmanaged text boxes, etc.\n * Assertions do not operate on native view hierarchy\n * Runtime behaviors are simulated, sometimes imperfectly\n\nIt's worth noting that the React Testing Library (web one) works a bit\ndifferently. While RTL also runs in Jest, it has access to a simulated browser\nDOM environment from the jsdom package, which allows it to use a regular React\nDOM renderer. Unfortunately, there is no similar React Native runtime\nenvironment package. This is probably because while the browser environment is\nwell-defined and highly standardized, the React Native environment constantly\nevolves in sync with the evolution of underlying OS-es. Maintaining such an\nenvironment would require duplicating countless React Native behaviors and\nkeeping them in sync as React Native develops.\n\n\nElement tree#\n\nCalling the render() function creates an element tree. This is done internally\nby invoking the createRoot() function from Test Renderer. The output tree\nrepresents your React Native component tree, containing only host elements. Each\nnode of that tree corresponds to a host component that would have a counterpart\nin the native view hierarchy.\n\nThese tree elements are represented by HostElement type from Test Renderer:\n\ninterface HostElement {\n  type: ElementType;\n  props: { [propName: string]: any };\n  parent: HostElement | null;\n  children: Array<HostElement | string>;\n\n  // Other props and methods\n}\n\n\nFor more details, see the Test Renderer documentation.\n\n\nHost and composite components#\n\nTo understand RNTL's element tree, it's important to know the difference between\nhost and composite components in React Native:\n\n * Host components have direct counterparts in the native view tree. Typical\n   examples are <View>, <Text>, <TextInput>, and <Image> from React Native. You\n   can think of these as an analog of <div>, <span> etc on the Web. You can also\n   create custom host views as native modules or import them from 3rd party\n   libraries, like React Navigation or React Native Gesture Handler.\n * Composite components are React code organization units that exist only on the\n   JavaScript side of your app. Typical examples are components you create\n   (function and class components), components imported from React Native (View,\n   Text, etc.), or 3rd party packages.\n\nThat might initially sound confusing since we put React Native's View in both\ncategories. There are two View components: composite and host. The relation\nbetween them is as follows:\n\n * Composite View is the type imported from the react-native package. It is a\n   JavaScript component that renders the host View as its only child.\n * Host View, which you do not render directly. React Native takes the props you\n   pass to the composite View, does some processing on them and passes them to\n   the host View.\n\nIn a full React tree, this would look like:\n\n* <View> (composite)\n  * <View> (host)\n    * children prop passed in JSX\n\n\nA similar relation exists between other composite and host pairs: e.g. Text,\nTextInput, and Image components.\n\nNot all React Native components are organized this way, e.g., when you use\nPressable (or TouchableOpacity), there is no host Pressable, but composite\nPressable is rendering a host View with specific props being set:\n\n* <Pressable> (composite)\n  * <View accessible={true} {...}> (host)\n    * children prop passed in JSX\n\n\n\nHost-only element tree#\n\nIn RNTL v14, Test Renderer only exposes host elements in the element tree.\nComposite components are not visible in the tree - you only see their host\nelement output. This is an intentional design choice that aligns with Testing\nLibrary's philosophy: tests should focus on what users can see and interact with\n(host elements), not on implementation details (composite components).\n\nFor a HostElement, the type prop is always a string value representing the host\ncomponent name, e.g., \"View\", \"Text\", \"TextInput\".\n\n\nTree nodes#\n\nRNTL v14 queries and the element tree only expose host elements. This aligns\nwith Testing Library's philosophy: tests should assert on what users can see and\ninteract with. Host elements represent the actual UI controls that users\ninteract with, while composite components exist purely in the JavaScript domain.\n\n\nUnderstanding props#\n\nWhen asserting props on host elements, you're verifying what actually reaches\nthe native view. This is important because composite components may process,\ntransform, or even forget to pass props to their host children.\n\nfunction ForgotToPassPropsButton({ title, onPress, style }) {\n  return (\n    <Pressable>\n      <Text>{title}</Text>\n    </Pressable>\n  );\n}\n\n\nIn the above example, the component accepts onPress and style props but doesn't\npass them to host views, so they won't affect the user interface. By testing\nhost elements, RNTL helps you catch these issues: if a prop doesn't reach a host\nelement, users won't see or interact with it.\n\n\nTree navigation#\n\nCAUTION\n\nYou should avoid navigating over the element tree, as this makes your testing\ncode fragile and may result in false positives. This section is more relevant\nfor people who want to contribute to our codebase.\n\nYou can navigate the tree of host elements using parent or children props of a\nHostElement. Be careful when doing this, as the tree structure for third-party\ncomponents can change independently from your code and cause unexpected test\nfailures.\n\n\nQueries#\n\nAll Testing Library queries return host components to encourage the best\npractices described above. Since v14, RNTL uses Test Renderer, which only\nrenders host elements, making it impossible to query composite components\ndirectly.","routePath":"/14.x/docs/advanced/testing-env","lang":"en","toc":[{"text":"React renderers","id":"react-renderers","depth":2,"charIndex":659},{"text":"Test Renderer","id":"test-renderer","depth":2,"charIndex":1382},{"text":"Element tree","id":"element-tree","depth":2,"charIndex":2921},{"text":"Host and composite components","id":"host-and-composite-components","depth":2,"charIndex":3603},{"text":"Host-only element tree","id":"host-only-element-tree","depth":3,"charIndex":5487},{"text":"Tree nodes","id":"tree-nodes","depth":2,"charIndex":6026},{"text":"Understanding props","id":"understanding-props","depth":3,"charIndex":6353},{"text":"Tree navigation","id":"tree-navigation","depth":2,"charIndex":7023},{"text":"Queries","id":"queries","depth":2,"charIndex":7505}],"frontmatter":{},"version":"14.x"},{"title":"Third-Party Library Integration","content":"#\n\nThe React Native Testing Library is designed to simulate the core behaviors of\nReact Native. However, it does not replicate the internal logic of third-party\nlibraries. This guide explains how to integrate your library with RNTL.\n\n\nHandling Events in Third-Party Libraries#\n\nRNTL provides two subsystems to simulate events:\n\n * Fire Event: A lightweight simulation system that can trigger event handlers\n   defined on both host and composite components.\n * User Event: A more realistic interaction simulation system that can trigger\n   event handlers defined only on host components.\n\nIn many third-party libraries, event handling involves native code, which means\nRNTL cannot fully simulate the event flow, as it runs only JavaScript code. To\naddress this limitation, you can use testOnly_on* props on host components to\nexpose custom events to RNTL’s event subsystems. Both subsystems will first\nattempt to locate the standard on* event handlers; if these are not available,\nthey fall back to the testOnly_on* handlers.\n\n\nExample: React Native Gesture Handler#\n\nReact Native Gesture Handler (RNGH) provides a composite Pressable component\nwith onPress* props. These event handlers are not exposed on the rendered host\nviews; instead, they are invoked via RNGH’s internal event flow, which involves\nnative modules. As a result, they are not accessible to RNTL’s event subsystems.\n\nTo enable RNTL to interact with RNGH’s Pressable component, the library exposes\ntestOnly_onPress* props on the NativeButton host component rendered by\nPressable. This adjustment allows RNTL to simulate interactions during testing.\n\nfunction Pressable({ onPress, onPressIn, onPressOut, onLongPress, ... }) {\n\n  // Component logic...\n\n  const isTestEnv = process.env.NODE_ENV === 'test';\n\n  return (\n    \n      \n    \n  );\n}\n","routePath":"/14.x/docs/advanced/third-party-integration","lang":"en","toc":[{"text":"Handling Events in Third-Party Libraries","id":"handling-events-in-third-party-libraries","depth":2,"charIndex":234},{"text":"Example: React Native Gesture Handler","id":"example-react-native-gesture-handler","depth":3,"charIndex":1026}],"frontmatter":{},"version":"14.x"},{"title":"Understanding `act` function","content":"Understanding act function#\n\nWhen writing RNTL tests one of the things that confuses developers the most are\ncryptic act() function errors logged into console. In this article I will try to\nbuild an understanding of the purpose and behaviour of act() so you can build\nyour tests with more confidence.\n\n\nact warning#\n\nLet's start with a typical act() warning logged to console:\n\nAn update to Root inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser.\nLearn more at https://react.dev/link/wrap-tests-with-act\n\n\n\nUnderstanding act#\n\n\nResponsibility#\n\nThis function is intended only for using in automated tests and works only in\ndevelopment mode. Attempting to use it in production build will throw an error.\n\nThe responsibility for act function is to make React renders and updates work in\ntests in a similar way they work in real application by grouping and executing\nrelated units of interaction (e.g. renders, effects, etc) together.\n\nTo showcase that behaviour let make a small experiment. First we define a\nfunction component that uses useEffect hook in a trivial way.\n\nfunction TestComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n\n\nIn the following tests we will directly use Test Renderer instead of RNTL render\nfunction to render our component for tests. In order to expose familiar queries\nlike getByText we will use within function from RNTL.\n\n\n\n\ntest('render without act', () => {\n  const renderer = createRoot();\n  renderer.render(<TestComponent />);\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 0')).toBeTruthy();\n});\n\n\nWhen testing without act call wrapping rendering call, we see that the assertion\nruns just after the rendering but before useEffect hooks effects are applied.\nWhich is not what we expected in our tests.\n\n\n\n\ntest('render with act', async () => {\n  const renderer = createRoot();\n  await act(() => {\n    renderer.render(<TestComponent />);\n  });\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 1')).toBeTruthy();\n});\n\n\nNote: In v14, act is now async by default and always returns a Promise. You\nshould always use await act(...).\n\nWhen wrapping rendering call with act we see that the changes caused by\nuseEffect hook have been applied as we would expect.\n\n\nWhen to use act#\n\nThe name act comes from Arrange-Act-Assert unit testing pattern. Which means\nit's related to part of the test when we execute some actions on the component\ntree.\n\nSo far we learned that act function allows tests to wait for all pending React\ninteractions to be applied before we make our assertions. When using act we get\nguarantee that any state updates will be executed as well as any enqueued\neffects will be executed.\n\nTherefore, we should use act whenever there is some action that causes element\ntree to render, particularly:\n\n * initial render call - renderer.render call\n * re-rendering of component - renderer.render call with updated element\n * triggering any event handlers that cause component tree render\n\nThankfully, for these basic cases RNTL has got you covered as our render,\nrerender and fireEvent methods already wrap their calls in act so that you do\nnot have to do it explicitly. In v14, these functions are all async and should\nbe awaited.\n\nNote that act calls can be safely nested and internally form a stack of calls.\n\n\nImplementation#\n\nThe act implementation is defined in the ReactAct.js source file inside React\nrepository. RNTL v14 requires React 19+, which provides the act function\ndirectly via React.act.\n\nRNTL exports act for convenience of the users as defined in the act.ts source\nfile. In v14, act is now async by default and always returns a Promise, making\nit compatible with async React features like Suspense boundary or use() hook.\nThe underlying implementation wraps React's act function to ensure consistent\nasync behavior.\n\nImportant: You should always use act exported from @testing-library/react-native\nrather than the one from react. The RNTL version automatically ensures async\nbehavior, whereas using React.act directly could still trigger synchronous act\nbehavior if used improperly, leading to subtle test issues.\n\n\nAsynchronous code#\n\nIn v14, act is always async and returns a Promise. While the callback you pass\nto act can be synchronous (dealing with things like synchronous effects or mocks\nusing already resolved promises), the act function itself should always be\nawaited. However, not all component code is synchronous. Frequently our\ncomponents or mocks contain some asynchronous behaviours like setTimeout calls\nor network calls.\n\n\nHandling asynchronous operations#\n\nWhen the callback passed to act contains asynchronous operations, the Promise\nreturned by act will resolve only after those operations complete.\n\nLets look at a simple example with component using setTimeout call to simulate\nasynchronous behaviour:\n\nfunction TestAsyncComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setTimeout(() => {\n      setCount((c) => c + 1);\n    }, 50);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n\n\n\n\ntest('render async natively', async () => {\n  await render(<TestAsyncComponent />);\n  expect(screen.getByText('Count 0')).toBeOnTheScreen();\n});\n\n\nIf we test our component in a native way without handling its asynchronous\nbehaviour we will end up with an act warning. This is because the setTimeout\ncallback will trigger a state update after the test has finished.\n\n\nSolution with fake timers#\n\nFirst solution is to use Jest's fake timers inside out tests:\n\ntest('render with fake timers', async () => {\n  jest.useFakeTimers();\n  await render(<TestAsyncComponent />);\n\n  await act(() => {\n    jest.runAllTimers();\n  });\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n\n\nNote: In v14, both render and act are async by default, so you should await\nthem.\n\nThat way we can wrap jest.runAllTimers() call which triggers the setTimeout\nupdates inside an act call, hence resolving the act warning.\n\n\nSolution with real timers#\n\nIf we wanted to stick with real timers then things get a bit more complex. Let's\nstart by applying a crude solution of opening async act() call for the expected\nduration of components updates:\n\ntest('render with real timers - sleep', async () => {\n  await render(<TestAsyncComponent />);\n  await act(() => {\n    await sleep(100); // Wait a bit longer than setTimeout in `TestAsyncComponent`\n  });\n\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n\n\nThis works correctly as we use an explicit async act() call that resolves the\nconsole error. However, it relies on our knowledge of exact implementation\ndetails which is a bad practice.\n\nLet's try more elegant solution using waitFor that will wait for our desired\nstate:\n\ntest('render with real timers - waitFor', async () => {\n  await render(<TestAsyncComponent />);\n\n  await waitFor(() => screen.getByText('Count 1'));\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n\n\nThis also works correctly, because waitFor call executes async act() call\ninternally.\n\nThe above code can be simplified using findBy query:\n\ntest('render with real timers - findBy', async () => {\n  await render(<TestAsyncComponent />);\n\n  expect(await screen.findByText('Count 1')).toBeOnTheScreen();\n});\n\n\nThis also works since findByText internally calls waitFor which uses async\nact().\n\nNote that all of the above examples are async tests using & awaiting async act()\nfunction call.\n\n\nReferences#\n\n * React act implementation source\n * React testing documentation","routePath":"/14.x/docs/advanced/understanding-act","lang":"en","toc":[{"text":"`act` warning","id":"act-warning","depth":2,"charIndex":-1},{"text":"Understanding `act`","id":"understanding-act","depth":2,"charIndex":-1},{"text":"Responsibility","id":"responsibility","depth":3,"charIndex":768},{"text":"When to use act","id":"when-to-use-act","depth":3,"charIndex":2679},{"text":"Implementation","id":"implementation","depth":3,"charIndex":3741},{"text":"Asynchronous code","id":"asynchronous-code","depth":2,"charIndex":4563},{"text":"Handling asynchronous operations","id":"handling-asynchronous-operations","depth":3,"charIndex":4989},{"text":"Solution with fake timers","id":"solution-with-fake-timers","depth":3,"charIndex":5865},{"text":"Solution with real timers","id":"solution-with-real-timers","depth":3,"charIndex":6403},{"text":"References","id":"references","depth":2,"charIndex":7864}],"frontmatter":{},"version":"14.x"},{"title":"API Overview","content":"#\n\nReact Native Testing Library consists of following APIs:\n\n * render function - render your UI components for testing purposes\n * screen object - access rendered UI:\n   * Queries - find relevant components by various predicates: role, text, test\n     ids, etc\n   * Lifecycle methods: rerender, unmount\n   * Helpers: debug, toJSON, root\n * Jest matchers - validate assumptions about your UI\n * User Event - simulate common user interactions like press or type in a\n   realistic way\n * Fire Event - simulate any component event in a simplified way purposes\n * Misc APIs:\n   * renderHook function - render hooks for testing\n   * Async utils: findBy* queries, wait, waitForElementToBeRemoved\n   * Configuration: configure, resetToDefaults\n   * Accessibility: isHiddenFromAccessibility\n   * Other: within, act, cleanup","routePath":"/14.x/docs/api","lang":"en","toc":[],"frontmatter":{"uri":"/api"},"version":"14.x"},{"title":"Fire Event API","content":"#\n\n\nfireEvent #\n\nNOTE\n\nFor common events like press or type it's recommended to use User Event API as\nit offers more realistic event simulation by emitting a sequence of events with\nproper event objects that mimic React Native runtime behavior.\n\nUse Fire Event for cases not supported by User Event and for triggering event\nhandlers on composite components.\n\nfunction fireEvent(element: HostElement, eventName: string, ...data: unknown[]): Promise<unknown>;\n\n\nThe fireEvent API allows you to trigger all kinds of event handlers on both host\nand composite components. It will try to invoke a single event handler\ntraversing the component tree bottom-up from passed element and trying to find\nenabled event handler named onXxx when xxx is the name of the event passed.\n\nUnlike User Event, this API does not automatically pass event object to event\nhandler, this is responsibility of the user to construct such object.\n\nThis function uses async act function internally to ensure all pending React\nupdates are executed during event handling.\n\n\n\ntest('fire changeText event', async () => {\n  const onEventMock = jest.fn();\n  await render(\n    // MyComponent renders TextInput which has a placeholder 'Enter details'\n    // and with `onChangeText` bound to handleChangeText\n    <MyComponent handleChangeText={onEventMock} />\n  );\n\n  await fireEvent(screen.getByPlaceholderText('change'), 'onChangeText', 'ab');\n  expect(onEventMock).toHaveBeenCalledWith('ab');\n});\n\n\nNOTE\n\nfireEvent performs checks that should prevent events firing on disabled\nelements.\n\nAn example using fireEvent with native events that aren't already aliased by the\nfireEvent api.\n\n\n\n\nconst onBlurMock = jest.fn();\n\nawait render(\n  <View>\n    <TextInput placeholder=\"my placeholder\" onBlur={onBlurMock} />\n  </View>\n);\n\n// you can omit the `on` prefix\nawait fireEvent(screen.getByPlaceholderText('my placeholder'), 'blur');\n\n\nFireEvent exposes convenience methods for common events like: press, changeText,\nscroll.\n\n\nfireEvent.press #\n\nNOTE\n\nIt is recommended to use the User Event press() helper instead as it offers more\nrealistic simulation of press interaction, including pressable support.\n\nfireEvent.press: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n\n\nInvokes press event handler on the element or parent element in the tree.\n\n\n\n\nconst onPressMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    pageX: 20,\n    pageY: 30,\n  },\n};\n\nawait render(\n  <View>\n    <TouchableOpacity onPress={onPressMock}>\n      <Text>Press me</Text>\n    </TouchableOpacity>\n  </View>\n);\n\nawait fireEvent.press(screen.getByText('Press me'), eventData);\nexpect(onPressMock).toHaveBeenCalledWith(eventData);\n\n\n\nfireEvent.changeText #\n\nNOTE\n\nIt is recommended to use the User Event type() helper instead as it offers more\nrealistic simulation of text change interaction, including key-by-key typing,\nelement focus, and other editing events.\n\nfireEvent.changeText: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n\n\nInvokes changeText event handler on the element or parent element in the tree.\n\n\n\n\nconst onChangeTextMock = jest.fn();\nconst CHANGE_TEXT = 'content';\n\nawait render(\n  <View>\n    <TextInput placeholder=\"Enter data\" onChangeText={onChangeTextMock} />\n  </View>\n);\n\nawait fireEvent.changeText(screen.getByPlaceholderText('Enter data'), CHANGE_TEXT);\n\n\n\nfireEvent.scroll #\n\nNOTE\n\nPrefer using user.scrollTo over fireEvent.scroll for ScrollView, FlatList, and\nSectionList components. User Event provides a more realistic event simulation\nbased on React Native runtime behavior.\n\nfireEvent.scroll: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n\n\nInvokes scroll event handler on the element or parent element in the tree.\n\nOn a ScrollView#\n\n\n\n\nconst onScrollMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    contentOffset: {\n      y: 200,\n    },\n  },\n};\n\nawait render(\n  <ScrollView testID=\"scroll-view\" onScroll={onScrollMock}>\n    <Text>Content</Text>\n  </ScrollView>\n);\n\nawait fireEvent.scroll(screen.getByTestId('scroll-view'), eventData);\n","routePath":"/14.x/docs/api/events/fire-event","lang":"en","toc":[{"text":"`fireEvent`","id":"fireevent","depth":2,"charIndex":-1},{"text":"`fireEvent.press`","id":"fireeventpress","depth":3,"charIndex":-1},{"text":"`fireEvent.changeText`","id":"fireeventchangetext","depth":3,"charIndex":-1},{"text":"`fireEvent.scroll`","id":"fireeventscroll","depth":3,"charIndex":-1},{"text":"On a `ScrollView`","id":"on-a-scrollview","depth":4,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"User Event interactions","content":"#\n\n\nComparison with Fire Event API#\n\nFire Event is our original event simulation API. It can invoke any event handler\ndeclared on either host or composite elements. Suppose the element does not have\nonEventName event handler for the passed eventName event, or the element is\ndisabled. In that case, Fire Event will traverse up the component tree, looking\nfor an event handler on both host and composite elements along the way. By\ndefault, it will not pass any event data, but the user might provide it in the\nlast argument.\n\nIn contrast, User Event provides realistic event simulation for user\ninteractions like press or type. Each interaction will trigger a sequence of\nevents corresponding to React Native runtime behavior. These events will be\ninvoked only on host elements, and will automatically receive event data\ncorresponding to each event.\n\nIf User Event supports a given interaction, you should always prefer it over the\nFire Event counterpart, as it will make your tests much more realistic and,\nhence, reliable. In other cases, e.g., when User Event does not support the\ngiven event or when invoking event handlers on composite elements, you have to\nuse Fire Event as the only available option.\n\n\nsetup()#\n\nuserEvent.setup(options?: {\n  delay?: number;\n  advanceTimers?: (delay: number) => Promise<void> | void;\n})\n\n\nExample\n\nconst user = userEvent.setup();\n\n\nCreates a User Event object instance, which can be used to trigger events.\n\n\nOptions #\n\n * delay controls the default delay between subsequent events, e.g., keystrokes.\n * advanceTimers is a time advancement utility function that should be used for\n   fake timers. The default setup handles both real timers and Jest fake timers.\n\n\npress()#\n\npress(\n  element: HostElement,\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.press(element);\n\n\nThis helper simulates a press on any pressable element, e.g. Pressable,\nTouchableOpacity, Text, TextInput, etc. Unlike fireEvent.press(), a more\nstraightforward API that will only call the onPress prop, this function\nsimulates the entire press interaction in a more realistic way by reproducing\nthe event sequence emitted by React Native runtime. This helper will trigger\nadditional events like pressIn and pressOut.\n\nThis event will take a minimum of 130 ms to run due to the internal React Native\nlogic. Consider using fake timers to speed up test execution for tests involving\npress and longPress interactions.\n\n\nlongPress()#\n\nlongPress(\n  element: HostElement,\n  options?: { duration?: number }\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.longPress(element);\n\n\nSimulates a long press user interaction. In React Native, the longPress event is\nemitted when the press duration exceeds the long press threshold (by default,\n500 ms). In other aspects, this action behaves similarly to regular press\naction, e.g., by emitting pressIn and pressOut events. The press duration is\ncustomizable through the options. This should be useful if you use the\ndelayLongPress prop.\n\nThis event will, by default, take 500 ms to run. Due to internal React Native\nlogic, it will take at least 130 ms regardless of the duration option passed.\nConsider using fake timers to speed up test execution for tests involving press\nand longPress interactions.\n\n\nOptions #\n\n * duration - duration of the press in milliseconds. The default value is 500\n   ms.\n\n\ntype()#\n\ntype(\n  element: HostElement,\n  text: string,\n  options?: {\n    skipPress?: boolean;\n    skipBlur?: boolean;\n    submitEditing?: boolean;\n  }\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.type(textInput, 'Hello world!');\n\n\nThis helper simulates the user focusing on a TextInput element, typing text one\ncharacter at a time, and leaving the element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\nNOTE\n\nThis function will add text to the text already present in the text input (as\nspecified by value or defaultValue props). To replace existing text, use clear()\nhelper first.\n\n\nOptions #\n\n * skipPress - if true, pressIn and pressOut events will not be triggered.\n * skipBlur - if true, endEditing and blur events will not be triggered when\n   typing is complete.\n * submitEditing - if true, submitEditing event will be triggered after typing\n   the text.\n\n\nSequence of events #\n\nThe sequence of events depends on the multiline prop and the passed options.\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * pressIn (optional)\n * focus\n * pressOut (optional)\n\nThe pressIn and pressOut events are sent by default but can be skipped by\npassing the skipPress: true option.\n\nTyping (for each character):\n\n * keyPress\n * change\n * changeText\n * selectionChange\n * contentSizeChange (only multiline)\n\nLeaving the element:\n\n * submitEditing (optional)\n * endEditing\n * blur\n\nThe submitEditing event is skipped by default. It can sent by setting the\nsubmitEditing: true option. The endEditing and blur events can be skipped by\npassing the skipBlur: true option.\n\n\nclear()#\n\nclear(\n  element: HostElement,\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.clear(textInput);\n\n\nThis helper simulates the user clearing the content of a TextInput element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\n\nSequence of events #\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * focus\n\nSelecting all content:\n\n * selectionChange\n\nPressing backspace:\n\n * keyPress\n * change\n * changeText\n * selectionChange\n\nLeaving the element:\n\n * endEditing\n * blur\n\n\npaste()#\n\npaste(\n  element: HostElement,\n  text: string,\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.paste(textInput, 'Text to paste');\n\n\nThis helper simulates the user pasting given text to a TextInput element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\n\nSequence of events #\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * focus\n\nSelecting all content:\n\n * selectionChange\n\nPasting the text:\n\n * change\n * changeText\n * selectionChange\n * contentSizeChange (only multiline)\n\nLeaving the element:\n\n * endEditing\n * blur\n\n\nscrollTo()#\n\nscrollTo(\n  element: HostElement,\n  options: {\n    y: number;\n    momentumY?: number;\n    contentSize?: { width: number; height: number };\n    layoutMeasurement?: { width: number; height: number };\n  } | {\n    x: number;\n    momentumX?: number;\n    contentSize?: { width: number; height: number };\n    layoutMeasurement?: { width: number; height: number };\n  }\n): Promise<void>\n\n\nExample\n\nconst user = userEvent.setup();\nawait user.scrollTo(scrollView, { y: 100, momentumY: 200 });\n\n\nThis helper simulates the user scrolling a host ScrollView element.\n\nThis function supports only host ScrollView elements, passing other element\ntypes will result in an error. Note that FlatList is accepted as it renders to a\nhost ScrollView element.\n\nScroll interaction should match the ScrollView element direction:\n\n * for a vertical scroll view (default or horizontal={false}), you should pass\n   only the y option (and optionally also momentumY).\n * for a horizontal scroll view (horizontal={true}), you should pass only the x\n   option (and optionally momentumX).\n\nEach scroll interaction consists of a mandatory drag scroll part, which\nsimulates the user dragging the scroll view with his finger (the y or x option).\nThis may optionally be followed by a momentum scroll movement, which simulates\nthe inertial movement of scroll view content after the user lifts his finger\n(momentumY or momentumX options).\n\n\nOptions #\n\n * y - target vertical drag scroll offset\n * x - target horizontal drag scroll offset\n * momentumY - target vertical momentum scroll offset\n * momentumX - target horizontal momentum scroll offset\n * contentSize - passed to ScrollView events and enabling FlatList updates\n * layoutMeasurement - passed to ScrollView events and enabling FlatList updates\n\nUser Event will generate several intermediate scroll steps to simulate user\nscroll interaction. You should not rely on exact number or values of these\nscrolls steps as they might be change in the future version.\n\nThis function will remember where the last scroll ended, so subsequent scroll\ninteraction will starts from that position. The initial scroll position will be\nassumed to be { y: 0, x: 0 }.\n\nTo simulate a FlatList (and other controls based on VirtualizedList) scrolling,\nyou should pass the contentSize and layoutMeasurement options, which enable the\nunderlying logic to update the currently visible window.\n\n\nSequence of events #\n\nThe sequence of events depends on whether the scroll includes an optional\nmomentum scroll component.\n\nDrag scroll:\n\n * contentSizeChange\n * scrollBeginDrag\n * scroll (multiple events)\n * scrollEndDrag\n\nMomentum scroll (optional):\n\n * momentumScrollBegin\n * scroll (multiple events)\n * momentumScrollEnd","routePath":"/14.x/docs/api/events/user-event","lang":"en","toc":[{"text":"Comparison with Fire Event API","id":"comparison-with-fire-event-api","depth":2,"charIndex":3},{"text":"`setup()`","id":"setup","depth":2,"charIndex":-1},{"text":"Options","id":"options","depth":3,"charIndex":-1},{"text":"`press()`","id":"press","depth":2,"charIndex":-1},{"text":"`longPress()`","id":"longpress","depth":2,"charIndex":-1},{"text":"Options","id":"options-1","depth":3,"charIndex":-1},{"text":"`type()`","id":"type","depth":2,"charIndex":-1},{"text":"Options","id":"options-2","depth":3,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events","depth":3,"charIndex":-1},{"text":"`clear()`","id":"clear","depth":2,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-1","depth":3,"charIndex":-1},{"text":"`paste()`","id":"paste","depth":2,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-2","depth":3,"charIndex":-1},{"text":"`scrollTo()`","id":"scroll-to","depth":2,"charIndex":-1},{"text":"Options","id":"options-3","depth":3,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-3","depth":3,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Jest matchers","content":"#\n\nThis guide describes built-in Jest matchers, we recommend using these matchers\nas they provide readable tests, accessibility support, and a better developer\nexperience.\n\n\nSetup#\n\nThere is no need to set up the built-in matchers; they are automatically\navailable in your tests when you import anything from\n@testing-library/react-native, e.g., render.\n\n\nChecking element existence#\n\n\ntoBeOnTheScreen()#\n\nexpect(element).toBeOnTheScreen();\n\n\nThis allows you to assert whether an element is attached to the element tree or\nnot. If you hold a reference to an element and it gets unmounted during the test\nit will no longer pass this assertion.\n\n\nElement Content#\n\n\ntoHaveTextContent()#\n\nexpect(element).toHaveTextContent(\n  text: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n\n\nThis allows you to assert whether the given element has the given text content\nor not. It accepts either string or RegExp matchers, as well as text match\noptions of exact and normalizer.\n\n\ntoContainElement()#\n\nexpect(container).toContainElement(\n  element: HostElement | null,\n)\n\n\nThis allows you to assert whether the given container element does contain\nanother host element.\n\n\ntoBeEmptyElement()#\n\nexpect(element).toBeEmptyElement();\n\n\nThis allows you to assert whether the given element does not have any host child\nelements or text content.\n\n\nChecking element state#\n\n\ntoHaveDisplayValue()#\n\nexpect(element).toHaveDisplayValue(\n  value: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n\n\nThis allows you to assert whether the given TextInput element has a specified\ndisplay value. It accepts either string or RegExp matchers, as well as text\nmatch options of exact and normalizer.\n\n\ntoHaveAccessibilityValue()#\n\nexpect(element).toHaveAccessibilityValue(\n  value: {\n    min?: number;\n    max?: number;\n    now?: number;\n    text?: string | RegExp;\n  },\n)\n\n\nThis allows you to assert whether the given element has a specified accessible\nvalue.\n\nThis matcher will assert accessibility value based on aria-valuemin,\naria-valuemax, aria-valuenow, aria-valuetext and accessibilityValue props. Only\ndefined value entries will be used in the assertion, the element might have\nadditional accessibility value entries and still be matched.\n\nWhen querying by text entry a string or RegExp might be used.\n\n\ntoBeEnabled() / toBeDisabled #\n\nexpect(element).toBeEnabled();\nexpect(element).toBeDisabled();\n\n\nThese allow you to assert whether the given element is enabled or disabled from\nthe user's perspective. It relies on the accessibility disabled state as set by\naria-disabled or accessibilityState.disabled props. It will consider a given\nelement disabled when it or any of its ancestors is disabled.\n\nNOTE\n\nThese matchers are the negation of each other, and both are provided to avoid\ndouble negations in your assertions.\n\n\ntoBeSelected()#\n\nexpect(element).toBeSelected();\n\n\nThis allows you to assert whether the given element is selected from the user's\nperspective. It relies on the accessibility selected state as set by\naria-selected or accessibilityState.selected props.\n\n\ntoBeChecked() / toBePartiallyChecked() #\n\nexpect(element).toBeChecked();\nexpect(element).toBePartiallyChecked();\n\n\nThese allow you to assert whether the given element is checked or partially\nchecked from the user's perspective. It relies on the accessibility checked\nstate as set by aria-checked or accessibilityState.checked props.\n\nNOTE\n * toBeChecked() matcher works only on Switch host elements and accessibility\n   elements with checkbox, radio or switch role.\n * toBePartiallyChecked() matcher works only on elements with checkbox role.\n\n\ntoBeExpanded() / toBeCollapsed() #\n\nexpect(element).toBeExpanded();\nexpect(element).toBeCollapsed();\n\n\nThese allow you to assert whether the given element is expanded or collapsed\nfrom the user's perspective. It relies on the accessibility expanded state as\nset by aria-expanded or accessibilityState.expanded props.\n\nNOTE\n\nThese matchers are the negation of each other for expandable elements (elements\nwith explicit aria-expanded or accessibilityState.expanded props). However, both\nwon't pass for non-expandable elements (ones without explicit aria-expanded or\naccessibilityState.expanded props).\n\n\ntoBeBusy()#\n\nexpect(element).toBeBusy();\n\n\nThis allows you to assert whether the given element is busy from the user's\nperspective. It relies on the accessibility busy state as set by aria-busy or\naccessibilityState.busy props.\n\n\nChecking element style#\n\n\ntoBeVisible()#\n\nexpect(element).toBeVisible();\n\n\nThis allows you to assert whether the given element is visible from the user's\nperspective.\n\nThe element is considered invisible when itself or any of its ancestors has\ndisplay: none or opacity: 0 styles, as well as when it's hidden from\naccessibility.\n\n\ntoHaveStyle()#\n\nexpect(element).toHaveStyle(\n  style: StyleProp<Style>,\n)\n\n\nThis allows you to assert whether the given element has given styles.\n\n\nOther matchers#\n\n\ntoHaveAccessibleName()#\n\nexpect(element).toHaveAccessibleName(\n  name?: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n\n\nThis allows you to assert whether the given element has a specified accessible\nname. It accepts either string or RegExp matchers, as well as text match options\nof exact and normalizer.\n\nThe accessible name will be computed based on aria-labelledby,\naccessibilityLabelledBy, aria-label, and accessibilityLabel props. For Image\nelements, the alt prop will also be considered. In the absence of these props,\nthe element text content will be used.\n\nWhen the name parameter is undefined it will only check if the element has any\naccessible name.\n\n\ntoHaveProp()#\n\nexpect(element).toHaveProp(\n  name: string,\n  value?: unknown,\n)\n\n\nThis allows you to assert whether the given element has a given prop. When the\nvalue parameter is undefined it will only check for existence of the prop, and\nwhen value is defined it will check if the actual value matches passed value.\n\nNOTE\n\nThis matcher should be treated as an escape hatch to be used when all other\nmatchers are not suitable.","routePath":"/14.x/docs/api/jest-matchers","lang":"en","toc":[{"text":"Setup","id":"setup","depth":2,"charIndex":173},{"text":"Checking element existence","id":"checking-element-existence","depth":2,"charIndex":355},{"text":"`toBeOnTheScreen()`","id":"tobeonthescreen","depth":3,"charIndex":-1},{"text":"Element Content","id":"element-content","depth":2,"charIndex":644},{"text":"`toHaveTextContent()`","id":"tohavetextcontent","depth":3,"charIndex":-1},{"text":"`toContainElement()`","id":"tocontainelement","depth":3,"charIndex":-1},{"text":"`toBeEmptyElement()`","id":"tobeemptyelement","depth":3,"charIndex":-1},{"text":"Checking element state","id":"checking-element-state","depth":2,"charIndex":1380},{"text":"`toHaveDisplayValue()`","id":"tohavedisplayvalue","depth":3,"charIndex":-1},{"text":"`toHaveAccessibilityValue()`","id":"tohaveaccessibilityvalue","depth":3,"charIndex":-1},{"text":"`toBeEnabled()` / `toBeDisabled`","id":"tobeenabled--tobedisabled","depth":3,"charIndex":-1},{"text":"`toBeSelected()`","id":"tobeselected","depth":3,"charIndex":-1},{"text":"`toBeChecked()` / `toBePartiallyChecked()`","id":"tobechecked--tobepartiallychecked","depth":3,"charIndex":-1},{"text":"`toBeExpanded()` / `toBeCollapsed()`","id":"tobeexpanded--tobecollapsed","depth":3,"charIndex":-1},{"text":"`toBeBusy()`","id":"tobebusy","depth":3,"charIndex":-1},{"text":"Checking element style","id":"checking-element-style","depth":2,"charIndex":4535},{"text":"`toBeVisible()`","id":"tobevisible","depth":3,"charIndex":-1},{"text":"`toHaveStyle()`","id":"tohavestyle","depth":3,"charIndex":-1},{"text":"Other matchers","id":"other-matchers","depth":2,"charIndex":5013},{"text":"`toHaveAccessibleName()`","id":"tohaveaccessiblename","depth":3,"charIndex":-1},{"text":"`toHaveProp()`","id":"tohaveprop","depth":3,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Accessibility","content":"#\n\n\nisHiddenFromAccessibility#\n\nfunction isHiddenFromAccessibility(element: HostElement | null): boolean {}\n\n\nAlso available as isInaccessible() alias for React Testing Library\ncompatibility.\n\nChecks if given element is hidden from assistive technology, e.g. screen\nreaders.\n\nNOTE\n\nLike isInaccessible function from DOM Testing Library this function considers\nboth accessibility elements and presentational elements (regular Views) to be\naccessible, unless they are hidden in terms of host platform.\n\nThis covers only part of ARIA notion of Accessibility Tree, as ARIA excludes\nboth hidden and presentational elements from the Accessibility Tree.\n\nFor the scope of this function, element is inaccessible when it, or any of its\nancestors, meets any of the following conditions:\n\n * it has display: none style\n * it has aria-hidden prop set to true\n * it has accessibilityElementsHidden prop set to true\n * it has importantForAccessibility prop set to no-hide-descendants\n * it has sibling host element with either aria-modal or\n   accessibilityViewIsModal prop set to true\n\nSpecifying accessible={false}, role=\"none\", accessibilityRole=\"none\", or\nimportantForAccessibility=\"no\" props does not cause the element to become\ninaccessible.","routePath":"/14.x/docs/api/misc/accessibility","lang":"en","toc":[{"text":"`isHiddenFromAccessibility`","id":"ishiddenfromaccessibility","depth":2,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Async utilities","content":"#\n\n\nfindBy* queries#\n\nThe findBy* queries are used to find elements that are not instantly available\nbut will be added as a result of some asynchronous action. Learn more details\nhere.\n\n\nwaitFor#\n\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: {\n    timeout?: number;\n    interval?: number;\n    onTimeout?: (error: Error) => Error;\n  }\n): Promise<T>;\n\n\nWaits for a period of time for the expectation callback to pass. waitFor may run\nthe callback a number of times until timeout is reached, as specified by the\ntimeout and interval options. The callback must throw an error when the\nexpectation is not met. Returning any value, including a falsy one, will be\ntreated as meeting the expectation, and the callback result will be returned to\nthe caller of waitFor function.\n\nawait waitFor(() => expect(mockFunction).toHaveBeenCalledWith());\n\n\nwaitFor function will be executing expectation callback every interval (default:\nevery 50 ms) until timeout (default: 1000 ms) is reached. The repeated execution\nof callback is stopped as soon as it does not throw an error, in such case the\nvalue returned by the callback is returned to waitFor caller. Otherwise, when it\nreaches the timeout, the final error thrown by expectation will be re-thrown by\nwaitFor to the calling code.\n\n// ❌ `waitFor` will return immediately because callback does not throw\nawait waitFor(() => false);\n\n\nwaitFor is an async function so you need to await the result to pause test\nexecution.\n\n// ❌ missing `await`: `waitFor` will just return Promise that will be rejected when the timeout is reached\nwaitFor(() => expect(1).toBe(2));\n\n\nNOTE\n\nYou can enforce awaiting waitFor by using the await-async-utils rule from\neslint-plugin-testing-library.\n\nSince waitFor is likely to run expectation callback multiple times, it is highly\nrecommended for it not to perform any side effects in waitFor.\n\nawait waitFor(async () => {\n  // ❌ button will be pressed on each waitFor iteration\n  await fireEvent.press(screen.getByText('press me'));\n  expect(mockOnPress).toHaveBeenCalled();\n});\n\n\nNOTE\n\nAvoiding side effects in expectation callback can be partially enforced with the\nno-wait-for-side-effects rule.\n\nIt is also recommended to have a single assertion per each waitFor for more\nconsistency and faster failing tests. If you want to make several assertions,\nthen they should be in seperate waitFor calls. In many cases you won't actually\nneed to wrap the second assertion in waitFor since the first one will do the\nwaiting required for asynchronous change to happen.\n\nwaitFor checks whether Jest fake timers are enabled and adapts its behavior in\nsuch case. The following snippet is a simplified version of how it behaves when\nfake timers are enabled:\n\nlet fakeTimeRemaining = timeout;\nlet lastError;\n\nwhile (fakeTimeRemaining > 0) {\n  fakeTimeRemaining = fakeTimeRemaining - interval;\n  jest.advanceTimersByTime(interval);\n  try {\n    // resolve\n    return expectation();\n  } catch (error) {\n    lastError = error;\n  }\n}\n\n// reject\nthrow lastError;\n\n\nIn the following example we test that a function is called after 10 seconds\nusing fake timers. Since we're using fake timers, the test won't depend on real\ntime passing and thus be much faster and more reliable. Also we don't have to\nadvance fake timers through Jest fake timers API because waitFor already does\nthis for us.\n\n// in component\nsetTimeout(() => {\n  someFunction();\n}, 10000);\n\n// in test\njest.useFakeTimers();\n\nawait waitFor(\n  () => {\n    expect(someFunction).toHaveBeenCalledWith();\n  },\n  { timeout: 10000 }\n);\n\n\nNOTE\n\nIf you receive warnings related to act() function consult our Understanding Act\nfunction document.\n\n\nOptions#\n\n * timeout: How long to wait for, in ms. Defaults to 1000 ms (configured by\n   asyncUtilTimeout option).\n * interval: How often to check, in ms. Defaults to 50 ms.\n * onTimeout: Callback to transform the error before it's thrown. Useful for\n   debugging, e.g., onTimeout: () => { screen.debug(); }.\n\n\nwaitForElementToBeRemoved#\n\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: {\n    timeout?: number;\n    interval?: number;\n    onTimeout?: (error: Error) => Error;\n  }\n): Promise<T>;\n\n\nWaits for non-deterministic periods of time until queried element is removed or\ntimes out. waitForElementToBeRemoved periodically calls expectation every\ninterval milliseconds to determine whether the element has been removed or not.\n\n\n\ntest('waiting for an Banana to be removed', async () => {\n  await render(<Banana />);\n\n  await waitForElementToBeRemoved(() => screen.getByText('Banana ready'));\n});\n\n\nThis method expects that the element is initially present in the render tree and\nthen is removed from it. If the element is not present when you call this method\nit throws an error.\n\nYou can use any of getBy, getAllBy, queryBy and queryAllBy queries for\nexpectation parameter.\n\nNOTE\n\nIf you receive warnings related to act() function consult our Understanding Act\nfunction document.","routePath":"/14.x/docs/api/misc/async","lang":"en","toc":[{"text":"`findBy*` queries","id":"findby-queries","depth":2,"charIndex":-1},{"text":"`waitFor`","id":"waitfor","depth":2,"charIndex":-1},{"text":"Options","id":"options","depth":3,"charIndex":3660},{"text":"`waitForElementToBeRemoved`","id":"waitforelementtoberemoved","depth":2,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Configuration","content":"#\n\n\nconfigure#\n\ntype Config = {\n  /** Default timeout, in ms, for `waitFor` and `findBy*` queries. */\n  asyncUtilTimeout: number;\n\n  /** Default value for `includeHiddenElements` query option. */\n  defaultIncludeHiddenElements: boolean;\n\n  /** Default options for `debug` helper. */\n  defaultDebugOptions?: Partial<DebugOptions>;\n};\n\ntype ConfigAliasOptions = {\n  /** RTL-compatibility alias for `defaultIncludeHiddenElements`. */\n  defaultHidden: boolean;\n};\n\nfunction configure(options: Partial<Config & ConfigAliasOptions>) {}\n\n\n\nasyncUtilTimeout option#\n\nDefault timeout, in ms, for async helper functions (waitFor,\nwaitForElementToBeRemoved) and findBy* queries. Defaults to 1000 ms.\n\n\ndefaultIncludeHiddenElements option#\n\nDefault value for includeHiddenElements query option for all queries. The\ndefault value is set to false, so all queries will not match elements hidden\nfrom accessibility. This is because the users of the app would not be able to\nsee such elements.\n\nThis option is also available as defaultHidden alias for compatibility with\nReact Testing Library.\n\n\ndefaultDebugOptions option#\n\nDefault debug options to be used when calling debug(). These default options\nwill be overridden by the ones you specify directly when calling debug().\n\n\nresetToDefaults()#\n\nfunction resetToDefaults() {}\n\n\n\nEnvironment variables#\n\n\nRNTL_SKIP_AUTO_CLEANUP#\n\nSet to true to disable automatic cleanup() after each test. It works the same as\nimporting react-native-testing-library/dont-cleanup-after-each or using\nreact-native-testing-library/pure.\n\n$ RNTL_SKIP_AUTO_CLEANUP=true jest\n\n\n\nRNTL_SKIP_AUTO_DETECT_FAKE_TIMERS#\n\nSet to true to disable auto-detection of fake timers. This might be useful in\nrare cases when you want to use non-Jest fake timers. See issue #886 for more\ndetails.\n\n$ RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS=true jest\n","routePath":"/14.x/docs/api/misc/config","lang":"en","toc":[{"text":"`configure`","id":"configure","depth":2,"charIndex":-1},{"text":"`asyncUtilTimeout` option","id":"asyncutiltimeout-option","depth":3,"charIndex":-1},{"text":"`defaultIncludeHiddenElements` option","id":"defaultincludehiddenelements-option","depth":3,"charIndex":-1},{"text":"`defaultDebugOptions` option","id":"defaultdebugoptions-option","depth":3,"charIndex":-1},{"text":"`resetToDefaults()`","id":"resettodefaults","depth":2,"charIndex":-1},{"text":"Environment variables","id":"environment-variables","depth":2,"charIndex":1313},{"text":"`RNTL_SKIP_AUTO_CLEANUP`","id":"rntl_skip_auto_cleanup","depth":3,"charIndex":-1},{"text":"`RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`","id":"rntl_skip_auto_detect_fake_timers","depth":3,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Other helpers","content":"#\n\n\nwithin #\n\nfunction within(element: HostElement): Queries {}\n\n\nwithin performs queries scoped to given element.\n\nNOTE\n\nPlease note that additional render specific operations like rerender, unmount,\ndebug, toJSON are not included.\n\nconst detailsScreen = within(screen.getByHintText('Details Screen'));\nexpect(detailsScreen.getByText('Some Text')).toBeOnTheScreen();\nexpect(detailsScreen.getByDisplayValue('Some Value')).toBeOnTheScreen();\nexpect(detailsScreen.queryByLabelText('Some Label')).toBeOnTheScreen();\nawait expect(detailsScreen.findByHintText('Some Label')).resolves.toBeOnTheScreen();\n\n\nUse cases for scoped queries include:\n\n * queries scoped to a single item inside a FlatList containing many items\n * queries scoped to a single screen in tests involving screen transitions (e.g.\n   with react-navigation)\n\n\nact#\n\nfunction act<T>(callback: () => T | Promise<T>): Promise<T>;\n\n\nWraps code that causes React state updates to ensure all updates are processed\nbefore assertions. By default any render, rerender, fireEvent, and waitFor calls\nare wrapped by this function, so there is no need to wrap it manually.\n\nIn v14, act is now async by default and always returns a Promise, making it\ncompatible with async React features like Suspense boundary or use() hook. This\nensures all pending React updates are executed before the Promise resolves.\n\n\n\nit('should update state', async () => {\n  await act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n\n\nNote: Even if your callback is synchronous, you should still use await act(...)\nas act now always returns a Promise.\n\nConsult our Understanding Act function document for more understanding of its\nintricacies.\n\n\ncleanup#\n\nfunction cleanup(): Promise<void>;\n\n\nUnmounts React trees that were mounted with render and clears screen variable\nthat holds latest render output.\n\nINFO\n\nPlease note that this is done automatically if the testing framework you're\nusing supports the afterEach global (like mocha, Jest, and Jasmine). If not, you\nwill need to do manual cleanups after each test.\n\nFor example, if you're using the jest testing framework, then you would need to\nuse the afterEach hook like so:\n\n\n\n\nafterEach(async () => {\n  await cleanup();\n});\n\nit('renders a view', async () => {\n  await render(<View />);\n  // ...\n});\n\n\nThe afterEach(cleanup) call also works in describe blocks:\n\ndescribe('when logged in', () => {\n  afterEach(async () => {\n    await cleanup();\n  });\n\n  it('renders the user', async () => {\n    await render(<SiteHeader />);\n    // ...\n  });\n});\n\n\nFailing to call cleanup when you've called render could result in a memory leak\nand tests which are not \"idempotent\" (which can lead to difficult to debug\nerrors in your tests).","routePath":"/14.x/docs/api/misc/other","lang":"en","toc":[{"text":"`within`","id":"within","depth":2,"charIndex":-1},{"text":"`act`","id":"act","depth":2,"charIndex":-1},{"text":"`cleanup`","id":"cleanup","depth":2,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"`renderHook` function","content":"renderHook function#\n\n\nrenderHook#\n\nasync function renderHook<Result, Props>(\n  hookFn: (props: Props) => Result,\n  options?: RenderHookOptions<Props>\n): Promise<RenderHookResult<Result, Props>>;\n\n\nRenders a test component that will call the provided callback, including any\nhooks it calls, every time it renders. Returns a Promise that resolves to a\nRenderHookResult object, which you can interact with.\n\nThis is the recommended default API for testing hooks. It uses async act\ninternally to ensure all pending React updates are executed during rendering,\nmaking it compatible with async React features like Suspense boundary or use()\nhook.\n\n * Returns a Promise: Should be awaited\n * Async methods: Both rerender and unmount return Promises and should be\n   awaited\n * Suspense support: Compatible with Suspense boundaries and use() hook\n\n\n\n\nit('should increment count', async () => {\n  const { result } = await renderHook(() => useCount());\n\n  expect(result.current.count).toBe(0);\n  await act(() => {\n    // Note that you should wrap the calls to functions your hook returns with `act` if they trigger an update of your hook's state to ensure pending useEffects are run before your next assertion.\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n\n\n// useCount.js\n\n\nexport const useCount = () => {\n  const [count, setCount] = useState(0);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  return { count, increment };\n};\n\n\nThe renderHook function accepts the following arguments:\n\nCallback is a function that is called each render of the test component. This\nfunction should call one or more hooks for testing.\n\nThe props passed into the callback will be the initialProps provided in the\noptions to renderHook, unless new props are provided by a subsequent rerender\ncall.\n\n\noptions#\n\nA RenderHookOptions<Props> object to modify the execution of the callback\nfunction, containing the following properties:\n\ninitialProps #\n\nThe initial values to pass as props to the callback function of renderHook. The\nProps type is determined by the type passed to or inferred by the renderHook\ncall.\n\nwrapper#\n\nA React component to wrap the test component in when rendering. This is usually\nused to add context providers from React.createContext for the hook to access\nwith useContext.\n\n\nResult#\n\ninterface RenderHookResult<Result, Props> {\n  result: { current: Result };\n  rerender: (props: Props) => Promise<void>;\n  unmount: () => Promise<void>;\n}\n\n\nThe renderHook function returns a Promise that resolves to an object with the\nfollowing properties:\n\nresult#\n\nThe current value of the result will reflect the latest of whatever is returned\nfrom the callback passed to renderHook. The Result type is determined by the\ntype passed to or inferred by the renderHook call.\n\nNote: When using React Suspense, result.current will be null while the hook is\nsuspended.\n\nrerender#\n\nAn async function to rerender the test component, causing any hooks to be\nrecalculated. If newProps are passed, they will replace the callback function's\ninitialProps for subsequent rerenders. The Props type is determined by the type\npassed to or inferred by the renderHook call.\n\nNote: This method returns a Promise and should be awaited.\n\nunmount#\n\nAn async function to unmount the test component. This is commonly used to\ntrigger cleanup effects for useEffect hooks.\n\nNote: This method returns a Promise and should be awaited.\n\n\nExamples#\n\nHere we present some extra examples of using renderHook API.\n\nWith initialProps#\n\n\n\n\nconst useCount = (initialCount: number) => {\n  const [count, setCount] = useState(initialCount);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  useEffect(() => {\n    setCount(initialCount);\n  }, [initialCount]);\n\n  return { count, increment };\n};\n\nit('should increment count', async () => {\n  const { result, rerender } = await renderHook((initialCount: number) => useCount(initialCount), {\n    initialProps: 1,\n  });\n\n  expect(result.current.count).toBe(1);\n\n  await act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(2);\n  await rerender(5);\n  expect(result.current.count).toBe(5);\n});\n\n\nWith wrapper#\n\nit('should use context value', async () => {\n  function Wrapper({ children }: { children: ReactNode }) {\n    return <Context.Provider value=\"provided\">{children}</Context.Provider>;\n  }\n\n  const { result } = await renderHook(() => useHook(), { wrapper: Wrapper });\n  // ...\n});\n\n\nWith React Suspense#\n\n\n\n\nfunction useSuspendingHook(promise: Promise<string>) {\n  return React.use(promise);\n}\n\nit('handles hook with suspense', async () => {\n  let resolvePromise: (value: string) => void;\n  const promise = new Promise<string>((resolve) => {\n    resolvePromise = resolve;\n  });\n\n  const { result } = await renderHook(useSuspendingHook, {\n    initialProps: promise,\n    wrapper: ({ children }) => (\n      <React.Suspense fallback={<Text>Loading...</Text>}>{children}</React.Suspense>\n    ),\n  });\n\n  // Initially suspended, result should not be available\n  expect(result.current).toBeNull();\n\n  await act(() => resolvePromise('resolved'));\n  expect(result.current).toBe('resolved');\n});\n","routePath":"/14.x/docs/api/misc/render-hook","lang":"en","toc":[{"text":"`renderHook`","id":"renderhook","depth":2,"charIndex":-1},{"text":"`options`","id":"options","depth":3,"charIndex":-1},{"text":"`initialProps`","id":"initialprops","depth":4,"charIndex":-1},{"text":"`wrapper`","id":"wrapper","depth":4,"charIndex":-1},{"text":"Result","id":"result","depth":3,"charIndex":2336},{"text":"`result`","id":"result-1","depth":4,"charIndex":-1},{"text":"`rerender`","id":"rerender","depth":4,"charIndex":-1},{"text":"`unmount`","id":"unmount","depth":4,"charIndex":-1},{"text":"Examples","id":"examples","depth":3,"charIndex":3454},{"text":"With `initialProps`","id":"with-initialprops","depth":4,"charIndex":-1},{"text":"With `wrapper`","id":"with-wrapper","depth":4,"charIndex":-1},{"text":"With React Suspense","id":"with-react-suspense","depth":4,"charIndex":4501}],"frontmatter":{},"version":"14.x"},{"title":"Queries","content":"#\n\nQueries are one of the main building blocks for the React Native Testing\nLibrary. They enable you to find relevant elements in the element tree, which\nrepresents your application's user interface when running under tests.\n\n\nAccessing queries#\n\nAll queries described below are accessible in two main ways: through the screen\nobject or by capturing the render function call result.\n\n\nUsing screen object#\n\n\n\ntest('accessing queries using \"screen\" object', async () => {\n  await render(...);\n\n  screen.getByRole(\"button\", { name: \"Start\" });\n})\n\n\nThe modern and recommended way of accessing queries is to use the screen object\nexported by the @testing-library/react-native package. This object will contain\nmethods of all available queries bound to the most recently rendered UI.\n\n\nUsing render result#\n\n\n\ntest('accessing queries using \"render\" result', async () => {\n  const { getByRole } = await render(...);\n  getByRole(\"button\", { name: \"Start\" });\n})\n\n\nThe classic way is to capture query functions, as they are returned from the\nrender function call. This provides access to the same functions as in the case\nof the screen object.\n\n\nQuery parts#\n\nEach query is composed of two parts: variant and predicate, which are separated\nby the by word in the middle of the name.\n\nConsider the following query:\n\ngetByRole()\n\n\nFor this query, getBy* is the query variant, and *ByRole is the predicate.\n\n\nQuery variant#\n\nThe query variants describe the expected number (and timing) of matching\nelements, so they differ in their return type.\n\nVARIANT       ASSERTION                       RETURN TYPE                   IS ASYNC?\ngetBy*        Exactly one matching element    HostElement                   No\ngetAllBy*     At least one matching element   Array<HostElement>            No\nqueryBy*      Zero or one matching element                                  No\nqueryAllBy*   No assertion                    Array<HostElement>            No\nfindBy*       Exactly one matching element    Promise<HostElement>          Yes\nfindAllBy*    At least one matching element   Promise<Array<HostElement>>   Yes\n\nQueries work as implicit assertions on the number of matching elements and will\nthrow an error when the assertion fails.\n\n\ngetBy* queries #\n\ngetByX(...): HostElement\n\n\ngetBy* queries return the single matching element for a query, and throw an\nerror if no elements match or if more than one match is found. If you need to\nfind more than one element, then use getAllBy.\n\n\ngetAllBy* queries #\n\ngetAllByX(...): HostElement[]\n\n\ngetAllBy* queries return an array of all matching elements for a query and throw\nan error if no elements match.\n\n\nqueryBy* queries #\n\nqueryByX(...): HostElement | null\n\n\nqueryBy* queries return the first matching node for a query, and return null if\nno elements match. This is useful for asserting an element that is not present.\nThis throws if more than one match is found (use queryAllBy instead).\n\n\nqueryAllBy* queries #\n\nqueryAllByX(...): HostElement[]\n\n\nqueryAllBy* queries return an array of all matching nodes for a query and return\nan empty array ([]) when no elements match.\n\n\nfindBy* queries #\n\nfindByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<HostElement>\n\n\nfindBy* queries return a promise which resolves when a matching element is\nfound. The promise is rejected if no elements match or if more than one match is\nfound after a default timeout of 1000 ms. If you need to find more than one\nelement use findAllBy* queries.\n\n\nfindAllBy* queries #\n\nfindAllByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<HostElement[]>\n\n\nfindAllBy* queries return a promise which resolves to an array of matching\nelements. The promise is rejected if no elements match after a default timeout\nof 1000 ms.\n\nINFO\n\nfindBy* and findAllBy* queries accept optional waitForOptions object arguments,\nwhich can contain timeout, interval and onTimeout properties which have the same\nmeaning as respective options for waitFor function.\n\nINFO\n\nIn cases when your findBy* and findAllBy* queries throw when unable to find\nmatching elements, it is helpful to pass onTimeout: () => { screen.debug(); }\ncallback using the waitForOptions parameter.\n\n\nQuery predicates#\n\nNote: most methods like this one return a HostElement with following properties\nthat you may be interested in:\n\ntype HostElement = {\n  type: string;\n  props: { [propName: string]: any };\n  parent: HostElement | null;\n  children: Array<HostElement | string>;\n};\n\n\n\n*ByRole #\n\n> getByRole, getAllByRole, queryByRole, queryAllByRole, findByRole,\n> findAllByRole\n\ngetByRole(\n  role: TextMatch,\n  options?: {\n    name?: TextMatch\n    disabled?: boolean,\n    selected?: boolean,\n    checked?: boolean | 'mixed',\n    busy?: boolean,\n    expanded?: boolean,\n    value: {\n      min?: number;\n      max?: number;\n      now?: number;\n      text?: TextMatch;\n    },\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n\n\nReturns a HostElement with matching role or accessibilityRole prop.\n\nINFO\n\nIn order for *ByRole queries to match an element it needs to be considered an\naccessibility element:\n\n 1. Text, TextInput and Switch host elements are these by default.\n 2. View host elements need an explicit accessible prop set to true\n 3. Some React Native composite components like Pressable & TouchableOpacity\n    render host View element with accessible prop already set.\n\n\n\nawait render(\n  <Pressable accessibilityRole=\"button\" disabled>\n    <Text>Hello</Text>\n  </Pressable>\n);\nconst element = screen.getByRole('button');\nconst element2 = screen.getByRole('button', { name: 'Hello' });\nconst element3 = screen.getByRole('button', { name: 'Hello', disabled: true });\n\n\nOptions #\n\n * name: Finds an element with given role/accessibilityRole and an accessible\n   name (= accessability label or text content).\n\n * disabled: You can filter elements by their disabled state (coming either from\n   aria-disabled prop or accessbilityState.disabled prop). The possible values\n   are true or false. Querying disabled: false will also match elements with\n   disabled: undefined (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the disabled\n     state.\n   * This option can alternatively be expressed using the toBeEnabled() /\n     toBeDisabled() Jest matchers.\n\n * selected: You can filter elements by their selected state (coming either from\n   aria-selected prop or accessbilityState.selected prop). The possible values\n   are true or false. Querying selected: false will also match elements with\n   selected: undefined (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the selected\n     state.\n   * This option can alternatively be expressed using the toBeSelected() Jest\n     matcher.\n\n * checked: You can filter elements by their checked state (coming either from\n   aria-checked prop or accessbilityState.checked prop). The possible values are\n   true, false, or \"mixed\".\n   \n   * See React Native's accessibilityState docs to learn more about the checked\n     state.\n   * This option can alternatively be expressed using the toBeChecked() /\n     toBePartiallyChecked() Jest matchers.\n\n * busy: You can filter elements by their busy state (coming either from\n   aria-busy prop or accessbilityState.busy prop). The possible values are true\n   or false. Querying busy: false will also match elements with busy: undefined\n   (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the busy\n     state.\n   * This option can alternatively be expressed using the toBeBusy() Jest\n     matcher.\n\n * expanded: You can filter elements by their expanded state (coming either from\n   aria-expanded prop or accessbilityState.expanded prop). The possible values\n   are true or false.\n   \n   * See React Native's accessibilityState docs to learn more about the expanded\n     state.\n   * This option can alternatively be expressed using the toBeExpanded() /\n     toBeCollapsed() Jest matchers.\n\n * value: Filter elements by their accessibility value, based on either\n   aria-valuemin, aria-valuemax, aria-valuenow, aria-valuetext or\n   accessibilityValue props. Accessiblity value conceptually consists of numeric\n   min, max and now entries, as well as string text entry.\n   \n   * See React Native accessibilityValue docs to learn more about the\n     accessibility value concept.\n   * This option can alternatively be expressed using the\n     toHaveAccessibilityValue() Jest matcher.\n\n\n*ByLabelText #\n\n> getByLabelText, getAllByLabelText, queryByLabelText, queryAllByLabelText,\n> findByLabelText, findAllByLabelText\n\ngetByLabelText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n\n\nReturns a HostElement with matching label:\n\n * either by matching aria-label/accessibilityLabel prop\n * or by matching text content of view referenced by\n   aria-labelledby/accessibilityLabelledBy prop\n * or by matching the alt prop on Image elements\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByLabelText('my-label');\n\n\n\n*ByPlaceholderText #\n\n> getByPlaceholderText, getAllByPlaceholderText, queryByPlaceholderText,\n> queryAllByPlaceholderText, findByPlaceholderText, findAllByPlaceholderText\n\ngetByPlaceholderText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n\n\nReturns a HostElement for a TextInput with a matching placeholder – may be a\nstring or regular expression.\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByPlaceholderText('username');\n\n\n\n*ByDisplayValue #\n\n> getByDisplayValue, getAllByDisplayValue, queryByDisplayValue,\n> queryAllByDisplayValue, findByDisplayValue, findAllByDisplayValue\n\ngetByDisplayValue(\n  value: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n\n\nReturns a HostElement for a TextInput with a matching display value – may be a\nstring or regular expression.\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByDisplayValue('username');\n\n\n\n*ByText #\n\n> getByText, getAllByText, queryByText, queryAllByText, findByText,\n> findAllByText\n\ngetByText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n\n\nReturns a HostElement with matching text – may be a string or regular\nexpression.\n\nThis method will join <Text> siblings to find matches, similarly to how React\nNative handles these components. This will allow for querying for strings that\nwill be visually rendered together, but may be semantically separate React\ncomponents.\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByText('banana');\n\n\n\n*ByHintText #\n\n> getByA11yHint, getAllByA11yHint, queryByA11yHint, queryAllByA11yHint,\n> findByA11yHint, findAllByA11yHint getByAccessibilityHint,\n> getAllByAccessibilityHint, queryByAccessibilityHint,\n> queryAllByAccessibilityHint, findByAccessibilityHint,\n> findAllByAccessibilityHint getByHintText, getAllByHintText, queryByHintText,\n> queryAllByHintText, findByHintText, findAllByHintText\n\ngetByHintText(\n  hint: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n\n\nReturns a HostElement with matching accessibilityHint prop.\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByHintText('Plays a song');\n\n\nINFO\n\nPlease consult Apple guidelines on how accessibilityHint should be used.\n\n\n*ByTestId #\n\n> getByTestId, getAllByTestId, queryByTestId, queryAllByTestId, findByTestId,\n> findAllByTestId\n\ngetByTestId(\n  testId: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n\n\nReturns a HostElement with matching testID prop. testID – may be a string or a\nregular expression.\n\n\n\nawait render(<MyComponent />);\nconst element = screen.getByTestId('unique-id');\n\n\nINFO\n\nIn the spirit of the guiding principles, it is recommended to use this only\nafter the other queries don't work for your use case. Using testID attributes do\nnot resemble how your software is used and should be avoided if possible.\nHowever, they are particularly useful for end-to-end testing on real devices,\ne.g. using Detox and it's an encouraged technique to use there. Learn more from\nthe blog post \"Making your UI tests resilient to change\".\n\n\nCommon options#\n\nUsually query first argument can be a string or a regex. All queries take at\nleast the hidden option as an optionnal second argument and some queries accept\nmore options which change string matching behaviour. See TextMatch for more\ninfo.\n\nincludeHiddenElements option#\n\nAll queries have the includeHiddenElements option which affects whether elements\nhidden from accessibility are matched by the query. By default queries will not\nmatch hidden elements, because the users of the app would not be able to see\nsuch elements.\n\nYou can configure the default value with the configure function.\n\nThis option is also available as hidden alias for compatibility with React\nTesting Library.\n\nExamples\n\nawait render(<Text style={{ display: 'none' }}>Hidden from accessibility</Text>);\n\n// Exclude hidden elements\nexpect(\n  screen.queryByText('Hidden from accessibility', {\n    includeHiddenElements: false,\n  })\n).not.toBeOnTheScreen();\n\n// Include hidden elements\nexpect(screen.getByText('Hidden from accessibility')).toBeOnTheScreen();\nexpect(\n  screen.getByText('Hidden from accessibility', { includeHiddenElements: true })\n).toBeOnTheScreen();\n\n\n\nTextMatch type#\n\ntype TextMatch = string | RegExp;\n\n\nMost of the query APIs take a TextMatch as an argument, which means the argument\ncan be either a string or regex.\n\n\nExamples#\n\nGiven the following render:\n\nawait render(<Text>Hello World</Text>);\n\n\nWill find a match:\n\n// Matching a string:\nscreen.getByText('Hello World'); // full string match\nscreen.getByText('llo Worl', { exact: false }); // substring match\nscreen.getByText('hello world', { exact: false }); // ignore case-sensitivity\n\n// Matching a regex:\nscreen.getByText(/World/); // substring match\nscreen.getByText(/world/i); // substring match, ignore case\nscreen.getByText(/^hello world$/i); // full string match, ignore case-sensitivity\nscreen.getByText(/Hello W?oRlD/i); // advanced regex\n\n\nWill NOT find a match\n\n// substring does not match\nscreen.getByText('llo Worl');\n// full string does not match\nscreen.getByText('Goodbye World');\n\n// case-sensitive regex with different case\nscreen.getByText(/hello world/);\n\n\n\nOptions #\n\nPrecision#\n\ntype TextMatchOptions = {\n  exact?: boolean;\n  normalizer?: (text: string) => string;\n};\n\n\nQueries that take a TextMatch also accept an object as the second argument that\ncan contain options that affect the precision of string matching:\n\n * exact: Defaults to true; matches full strings, case-sensitive. When false,\n   matches substrings and is not case-sensitive.\n   * exact has no effect on regex argument.\n   * In most cases using a regex instead of a string gives you more control over\n     fuzzy matching and should be preferred over { exact: false }.\n * normalizer: An optional function which overrides normalization behavior. See\n   Normalization.\n\nexact option defaults to true but if you want to search for a text slice or make\ntext matching case-insensitive you can override it. That being said we advise\nyou to use regex in more complex scenarios.\n\nNormalization#\n\nBefore running any matching logic against text, it is automatically normalized.\nBy default, normalization consists of trimming whitespace from the start and end\nof text, and collapsing multiple adjacent whitespace characters into a single\nspace.\n\nIf you want to prevent that normalization, or provide alternative normalization\n(e.g. to remove Unicode control characters), you can provide a normalizer\nfunction in the options object. This function will be given a string and is\nexpected to return a normalized version of that string.\n\nINFO\n\nSpecifying a value for normalizer replaces the built-in normalization, but you\ncan call getDefaultNormalizer to obtain a built-in normalizer, either to adjust\nthat normalization or to call it from your own normalizer.\n\ngetDefaultNormalizer take options object which allows the selection of\nbehaviour:\n\n * trim: Defaults to true. Trims leading and trailing whitespace.\n * collapseWhitespace: Defaults to true. Collapses inner whitespace (newlines,\n   tabs repeated spaces) into a single space.\n\nNormalization Examples#\n\nTo perform a match against text without trimming:\n\nscreen.getByText('text', {\n  normalizer: getDefaultNormalizer({ trim: false }),\n});\n\n\nTo override normalization to remove some Unicode characters whilst keeping some\n(but not all) of the built-in normalization behavior:\n\nscreen.getByText('text', {\n  normalizer: (str) => getDefaultNormalizer({ trim: false })(str).replace(/[\\u200E-\\u200F]*/g, ''),\n});\n","routePath":"/14.x/docs/api/queries","lang":"en","toc":[{"text":"Accessing queries","id":"accessing-queries","depth":2,"charIndex":226},{"text":"Using `screen` object","id":"using-screen-object","depth":3,"charIndex":-1},{"text":"Using `render` result","id":"using-render-result","depth":3,"charIndex":-1},{"text":"Query parts","id":"query-parts","depth":2,"charIndex":1138},{"text":"Query variant","id":"query-variant","depth":2,"charIndex":1397},{"text":"`getBy*` queries","id":"getby-queries","depth":3,"charIndex":-1},{"text":"`getAllBy*` queries","id":"getallby-queries","depth":3,"charIndex":-1},{"text":"`queryBy*` queries","id":"queryby-queries","depth":3,"charIndex":-1},{"text":"`queryAllBy*` queries","id":"queryallby-queries","depth":3,"charIndex":-1},{"text":"`findBy*` queries","id":"findby-queries","depth":3,"charIndex":-1},{"text":"`findAllBy*` queries","id":"findallby-queries","depth":3,"charIndex":-1},{"text":"Query predicates","id":"query-predicates","depth":2,"charIndex":4239},{"text":"`*ByRole`","id":"byrole","depth":3,"charIndex":-1},{"text":"Options","id":"options","depth":4,"charIndex":-1},{"text":"`*ByLabelText`","id":"bylabeltext","depth":3,"charIndex":-1},{"text":"`*ByPlaceholderText`","id":"byplaceholdertext","depth":3,"charIndex":-1},{"text":"`*ByDisplayValue`","id":"bydisplayvalue","depth":3,"charIndex":-1},{"text":"`*ByText`","id":"bytext","depth":3,"charIndex":-1},{"text":"`*ByHintText`","id":"byhinttext","depth":3,"charIndex":-1},{"text":"`*ByTestId`","id":"bytestid","depth":3,"charIndex":-1},{"text":"Common options","id":"common-options","depth":3,"charIndex":12692},{"text":"`includeHiddenElements` option","id":"includehiddenelements-option","depth":4,"charIndex":-1},{"text":"TextMatch type","id":"textmatch-type","depth":2,"charIndex":13851},{"text":"Examples","id":"examples","depth":3,"charIndex":14020},{"text":"Options","id":"options-1","depth":3,"charIndex":-1},{"text":"Precision","id":"precision","depth":4,"charIndex":14846},{"text":"Normalization","id":"normalization","depth":4,"charIndex":15718}],"frontmatter":{},"version":"14.x"},{"title":"`render` API","content":"render API#\n\n\nrender function #\n\nasync function render<T>(\n  element: React.ReactElement<T>,\n  options?: RenderOptions\n): Promise<RenderResult>;\n\n\nThe render function is the entry point for writing React Native Testing Library\ntests. It deeply renders the given React element and returns helpers to query\nthe output components' structure. This function is async by default and uses\nasync act internally to ensure all pending React updates are executed during\nrendering, making it compatible with async React features like Suspense boundary\nor use() hook.\n\n\n\ntest('basic test', async () => {\n  await render(<MyApp />);\n  expect(screen.getAllByRole('button', { name: 'start' })).toBeOnTheScreen();\n});\n\n\n> When using React context providers, like Redux Provider, you'll likely want to\n> wrap rendered component with them. In such cases, it's convenient to create\n> your own custom render method. Follow this great guide on how to set this up.\n\n\nOptions#\n\nThe behavior of the render method can be customized by passing various options\nas a second argument of the RenderOptions type:\n\nwrapper#\n\nwrapper?: React.ComponentType<any>,\n\n\nThis option allows you to wrap the tested component, passed as the first option\nto the render() function, in an additional wrapper component. This is useful for\ncreating reusable custom render functions for common React Context providers.\n\ncreateNodeMock #\n\ncreateNodeMock?: (element: React.ReactElement) => object,\n\n\nThis option allows you to pass createNodeMock option to the renderer's create()\nmethod in order to allow for custom mock refs. This option is passed through to\nTest Renderer.\n\nText string validation\n\nTest Renderer automatically enforces React Native's requirement that text\nstrings must be rendered within a <Text> component. If you try to render a\nstring value under components other than <Text> (e.g., under <View>), it will\nthrow an Invariant Violation: Text strings must be rendered within a <Text>\ncomponent error, matching React Native's runtime behavior.\n\nThis validation is always enabled and cannot be disabled, ensuring your tests\naccurately reflect how your code will behave in production.\n\n\nResult#\n\nThe render function returns a promise that resolves to the same queries and\nutilities as the screen object. We recommend using the screen object for queries\nand the lifecycle methods from the render result when needed.\n\nSee this article from Kent C. Dodds for more details.\n\nType information\n\nQuery results and element references use the HostElement type from Test\nRenderer. If you need to type element variables, you can import this type\ndirectly from test-renderer.","routePath":"/14.x/docs/api/render","lang":"en","toc":[{"text":"`render` function","id":"render-function","depth":2,"charIndex":-1},{"text":"Options","id":"options","depth":3,"charIndex":942},{"text":"`wrapper`","id":"wrapper","depth":4,"charIndex":-1},{"text":"`createNodeMock`","id":"createnodemock","depth":4,"charIndex":-1},{"text":"Result","id":"result","depth":3,"charIndex":2149}],"frontmatter":{},"version":"14.x"},{"title":"`screen` object","content":"screen object#\n\nlet screen: {\n  ...queries;\n  rerender(element: React.Element<unknown>): Promise<void>;\n  unmount(): Promise<void>;\n  debug(options?: DebugOptions): void\n  toJSON(): JsonElement | null;\n  container: HostElement;\n  root: HostElement | null;\n};\n\n\nThe screen object offers a recommended way to access queries and utilities for\nthe currently rendered UI.\n\nThis object is assigned after the render call and cleared after each test by\ncalling cleanup. If no render call has been made in a given test, then it holds\na special object and throws a helpful error on each property and method access.\n\n\n...queries#\n\nThe most important feature of screen is providing a set of helpful queries that\nallow you to find certain elements in the view hierarchy.\n\nSee Queries for a complete list.\n\nExample#\n\n\n\ntest('example', async () => {\n  await render(<MyComponent />);\n  const buttonStart = screen.getByRole('button', { name: 'start' });\n});\n\n\n\nrerender#\n\nfunction rerender(element: React.Element<unknown>): Promise<void>;\n\n\nRe-render the in-memory tree with a new root element. This simulates a React\nupdate render at the root. If the new element has the same type (and key) as the\nprevious element, the tree will be updated; otherwise, it will re-mount a new\ntree, in both cases triggering the appropriate lifecycle events.\n\nThis method is async and uses async act function internally to ensure all\npending React updates are executed during updating, making it compatible with\nasync React features like Suspense boundary or use() hook.\n\n\n\ntest('async rerender test', async () => {\n  await render(<MyComponent initialData=\"first\" />);\n\n  await screen.rerender(<MyComponent initialData=\"updated\" />);\n  expect(screen.getByText('updated')).toBeOnTheScreen();\n});\n\n\n\nunmount#\n\nfunction unmount(): Promise<void>;\n\n\nUnmount the in-memory tree, triggering the appropriate lifecycle events.\n\nThis method is async and uses async act function internally to ensure all\npending React updates are executed during unmounting, making it compatible with\nasync React features like Suspense boundary or use() hook.\n\nNOTE\n\nUsually you should not need to call unmount as it is done automatically if your\ntest runner supports afterEach hook (like Jest, mocha, Jasmine).\n\n\ndebug#\n\nfunction debug(options?: { message?: string; mapProps?: MapPropsFunction }): void;\n\n\nPretty prints deeply rendered component passed to render.\n\nmessage option #\n\nYou can provide a message that will be printed on top.\n\nawait render(<Component />);\nscreen.debug({ message: 'optional message' });\n\n\nlogs optional message and colored JSX:\n\noptional message\n\n<View\n  onPress={[Function bound fn]}\n>\n  <Text>Press me</Text>\n</View>\n\n\nmapProps option #\n\nfunction debug({ mapProps: (props) => ({}) });\n\n\nYou can use the mapProps option to transform the props that will be printed :\n\nawait render(<View style={{ backgroundColor: 'red' }} />);\nscreen.debug({ mapProps: ({ style, ...props }) => ({ props }) });\n\n\nThis will log the rendered JSX without the style props.\n\nThe children prop cannot be filtered out so the following will print all\nrendered components with all props but children filtered out.\n\nThis option can be used to target specific props when debugging a query (for\ninstance, keeping only the children prop when debugging a getByText query).\n\nYou can also transform prop values so that they are more readable (e.g., flatten\nstyles).\n\n\n\nscreen.debug({\n  mapProps: ({ style, ...props }) => ({ style: StyleSheet.flatten(style), ...props }),\n});\n\n\nOr remove props that have little value when debugging tests, e.g. path prop for\nsvgs\n\nscreen.debug({ mapProps: ({ path, ...props }) => ({ ...props }) });\n\n\n\ntoJSON#\n\nfunction toJSON(): JsonElement | null;\n\n\nGet the rendered component JSON representation, e.g. for snapshot testing.\n\n\ncontainer#\n\nconst container: HostElement;\n\n\nReturns a pseudo-element container whose children are the elements you asked to\nrender. This is the root container element from Test Renderer.\n\nThe container is safe to use and provides access to the entire rendered tree.\nIt's useful when you need to query or manipulate the entire rendered output,\nsimilar to how container works in React Testing Library.\n\n\n\ntest('example', async () => {\n  await render(<MyComponent />);\n  // container contains the entire rendered tree\n  const container = screen.container;\n  expect(container).toBeTruthy();\n});\n\n\n\nroot#\n\nconst root: HostElement | null;\n\n\nReturns the rendered root host element, or null if nothing was rendered. This is\nthe first child of the container, which represents the actual root element you\nrendered.\n\nThis API is primarily useful for component tests, as it allows you to access\nroot host view without using *ByTestId queries or similar methods.\n\nNOTE\n\nIn rare cases where your root element is a React.Fragment with multiple\nchildren, the container will have more than one child, and root will return only\nthe first one. In such cases, use container.children to access all rendered\nelements.\n\n\n\ntest('example', async () => {\n  await render(\n    <View testID=\"root-view\">\n      <Text>Hello</Text>\n    </View>\n  );\n  // root is the View element you rendered\n  expect(screen.root.props.testID).toBe('root-view');\n});\n","routePath":"/14.x/docs/api/screen","lang":"en","toc":[{"text":"`...queries`","id":"queries","depth":3,"charIndex":-1},{"text":"Example","id":"example","depth":4,"charIndex":792},{"text":"`rerender`","id":"rerender","depth":3,"charIndex":-1},{"text":"`unmount`","id":"unmount","depth":3,"charIndex":-1},{"text":"`debug`","id":"debug","depth":3,"charIndex":-1},{"text":"`message` option","id":"message-option","depth":4,"charIndex":-1},{"text":"`mapProps` option","id":"mapprops-option","depth":4,"charIndex":-1},{"text":"`toJSON`","id":"tojson","depth":3,"charIndex":-1},{"text":"`container`","id":"container","depth":3,"charIndex":-1},{"text":"`root`","id":"root","depth":3,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Community resources","content":"#\n\n\nRecommended content#\n\n * The Testing Trophy and Testing Classifications by Kent C. Dodds (2021) -\n   classic article explaining testing philosophy behind all Testing Library\n   implementations.\n * Common mistakes with React Testing Library by Kent C. Dodds (2020) - classic\n   article explaining React Testing Library best practices, highly applicable to\n   RNTL as well.\n * React Native — UI Testing (Ultimate Guide) by Anisur Rahman - comprehensive\n   guide to RNTL testing\n * React Native Testing examples repo by Steve Galili - extensive repo with RN\n   testing examples for RNTL and Maestro\n\n\nOlder, potentially outdated content#\n\n * Where and how to start testing 🧪 your react-native app ⚛️ and how to keep on\n   testin’ by Steve Galili (2020) - article referencing Steve's examples repo.\n * Intro to React Native Testing Library & Jest Native by Alireza Ghamkhar\n   (2020) - video tutorial on RNTL setup and testing.","routePath":"/14.x/docs/guides/community-resources","lang":"en","toc":[{"text":"Recommended content","id":"recommended-content","depth":2,"charIndex":3},{"text":"Older, potentially outdated content","id":"older-potentially-outdated-content","depth":2,"charIndex":601}],"frontmatter":{},"version":"14.x"},{"title":"FAQ","content":"#\n\n\nCan I test the native features of React Native apps?#\n\nShort answer: no.\n\nReact Native Testing Library does not provide an entire React Native runtime\nsince that would require running on a physical device or iOS simulator/Android\nemulator to provision the underlying OS and platform APIs.\n\nInstead of using React Native renderer, it simulates only the JavaScript part of\nits runtime using Test Renderer while providing queries and event APIs (User\nEvent, Fire Event) that mimicking certain behaviors from the actual runtime.\n\nYou can learn more about our testing environment here.\n\nThis approach has specific benefits and shortfalls. On the positive side:\n\n * it allows testing most of the logic of regular React Native apps\n * it allows running tests on any OS supported by Jest or other test runners,\n   e.g., on CI\n * it uses much less resources than full runtime simulation\n * you can use Jest fake timers\n\nOn the negative side:\n\n * you cannot test native features\n * it might not perfectly simulate certain JavaScript features, but we are\n   working on it\n\nThe User Event interactions solve some of the simulation issues, as they offer\nmore realistic event handling than the basic Fire Event API.\n\n\nShould I use/migrate to screen queries?#\n\nThere is no need to migrate existing test code to use screen-bases queries. You\ncan still use queries and other functions returned by render. The screen object\ncaptures the latest render result.\n\nFor new code, you are encouraged to use screen as there are some good reasons\nfor that, which are described in this article by Kent C. Dodds.\n\n\nShould I use/migrate to User Event interactions?#\n\nWe encourage you to migrate existing tests to use the User Event interactions,\nwhich offer more realistic event handling than the basic Fire Event API. Hence,\nit will provide more confidence in the quality of your code.","routePath":"/14.x/docs/guides/faq","lang":"en","toc":[{"text":"Can I test the native features of React Native apps?","id":"can-i-test-the-native-features-of-react-native-apps","depth":2,"charIndex":3},{"text":"Should I use/migrate to `screen` queries?","id":"should-i-usemigrate-to-screen-queries","depth":2,"charIndex":-1},{"text":"Should I use/migrate to User Event interactions?","id":"should-i-usemigrate-to-user-event-interactions","depth":2,"charIndex":1589}],"frontmatter":{},"version":"14.x"},{"title":"How should I query?","content":"#\n\nReact Native Testing Library provides various query types, allowing great\nflexibility in finding views appropriate for your tests. At the same time, the\nnumber of queries might be confusing. This guide aims to help you pick the\ncorrect queries for your test scenarios.\n\n\nQuery parts#\n\nEach query is composed of two parts: variant and predicate, which are separated\nby the by word in the middle of the query.\n\nConsider the following query:\n\ngetByRole();\n\n\nFor this query, getBy* is the query variant, and *ByRole is the predicate.\n\n\nQuery variant#\n\nThe query variants describe the expected number (and timing) of matching\nelements, so they differ in their return type.\n\nVARIANT       ASSERTION                       RETURN TYPE                   IS ASYNC?\ngetBy*        Exactly one matching element    HostElement                   No\ngetAllBy*     At least one matching element   Array<HostElement>            No\nqueryBy*      Zero or one matching element                                  No\nqueryAllBy*   No assertion                    Array<HostElement>            No\nfindBy*       Exactly one matching element    Promise<HostElement>          Yes\nfindAllBy*    At least one matching element   Promise<Array<HostElement>>   Yes\n\nQueries work as implicit assertions on the number of matching elements and will\nthrow an error when the assertion fails.\n\n\nIdiomatic query variants#\n\nIdiomatic query variants clarify test intent and the expected number of matching\nelements. They will also throw helpful errors if assertions fail to help\ndiagnose the issues.\n\nHere are general guidelines for picking idiomatic query variants:\n\n 1. Use getBy* in the most common case when you expect a single matching\n    element. Use other queries only in more specific cases.\n 2. Use findBy* when an element is not yet in the element tree, but you expect\n    it to be there as a result of some asynchronous action.\n 3. Use getAllBy* (and findAllBy* for async) if you expect more than one\n    matching element, e.g. in a list.\n 4. Use queryBy* only when element should not exist to use it together with e.g.\n    not.toBeOnTheScreen() matcher.\n\nAvoid using queryAllBy* in regular tests, as it provides no assertions on the\nnumber of matching elements. You may still find it useful when building reusable\ncustom testing tools.\n\n\nQuery predicate#\n\nThe query predicate describes how you decide whether to match the given element.\n\nPREDICATE            SUPPORTED ELEMENTS   INSPECTED PROPS\n*ByRole              all host elements    role, accessibilityRole, optional: accessible name,\n                                          accessibility state and value\n*ByLabelText         all host elements    aria-label, aria-labelledby, accessibilityLabel,\n                                          accessibilityLabelledBy, alt (for Image)\n*ByDisplayValue      TextInput            value, defaultValue\n*ByPlaceholderText   TextInput            placeholder\n*ByText              Text                 children (text content)\n*ByHintText          all host elements    accessibilityHint\n*ByTestId            all host elements    testID\n\n\nIdiomatic query predicates#\n\nChoosing the proper query predicate helps better express the test's intent and\nmake the tests resemble how users interact with your code (components, screens,\netc.) as much as possible following our Guiding Principles. Additionally, most\npredicates promote the usage of proper accessibility props, which add a semantic\nlayer on top of an element tree composed primarily of View elements.\n\nIt is recommended to use query predicates in the following order of priority:\n\n\n1. By Role query #\n\nThe first and most versatile predicate is *ByRole, which starts with the\nsemantic role of the element and can be further narrowed down with additional\noptions. React Native has two role systems, the web/ARIA-compatible one based on\nrole prop and the traditional one based on accessibilityRole prop, you can use\neither of these.\n\nIn most cases, you need to set accessibility roles explicitly (or your component\nlibrary can set some of them for you). These roles allow assistive technologies\n(like screen readers) and testing code to understand your view hierarchy better.\n\nSome frequently used roles include:\n\n * alert - important text to be presented to the user, e.g., error message\n * button\n * checkbox & switch - on/off controls\n * heading (header) - header for content section, e.g., the title of navigation\n   bar\n * img (image)\n * link\n * menu & menuitem\n * progressbar\n * radiogroup & radio\n * searchbox (search)\n * slider (adjustable)\n * summary\n * tablist & tab\n * text - static text that cannot change\n * toolbar - container for action buttons\n\nName option #\n\nFrequently, you will want to add the name option, which will match both the\nelement's role and its accessible name (= element's accessibility label or text\ncontent).\n\nHere are a couple of examples:\n\n * start button: getByRole(\"button\", { name: \"Start\" })\n * silent mode switch: getByRole(\"switch\", { name: \"Silent Mode\" })\n * screen header: getByRole(\"header\", { name: \"Settings\" })\n * undo menu item: getByRole(\"menuitem\", { name: \"Undo\" })\n * error messages: getByRole(\"alert\", { name: /Not logged in/ })\n\n\n2. Text input queries #\n\nQuerying TextInput elements presents a unique challenge as there is no separate\nrole for TextInput elements. There is a searchbox/search role, which can be\nassigned to TextInput, but it should be only used in the context of search\ninputs, leaving other text inputs without a role to query with.\n\nTherefore, you can use the following queries to find relevant text inputs:\n\n 1. *ByLabelText - will match the accessibility label of the element. This query\n    will match any host elements, including TextInput elements.\n 2. *ByPlaceholderText - will match the placeholder of TextInput element. This\n    query will match only TextInput elements.\n 3. *ByDisplayValue - will the current (or default) value of TextInput element.\n    This query will match only TextInput elements.\n\n\n3. Other accessible queries #\n\nThese queries reflect the apps' user experience, both visual and through\nassistive technologies (e.g. screen reader).\n\nThese queries include:\n\n * *ByText - will match the text content of the element. This query will match\n   only Text elements.\n * *ByLabelText - will match the accessibility label of the element.\n * *ByHintText - will match the accessibility hint of the element.\n\n\n4. Test ID query #\n\nAs a final predicate, you can use the testID prop to find relevant views. Using\nthe *ByTestId predicate offers the most flexibility, but at the same time, it\ndoes not represent the user experience, as users are not aware of test IDs.\n\nNote that using test IDs is a widespread technique in end-to-end testing due to\nvarious issues with querying views through other means in its specific context.\nNevertheless, we still encourage you to use recommended RNTL queries as it will\nmake your integration and component test more reliable and resilient.","routePath":"/14.x/docs/guides/how-to-query","lang":"en","toc":[{"text":"Query parts","id":"query-parts","depth":2,"charIndex":273},{"text":"Query variant","id":"query-variant","depth":2,"charIndex":534},{"text":"Idiomatic query variants","id":"idiomatic-query-variants","depth":3,"charIndex":1357},{"text":"Query predicate","id":"query-predicate","depth":2,"charIndex":2310},{"text":"Idiomatic query predicates","id":"idiomatic-query-predicates","depth":3,"charIndex":3101},{"text":"1. By Role query","id":"1-by-role-query","depth":3,"charIndex":-1},{"text":"Name option","id":"name-option","depth":4,"charIndex":-1},{"text":"2. Text input queries","id":"2-text-input-queries","depth":3,"charIndex":-1},{"text":"3. Other accessible queries","id":"3-other-accessible-queries","depth":3,"charIndex":-1},{"text":"4. Test ID query","id":"4-test-id-query","depth":3,"charIndex":-1}],"frontmatter":{},"version":"14.x"},{"title":"Troubleshooting","content":"#\n\nThis guide describes common issues found by users when integrating React Native\nTest Library to their projects:\n\n\nExample repository#\n\nWe maintain an example repository that showcases a modern React Native Testing\nLibrary setup with TypeScript, etc.\n\nIn case something does not work in your setup you can refer to this repository\nfor recommended configuration.\n\n\nUndefined component error#\n\n> Warning: React.jsx: type is invalid -- expected a string (for built-in\n> components) or a class/function (for composite components) but got: undefined.\n\nThis frequently happens when you mock a complex module incorrectly, e.g.:\n\njest.mock('@react-navigation/native', () => {\n  return {\n    useNavigation: jest.fn(),\n  };\n});\n\n\nThe above mock will mock useNavigation hook as intended, but at the same time\nall other exports from @react-navigation/native package are now undefined. If\nyou want to use NavigationContainer component from the same package it will be\nundefined and result in the error above.\n\nIn order to mock only a part of given package you should re-export all other\nexports using jest.requireActual helper:\n\njest.mock('@react-navigation/native', () => {\n  return {\n    ...jest.requireActual('@react-navigation/native'),\n    useNavigation: jest.fn(),\n  };\n});\n\n\nThat way the mock will re-export all of the @react-navigation/native members and\noverwrite only the useNavigation hook.\n\nAlternatively, you can use jest.spyOn to mock package exports selectively.\n\n\nMocking React Native#\n\nIn case of mocking react-native package you should not mock the whole package at\nonce, as this approach has issues with jest.requireActual call. In this case it\nis recommended to mock particular library paths inside the package, e.g.:\n\njest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');\n\n\n\nAct warnings#\n\nWhen writing tests you may encounter warnings connected with act() function.\nThere are two kinds of these warnings:\n\n * sync act() warning - Warning: An update to Component inside a test was not\n   wrapped in act(...)\n * async act() warning - Warning: You called act(async () => ...) without await\n\nYou can read more about act() function in our understanding act function guide.\n\nNormally, you should not encounter sync act() warnings, but if that happens this\nprobably indicate an issue with your test and should be investigated.\n\nIn case of async act() function this might happen more or less randomly,\nespecially if your components contain async logic. So far this warning does not\nseem to affect test correctness.","routePath":"/14.x/docs/guides/troubleshooting","lang":"en","toc":[{"text":"Example repository","id":"example-repository","depth":2,"charIndex":116},{"text":"Undefined component error","id":"undefined-component-error","depth":2,"charIndex":365},{"text":"Mocking React Native","id":"mocking-react-native","depth":3,"charIndex":1468},{"text":"Act warnings","id":"act-warnings","depth":2,"charIndex":1799}],"frontmatter":{},"version":"14.x"},{"title":"Introduction","content":"#\n\nAlpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the\nstable release. Please report any issues you encounter.\n\n\nThe problem#\n\nYou want to write maintainable tests for your React Native components. As a part\nof this goal, you want your tests to avoid including implementation details of\nyour components and focus on making your tests give you the confidence they are\nintended. As part of this, you want your tests to be maintainable in the long\nrun so refactors of your components (changes to implementation but not\nfunctionality) don't break your tests and slow you and your team down.\n\n\nThis solution#\n\nThe React Native Testing Library (RNTL) is a comprehensive solution for testing\nReact Native components. It provides React Native runtime simulation on top of\nTest Renderer, in a way that encourages better testing practices. Its primary\nguiding principle is:\n\n> The more your tests resemble how your software is used, the more confidence\n> they can give you.\n\nThis project is inspired by React Testing Library. It is tested to work with\nJest, but it should work with other test runners as well.\n\n\nExample#\n\n\n\n\ntest('form submits two answers', async () => {\n  const questions = ['q1', 'q2'];\n  const onSubmit = jest.fn();\n\n  const user = userEvent.setup();\n  await render(<QuestionsBoard questions={questions} onSubmit={onSubmit} />);\n\n  const answerInputs = screen.getAllByLabelText('answer input');\n  await user.type(answerInputs[0], 'a1');\n  await user.type(answerInputs[1], 'a2');\n  await user.press(screen.getByRole('button', { name: 'Submit' }));\n\n  expect(onSubmit).toHaveBeenCalledWith({\n    1: { q: 'q1', a: 'a1' },\n    2: { q: 'q2', a: 'a2' },\n  });\n});\n\n\nYou can find the source of the QuestionsBoard component and this example here.","routePath":"/14.x/docs/start/intro","lang":"en","toc":[{"text":"The problem","id":"the-problem","depth":2,"charIndex":151},{"text":"This solution","id":"this-solution","depth":2,"charIndex":627},{"text":"Example","id":"example","depth":2,"charIndex":1140}],"frontmatter":{},"version":"14.x"},{"title":"Migration to 14.x","content":"#\n\nAlpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the\nstable release. Please report any issues you encounter.\n\nThis guide describes the migration to React Native Testing Library version 14\nfrom version 13.x.\n\n\nOverview#\n\nRNTL v14 is a major release that drops support for React 18 and fully embraces\nReact 19's async-first paradigm. Key changes include:\n\n * React 19+ required: Minimum supported versions are React 19.0.0 and React\n   Native 0.78+\n * Async APIs by default: render, renderHook, fireEvent, and act are now async\n * New renderer: Switched from deprecated React Test Renderer to Test Renderer\n * API cleanup: Removed deprecated APIs (update, getQueriesForElement,\n   UNSAFE_root, concurrentRoot option)\n * Safe container API: Reintroduced container which is now safe to use\n\nReact 18 Users\n\nIf you need to support React 18, please continue using RNTL v13.x.\n\n\nQuick Migration#\n\nWe provide codemods to automate most of the migration:\n\nStep 1: Update dependencies\n\nStep 2: Update test code to async\n\nAfter running the codemods, review the changes and run your tests.\n\n\nBreaking Changes#\n\n\nSupported React and React Native versions#\n\nThis version requires React 19+ and React Native 0.78+. If you need to support\nReact 18, please use the latest v13.x version.\n\nRNTL VERSION   REACT VERSION   REACT NATIVE VERSION\nv14.x          >= 19.0.0       >= 0.78\nv13.x          >= 18.0.0       >= 0.71\n\n\nTest Renderer replaces React Test Renderer#\n\nIn v14, React Native Testing Library now uses Test Renderer instead of the\ndeprecated React Test Renderer. Test Renderer is a modern, actively maintained\nalternative that provides better compatibility with React 19 and improved type\nsafety.\n\nWhat changed:\n\n * The underlying renderer has been switched from React Test Renderer to Test\n   Renderer\n * This change is mostly internal and should not require code changes in most\n   cases\n * Type definitions have been updated to use HostElement from Test Renderer\n   instead of ReactTestInstance\n\nMigration:\n\n1. Update dependencies#\n\nRun codemod for updating dependencies:\n\nManual changes#\n\nRemove React Test Renderer and its type definitions from your dev dependencies,\nand add Test Renderer:\n\n2. Update type imports (if needed)#\n\nIf you were directly importing types from React Test Renderer, you may need to\nupdate your imports:\n\n// Before (v13)\n\n\n// After (v14)\n\n\n\nNote: Most users won't need to update type imports, as React Native Testing\nLibrary now exports the necessary types directly.\n\nFor more details, see the Test Renderer documentation.\n\n\nAsync APIs by Default#\n\nWith React 18 support dropped, RNTL v14 fully embraces React 19's async\nrendering model. The following functions are now async by default:\n\n * render() → returns Promise<RenderResult>\n * rerender() and unmount() → return Promise<void>\n * renderHook() → returns Promise<RenderHookResult>\n * fireEvent() and helpers (press, changeText, scroll) → return Promise<void>\n * act() → always returns Promise<T>\n\nAlready using async APIs?\n\nIf you adopted the async APIs introduced in RNTL v13.3 (renderAsync,\nfireEventAsync, renderHookAsync), simply rename them to their non-async\ncounterparts (render, fireEvent, renderHook). The async versions have been\nremoved as the standard APIs are now async by default.\n\nrender is now async #\n\nIn v14, render is now async by default and returns a Promise. This change\nenables proper support for async React features like Suspense boundary or use()\nhook.\n\nBefore (v13):\n\n\n\nit('should render component', () => {\n  render(<MyComponent />);\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n\n\nAfter (v14):\n\n\n\nit('should render component', async () => {\n  await render(<MyComponent />);\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n\n\nFor more details, see the render API documentation.\n\nrenderHook is now async#\n\nIn v14, renderHook is now async by default and returns a Promise.\n\nBefore (v13):\n\n\n\nit('should test hook', () => {\n  const { result, rerender } = renderHook(() => useMyHook());\n\n  rerender(newProps);\n  unmount();\n});\n\n\nAfter (v14):\n\n\n\nit('should test hook', async () => {\n  const { result, rerender } = await renderHook(() => useMyHook());\n\n  await rerender(newProps);\n  await unmount();\n});\n\n\nFor more details, see the renderHook API documentation.\n\nfireEvent is now async#\n\nIn v14, fireEvent and its helpers (press, changeText, scroll) are now async by\ndefault and return a Promise.\n\nBefore (v13):\n\n\n\nit('should press button', () => {\n  render(<MyComponent />);\n  fireEvent.press(screen.getByText('Press me'));\n  expect(onPress).toHaveBeenCalled();\n});\n\n\nAfter (v14):\n\n\n\nit('should press button', async () => {\n  await render(<MyComponent />);\n  await fireEvent.press(screen.getByText('Press me'));\n  expect(onPress).toHaveBeenCalled();\n});\n\n\nact is now async#\n\nIn v14, act is now async by default and always returns a Promise. You should\nalways await the result of act().\n\nWhat changed:\n\n * act now always returns a Promise<T> instead of T | Thenable<T>\n * act should always be awaited\n * The API is more consistent and predictable\n\nNOTE\n\nThe transition to async act may prevent testing very short transient states, as\nawaiting act will flush all pending updates before returning.\n\nBefore (v13):\n\n\n\nit('should update state', () => {\n  act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n\n\nAfter (v14):\n\n\n\nit('should update state', async () => {\n  await act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n\n\nNote: Even if your callback is synchronous, you should still use await act(...)\nas act now always returns a Promise.\n\nFor more details, see the act API documentation.\n\nBenefits of Async APIs#\n\n * Suspense support: Properly handles Suspense boundaries and use() hook\n * Better timing: Ensures all pending React updates are executed before\n   assertions\n * Simpler mental model: All rendering operations are consistently async\n * Future-proof: Aligns with React's direction toward async rendering\n\n\nRemoved APIs#\n\nupdate alias removed#\n\nThe update alias for rerender has been removed. Use rerender instead:\n\n// Before (v13)\nscreen.update(<MyComponent />);\nconst { update } = render(<MyComponent />);\nupdate(<MyComponent newProp />);\n\n// After (v14)\nawait screen.rerender(<MyComponent />);\nconst { rerender } = await render(<MyComponent />);\nawait rerender(<MyComponent newProp />);\n\n\ngetQueriesForElement export removed#\n\nThe getQueriesForElement export alias for within has been removed. Use within\ninstead:\n\n// Before (v13)\n\n\nconst queries = getQueriesForElement(element);\n\n// After (v14)\n\n\nconst queries = within(element);\n\n\nNote: getQueriesForElement was just an alias for within, so the functionality is\nidentical - only the import needs to change.\n\nUNSAFE_root removed#\n\nUNSAFE_root has been removed. Use container to access the pseudo-element\ncontainer, or root to access the first rendered host element:\n\n// Before (v13)\nconst unsafeRoot = screen.UNSAFE_root;\n\n// After (v14)\nconst container = screen.container; // pseudo-element container\nconst root = screen.root; // first rendered host element\n\n\nLegacy UNSAFE_* queries removed#\n\nThe legacy UNSAFE_getAllByType, UNSAFE_getByType, UNSAFE_getAllByProps, and\nUNSAFE_getByProps queries have been removed. These queries could return\ncomposite (user-defined) components, which is no longer supported with Test\nRenderer as it only renders host elements.\n\nIf you were using these legacy queries, you should refactor your tests to use\nthe standard queries (getByRole, getByText, getByTestId, etc.) which target host\nelements.\n\n// Before (v13)\nconst buttons = screen.UNSAFE_getAllByType(Button);\nconst input = screen.UNSAFE_getByProps({ placeholder: 'Enter text' });\n\n// After (v14)\nconst buttons = screen.getAllByRole('button');\nconst input = screen.getByPlaceholderText('Enter text');\n\n\nconcurrentRoot option removed#\n\nThe concurrentRoot option has been removed from both render options and\nconfigure function. In v14, concurrent rendering is always enabled by default,\nas it is the standard rendering mode for React 19 and React Native's New\nArchitecture.\n\n// Before (v13)\nrender(<MyComponent />, { concurrentRoot: true });  // Enable concurrent mode\nrender(<MyComponent />, { concurrentRoot: false }); // Disable concurrent mode\nconfigure({ concurrentRoot: false });               // Disable globally\n\n// After (v14)\nawait render(<MyComponent />); // Always uses concurrent rendering\n\n\nMigration: Simply remove any concurrentRoot options from your render calls and\nconfigure function. If you were explicitly setting concurrentRoot: true, no\nchanges are needed beyond removing the option. If you were setting\nconcurrentRoot: false to disable concurrent rendering, this is no longer\nsupported in v14.\n\n\ncontainer API reintroduced#\n\nIn v14, the container API has been reintroduced and is now safe to use.\nPreviously, container was renamed to UNSAFE_root in v12 due to behavioral\ndifferences from React Testing Library's container. In v14, container now\nreturns a pseudo-element container whose children are the elements you asked to\nrender, making it safe and consistent with React Testing Library's behavior.\n\nWhat changed:\n\n * screen.container is now available and safe to use\n * container returns a pseudo-element container from Test Renderer\n * The container's children are the elements you rendered\n * UNSAFE_root has been removed\n\nBefore (v13):\n\n\n\nit('should access root', () => {\n  render(<MyComponent />);\n  // UNSAFE_root was the only way to access the container\n  const root = screen.UNSAFE_root;\n});\n\n\nAfter (v14):\n\n\n\nit('should access container', async () => {\n  await render(<MyComponent />);\n  // container is now safe and available\n  const container = screen.container;\n  // root is the first child of container\n  const root = screen.root;\n});\n\n\nFor more details, see the screen API documentation.\n\n\nText string validation enforced by default#\n\nIn v14, Test Renderer automatically enforces React Native's requirement that\ntext strings must be rendered within a <Text> component. This means the\nunstable_validateStringsRenderedWithinText option has been removed from\nRenderOptions, as this validation is now always enabled.\n\nWhat changed:\n\n * Text string validation is now always enabled and cannot be disabled\n * The unstable_validateStringsRenderedWithinText option has been removed\n * Tests will now throw Invariant Violation: Text strings must be rendered\n   within a <Text> component errors when attempting to render strings outside of\n   <Text> components, matching React Native's runtime behavior\n\nMigration:\n\nIf you were using unstable_validateStringsRenderedWithinText: true in your\nrender options, you can simply remove this option as the validation is now\nalways enabled:\n\n// Before (v13)\nrender(<MyComponent />, {\n  unstable_validateStringsRenderedWithinText: true,\n});\n\n// After (v14)\nawait render(<MyComponent />);\n// Validation is now always enabled\n\n\nIf you were relying on the previous behavior where strings could be rendered\noutside of <Text> components, you'll need to fix your components to wrap strings\nin <Text> components, as this matches React Native's actual runtime behavior.\n\n\nCodemods#\n\nWe provide two codemods to automate the migration. Both codemods are safe to run\nmultiple times - they will only transform code that hasn't been migrated yet.\n\n\nrntl-v14-update-deps#\n\nUpdates your package.json:\n\n * Removes React Test Renderer (react-test-renderer and\n   @types/react-test-renderer)\n * Adds Test Renderer (test-renderer)\n * Updates @testing-library/react-native to alpha version\n\n\nrntl-v14-async-functions#\n\nTransforms test files:\n\n * Adds await to render(), act(), renderHook(), fireEvent() calls\n * Makes test functions async when needed\n * Handles screen.rerender(), screen.unmount(), and renderer methods\n\nCustom render functions#\n\nIf you have custom render helpers (like renderWithProviders), you can specify\nthem using the customRenderFunctions parameter. The codemod will then also\ntransform calls to these functions:\n\nThis will add await to your custom render calls and make the containing test\nfunctions async, just like it does for the standard render function.\n\nLimitations#\n\n * Helper functions defined in test files are not transformed by default\n * Namespace imports (import * as RNTL) are not handled\n\n\nFull Changelog#\n\nhttps://github.com/callstack/react-native-testing-library/compare/v13.3.3...v14.\n0.0","routePath":"/14.x/docs/start/migration-v14","lang":"en","toc":[{"text":"Overview","id":"overview","depth":2,"charIndex":249},{"text":"Quick Migration","id":"quick-migration","depth":2,"charIndex":912},{"text":"Breaking Changes","id":"breaking-changes","depth":2,"charIndex":1119},{"text":"Supported React and React Native versions","id":"supported-react-and-react-native-versions","depth":3,"charIndex":1139},{"text":"Test Renderer replaces React Test Renderer","id":"test-renderer-replaces-react-test-renderer","depth":3,"charIndex":1442},{"text":"1. Update dependencies","id":"1-update-dependencies","depth":4,"charIndex":2042},{"text":"2. Update type imports (if needed)","id":"2-update-type-imports-if-needed","depth":4,"charIndex":2228},{"text":"Async APIs by Default","id":"async-apis-by-default","depth":3,"charIndex":2586},{"text":"`render` is now async","id":"render-is-now-async","depth":4,"charIndex":-1},{"text":"`renderHook` is now async","id":"renderhook-is-now-async","depth":4,"charIndex":-1},{"text":"`fireEvent` is now async","id":"fireevent-is-now-async","depth":4,"charIndex":-1},{"text":"`act` is now async","id":"act-is-now-async","depth":4,"charIndex":-1},{"text":"Benefits of Async APIs","id":"benefits-of-async-apis","depth":4,"charIndex":5714},{"text":"Removed APIs","id":"removed-apis","depth":3,"charIndex":6043},{"text":"`update` alias removed","id":"update-alias-removed","depth":4,"charIndex":-1},{"text":"`getQueriesForElement` export removed","id":"getqueriesforelement-export-removed","depth":4,"charIndex":-1},{"text":"`UNSAFE_root` removed","id":"unsafe_root-removed","depth":4,"charIndex":-1},{"text":"Legacy `UNSAFE_*` queries removed","id":"legacy-unsafe_-queries-removed","depth":4,"charIndex":-1},{"text":"`concurrentRoot` option removed","id":"concurrentroot-option-removed","depth":4,"charIndex":-1},{"text":"`container` API reintroduced","id":"container-api-reintroduced","depth":3,"charIndex":-1},{"text":"Text string validation enforced by default","id":"text-string-validation-enforced-by-default","depth":3,"charIndex":9911},{"text":"Codemods","id":"codemods","depth":2,"charIndex":11215},{"text":"`rntl-v14-update-deps`","id":"rntl-v14-update-deps","depth":3,"charIndex":-1},{"text":"`rntl-v14-async-functions`","id":"rntl-v14-async-functions","depth":3,"charIndex":-1},{"text":"Custom render functions","id":"custom-render-functions","depth":4,"charIndex":11852},{"text":"Limitations","id":"limitations","depth":4,"charIndex":12215},{"text":"Full Changelog","id":"full-changelog","depth":2,"charIndex":12360}],"frontmatter":{},"version":"14.x"},{"title":"Quick Start","content":"#\n\nAlpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the\nstable release. Please report any issues you encounter.\n\n\nInstallation#\n\nOpen a Terminal in your project's folder and run:\n\nThis library has a peer dependency on Test Renderer. Make sure to install it:\n\nTest Renderer provides better compatibility with React 19 and improved type\nsafety compared to the deprecated React Test Renderer.\n\n\nJest matchers#\n\nRNTL automatically extends Jest with React Native-specific matchers. The only\nthing you need to do is to import anything from @testing-library/react-native\nwhich you already need to do to access the render function.\n\n\nESLint plugin#\n\nWe recommend setting up eslint-plugin-testing-library package to help you avoid\ncommon Testing Library mistakes and bad practices.\n\nInstall the plugin (assuming you already have eslint installed & configured):\n\nThen, add relevant entry to your ESLint config (e.g., .eslintrc.js). We\nrecommend extending the react plugin:\n\nmodule.exports = {\n  overrides: [\n    {\n      // Test files only\n      files: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[jt]s?(x)'],\n      extends: ['plugin:testing-library/react'],\n    },\n  ],\n};\n","routePath":"/14.x/docs/start/quick-start","lang":"en","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":151},{"text":"Jest matchers","id":"jest-matchers","depth":3,"charIndex":429},{"text":"ESLint plugin","id":"eslint-plugin","depth":3,"charIndex":663}],"frontmatter":{},"version":"14.x"}]