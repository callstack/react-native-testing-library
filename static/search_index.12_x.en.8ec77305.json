[{"title":"Network Requests","content":"## Introduction\n\nMocking network requests is an essential part of testing React Native applications. By mocking\nnetwork\nrequests, you can control the data that is returned from the server and test how your application\nbehaves in different scenarios, such as when the request is successful or when it fails.\n\nIn this guide, we will show you how to mock network requests and guard your test suits from unwanted\nand unmocked/unhandled network requests\n\n:::info\nTo simulate a real-world scenario, we will use the [Random User Generator API]() that provides random user data.\n:::\n\n## Phonebook Example\n\nLet's assume we have a simple phonebook application that\nuses [`fetch`]() for fetching Data from a server.\nIn our case, we have a list of contacts and favorites that we want to display in our application.\n\nThis is how the root of the application looks like:\n\n```tsx title=network-requests/Phonebook.tsx\n\n\n\n\n\n\n\n\nexport default () => {\n  const [usersData, setUsersData] = useState<User[]>([]);\n  const [favoritesData, setFavoritesData] = useState<User[]>([]);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const _getAllContacts = async () => {\n      const _data = await getAllContacts();\n      setUsersData(_data);\n    };\n    const _getAllFavorites = async () => {\n      const _data = await getAllFavorites();\n      setFavoritesData(_data);\n    };\n\n    const run = async () => {\n      try {\n        await Promise.all([_getAllContacts(), _getAllFavorites()]);\n      } catch (e) {\n        const message = isErrorWithMessage(e) ? e.message : 'Something went wrong';\n        setError(message);\n      }\n    };\n\n    void run();\n  }, []);\n\n  if (error) {\n    return <Text>An error occurred: {error}</Text>;\n  }\n\n  return (\n    <>\n      <FavoritesList users={favoritesData} />\n      <ContactsList users={usersData} />\n    </>\n  );\n};\n```\n\nWe fetch the contacts from the server using the `getAllFavorites` function that utilizes `fetch`.\n\n```tsx title=network-requests/api/getAllContacts.ts\n\n\nexport default async (): Promise<User[]> => {\n  const res = await fetch('https://randomuser.me/api/?results=25');\n  if (!res.ok) {\n    throw new Error(`Error fetching contacts`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n```\n\nWe have similar function for fetching the favorites, but this time limiting the results to 10.\n\n```tsx title=network-requests/api/getAllFavorites.ts\n\n\nexport default async (): Promise<User[]> => {\n  const res = await fetch('https://randomuser.me/api/?results=10');\n  if (!res.ok) {\n    throw new Error(`Error fetching favorites`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n```\n\nOur `FavoritesList` component is a simple component that displays the list of favorite contacts and\ntheir avatars horizontally.\n\n```tsx title=network-requests/components/FavoritesList.tsx\n\n\n\n\n\nexport default ({users}: { users: User[] }) => {\n  const renderItem: ListRenderItem<User> = useCallback(({item: {picture}}) => {\n    return (\n      <View style={styles.userContainer}>\n        <Image\n          source={{uri: picture.thumbnail}}\n          style={styles.userImage}\n          accessibilityLabel={'favorite-contact-avatar'}\n        />\n      </View>\n    );\n  }, []);\n\n  if (users.length === 0) return (\n    <View style={styles.loaderContainer}>\n      <Text>Figuring out your favorites...</Text>\n    </View>\n  );\n\n  return (\n    <View style={styles.outerContainer}>\n      <Text>⭐My Favorites</Text>\n      <FlatList<User>\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    </View>\n  );\n};\n\n// Looking for styles?\n// Check examples/cookbook/app/advanced/components/FavoritesList.tsx\nconst styles =\n...\n```\n\nOur `ContactsList` component is similar to the `FavoritesList` component, but it displays the list\nof\nall contacts vertically.\n\n```tsx title=network-requests/components/ContactsList.tsx\n\n\n\n\n\nexport default ({ users }: { users: User[] }) => {\n  const renderItem: ListRenderItem<User> = useCallback(\n    ({ item: { name, email, picture, cell }, index }) => {\n      const { title, first, last } = name;\n      const backgroundColor = index % 2 === 0 ? '#f9f9f9' : '#fff';\n      return (\n        <View style={[{ backgroundColor }, styles.userContainer]}>\n          <Image source={{ uri: picture.thumbnail }} style={styles.userImage} />\n          <View>\n            <Text>\n              Name: {title} {first} {last}\n            </Text>\n            <Text>Email: {email}</Text>\n            <Text>Mobile: {cell}</Text>\n          </View>\n        </View>\n      );\n    },\n    [],\n  );\n\n  if (users.length === 0) return <FullScreenLoader />;\n\n  return (\n    <View>\n      <FlatList<User>\n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    </View>\n  );\n};\n\n// Looking for styles or FullScreenLoader component?\n// Check examples/cookbook/app/advanced/components/ContactsList.tsx\nconst FullScreenLoader = () => ...\nconst styles = ...\n```\n\n## Start testing with a simple test\n\nIn our initial test we would like to test if the `PhoneBook` component renders the `FavoritesList`\nand `ContactsList` components correctly.\nWe will need to mock the network requests and their corresponding responses to ensure that the component behaves as\nexpected. To mock the network requests we will use [MSW (Mock Service Worker)]().\n\n:::note\nWe recommend using the Mock Service Worker (MSW) library to declaratively mock API communication in your tests instead of stubbing `fetch`, or relying on third-party adapters.\n:::\n\n:::info\nYou can install MSW by running `npm install msw --save-dev` or `yarn add msw --dev`.\nMore info regarding installation can be found in [MSW's getting started guide]().\n\nPlease make sure you're also aware of [MSW's setup guide]().\nPlease be minded that the MSW's setup guide is potentially incomplete and might contain discrepancies/missing pieces.\n:::\n\n```tsx title=network-requests/Phonebook.test.tsx\n\n\n\n\n\n\n\n// Define request handlers and response resolvers for random user API.\n// By default, we always return the happy path response.\nconst handlers = [\n  http.get('https://randomuser.me/api/*', () => {\n    return HttpResponse.json(DATA);\n  }),\n];\n\n// Setup a request interception server with the given request handlers.\nconst server = setupServer(...handlers);\n\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\ndescribe('PhoneBook', () => {\n  it('fetches all contacts and favorites successfully and renders lists in sections correctly', async () => {\n    render(<PhoneBook />);\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(await screen.findByText('Name: Mrs Ida Kristensen')).toBeOnTheScreen();\n    expect(await screen.findByText('Email: ida.kristensen@example.com')).toBeOnTheScreen();\n    expect(await screen.findAllByText(/name/i)).toHaveLength(3);\n    expect(await screen.findByText(/my favorites/i)).toBeOnTheScreen();\n    expect(await screen.findAllByLabelText('favorite-contact-avatar')).toHaveLength(3);\n  });\n});\n\nconst DATA: { results: User[] } = {\n  results: [\n    {\n      name: {\n        title: 'Mrs',\n        first: 'Ida',\n        last: 'Kristensen',\n      },\n      email: 'ida.kristensen@example.com',\n      id: {\n        name: 'CPR',\n        value: '250562-5730',\n      },\n      picture: {\n        large: 'https://randomuser.me/api/portraits/women/26.jpg',\n        medium: 'https://randomuser.me/api/portraits/med/women/26.jpg',\n        thumbnail: 'https://randomuser.me/api/portraits/thumb/women/26.jpg',\n      },\n      cell: '123-4567-890',\n    },\n    // For brevity, we have omitted the rest of the users, you can still find them in\n    // examples/cookbook/app/network-requests/__tests__/test-utils.ts\n    ...\n  ],\n};\n```\n\n:::info\nMore info regarding how to describe the network using request handlers, intercepting a request and handling its response can be found in the [MSW's documentation]().\n:::\n\n## Testing error handling\n\nAs we are dealing with network requests, and things can go wrong, we should also cover the case when\nthe API request fails. In this case, we would like to test how our application behaves when the API request fails.\n\n:::info\nThe nature of the network can be highly dynamic, which makes it challenging to describe it completely in a fixed list of request handlers.\nMSW provides us the means to override any particular network behavior using the designated `.use()` API.\nMore info can be found in [MSW's Network behavior overrides documentation]()\n:::\n\n```tsx title=network-requests/Phonebook.test.tsx\n...\n\nconst mockServerFailureForGetAllContacts = () => {\n  server.use(\n    http.get('https://randomuser.me/api/', ({ request }) => {\n      // Construct a URL instance out of the intercepted request.\n      const url = new URL(request.url);\n      // Read the \"results\" URL query parameter using the \"URLSearchParams\" API.\n      const resultsLength = url.searchParams.get('results');\n      // Simulate a server error for the get all contacts request.\n      // We check if the \"results\" query parameter is set to \"25\"\n      // to know it's the correct request to mock, in our case get all contacts.\n      if (resultsLength === '25') {\n        return new HttpResponse(null, { status: 500 });\n      }\n      // Return the default response for all other requests that match URL and verb. (in our case get favorites)\n      return HttpResponse.json(DATA);\n    }),\n  );\n};\n\ndescribe('PhoneBook', () => {\n...\n  it('fails to fetch all contacts and renders error message', async () => {\n    mockServerFailureForGetAllContacts();\n    render(<PhoneBook />);\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(\n      await screen.findByText(/an error occurred: error fetching contacts/i),\n    ).toBeOnTheScreen();\n  });\n});\n\n```\n\n## Global guarding against unwanted API requests\n\nAs mistakes may happen, we might forget to mock a network request in one of our tests in the future.\nTo prevent us from happening, and alert when a certain network request is left unhandled, you may choose to\nmove MSW's server management from `PhoneBook.test.tsx` to Jest's setup file via [`setupFilesAfterEnv`]().\n\n```tsx title=examples/cookbook/jest-setup.ts\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\n// ... rest of your setup file\n```\n\nThis setup will ensure you have the MSW server running before any test suite starts and stops it after all tests are done.\nWhich will result in a warning in the console if you forget to mock an API request in your test suite.\n\n```bash\n[MSW] Warning: intercepted a request without a matching request handler:\n • GET https://randomuser.me/api/?results=25?results=25\n```\n\n## Conclusion\n\nTesting a component that makes network requests in combination with MSW takes some initial preparation to configure and describe the overridden networks.\nWe can achieve that by using MSW's request handlers and intercepting APIs.\n\nOnce up and running we gain full grip over the network requests, their responses, statuses.\nDoing so is crucial to be able to test how our application behaves in different\nscenarios, such as when the request is successful or when it fails.\n\nWhen global configuration is in place, MSW's will also warn us when an unhandled network requests has occurred throughout a test suite.\n\n## Further Reading and Alternatives\n\nExplore more advanced scenarios for mocking network requests with MSW:\n\n- MSW's Basics - [Intercepting requests]() and/or [Mocking responses]()\n- MSW's Network behavior - how to describe [REST]() and/or [GraphQL]() APIs\n","routePath":"/12.x/cookbook/advanced/network-requests","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2,"charIndex":0},{"id":"phonebook-example","text":"Phonebook Example","depth":2,"charIndex":576},{"id":"start-testing-with-a-simple-test","text":"Start testing with a simple test","depth":2,"charIndex":5125},{"id":"testing-error-handling","text":"Testing error handling","depth":2,"charIndex":8310},{"id":"global-guarding-against-unwanted-api-requests","text":"Global guarding against unwanted API requests","depth":2,"charIndex":10206},{"id":"conclusion","text":"Conclusion","depth":2,"charIndex":11296},{"id":"further-reading-and-alternatives","text":"Further Reading and Alternatives","depth":2,"charIndex":11919}],"frontmatter":{},"version":"12.x"},{"title":"Async tests","content":"## Summary\n\nTypically, you would write synchronous tests, as they are simple and get the work done. However, there are cases when using asynchronous (async) tests might be necessary or beneficial. The two most common cases are:\n\n1. **Testing Code with asynchronous operations**: When your code relies on asynchronous operations, such as network calls or database queries, async tests are essential. Even though you should mock these network calls, the mock should act similarly to the actual behavior and hence by async.\n2. **UserEvent API:** Using the [User Event API]() in your tests creates more realistic event handling. These interactions introduce delays (even though these are typically event-loop ticks with 0 ms delays), requiring async tests to handle the timing correctly.\n\nUsing async tests when needed ensures your tests are reliable and simulate real-world conditions accurately.\n\n### Example\n\nConsider a basic asynchronous test for a user signing in with correct credentials:\n\n```javascript\ntest('User can sign in with correct credentials', async () => {\n  // Typical test setup\n  const user = userEvent.setup();\n  render(<App />);\n\n  // No need to use async here, components are already rendered\n  expect(screen.getByRole('header', { name: 'Sign in to Hello World App!' })).toBeOnTheScreen();\n\n  // Using await as User Event requires it\n  await user.type(screen.getByLabelText('Username'), 'admin');\n  await user.type(screen.getByLabelText('Password'), 'admin1');\n  await user.press(screen.getByRole('button', { name: 'Sign In' }));\n\n  // Using await as sign in operation is asynchronous\n  expect(await screen.findByRole('header', { name: 'Welcome admin!' })).toBeOnTheScreen();\n\n  // Follow-up assertions do not need to be async, as we already waited for sign in operation to complete\n  expect(\n    screen.queryByRole('header', { name: 'Sign in to Hello World App' })\n  ).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Username')).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Password')).not.toBeOnTheScreen();\n});\n```\n\n## Async utilities\n\nThere are several asynchronous utilities you might use in your tests.\n\n### `findBy*` queries\n\nThe most common are the [`findBy*` queries](). These are useful when waiting for a matching element to appear. They can be understood as a [`getBy*` queries]() used in conjunction with a [`waitFor` function]().\n\nThey accept the same predicates as `getBy*` queries like `findByRole`, `findByTest`, etc. They also have a multiple elements variant called [`findAllBy*`]().\n\n```typescript\nfunction findByRole: (\n  role: TextMatch,\n  queryOptions?: {\n    // Query specific options\n  }\n  waitForOptions?: {\n    timeout?: number;\n    interval?: number;\n    // ..\n  }\n): Promise<ReactTestInstance>;\n```\n\nEach query has a default `timeout` value of 1000 ms and a default `interval` of 50 ms. Custom timeout and check intervals can be specified if needed, as shown below:\n\n#### Example\n\n```typescript\nconst button = await screen.findByRole('button'), { name: 'Start' }, { timeout: 1000, interval: 50 });\n```\n\nAlternatively, a default global `timeout` value can be set using the [`configure` function]():\n\n```typescript\nconfigure({ asyncUtilTimeout: timeout });\n```\n\n### `waitFor` function\n\nThe `waitFor` function is another option, serving as a lower-level utility in more advanced cases.\n\n```typescript\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T>;\n```\n\nIt accepts an `expectation` to be validated and repeats the check every defined interval until it no longer throws an error. Similarly to `findBy*` queries they accept `timeout` and `interval` options and have the same default values of 1000ms for timeout, and a checking interval of 50 ms.\n\n#### Example\n\n```typescript\nawait waitFor(() => expect(mockAPI).toHaveBeenCalledTimes(1));\n```\n\nIf you want to use it with `getBy*` queries, use the `findBy*` queries instead, as they essentially do the same, but offer better developer experience.\n\n### `waitForElementToBeRemoved` function\n\nA specialized function, [`waitForElementToBeRemoved`](), is used to verify that a matching element was present but has since been removed.\n\n```typescript\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T> {}\n```\n\nThis function is, in a way, the negation of `waitFor` as it expects the initial expectation to be true (not throw an error), only to turn invalid (start throwing errors) on subsequent runs. It operates using the same `timeout` and `interval` parameters as `findBy*` queries and `waitFor`.\n\n#### Example\n\n```typescript\nawait waitForElementToBeRemoved(() => getByText('Hello World'));\n```\n\n## Fake Timers\n\nAsynchronous tests can take long to execute due to the delays introduced by asynchronous operations. To mitigate this, fake timers can be used. These are particularly useful when delays are mere waits, such as the 130 milliseconds wait introduced by the UserEvent `press()` event due to React Native runtime behavior or simulated 1000 wait in a API call mock. Fake timers allow for precise fast-forwarding through these wait periods.\n\nHere are the basics of using [Jest fake timers]():\n\n- Enable fake timers with: `jest.useFakeTimers()`\n- Disable fake timers with: `jest.useRealTimers()`\n- Advance fake timers forward with: `jest.advanceTimersByTime(interval)`\n- Run **all timers** to completion with: `jest.runAllTimers()`\n- Run **currently pending timers** to completion with: `jest.runOnlyPendingTimers()`\n\nBe cautious when running all timers to completion as it might create an infinite loop if these timers schedule follow-up timers. In such cases, it's safer to use `jest.runOnlyPendingTimers()` to avoid ending up in an infinite loop of scheduled tasks.\n\nYou can use both built-in Jest fake timers, as well as [Sinon.JS fake timers]().\n\nNote: you do not need to advance timers by hand when using User Event API, as it's automatically.\n","routePath":"/12.x/cookbook/basics/async-tests","lang":"en","toc":[{"id":"summary","text":"Summary","depth":2,"charIndex":0},{"id":"example","text":"Example","depth":3,"charIndex":895},{"id":"async-utilities","text":"Async utilities","depth":2,"charIndex":2059},{"id":"findby-queries","text":"`findBy*` queries","depth":3,"charIndex":2150},{"id":"example-1","text":"Example","depth":4,"charIndex":3785},{"id":"waitfor-function","text":"`waitFor` function","depth":3,"charIndex":3229},{"id":"example-2","text":"Example","depth":4,"charIndex":4666},{"id":"waitforelementtoberemoved-function","text":"`waitForElementToBeRemoved` function","depth":3,"charIndex":4034},{"id":"example-3","text":"Example","depth":4,"charIndex":-1},{"id":"fake-timers","text":"Fake Timers","depth":2,"charIndex":4764}],"frontmatter":{},"version":"12.x"},{"title":"Custom `render` function","content":"### Summary\n\nRNTL exposes the `render` function as the primary entry point for tests. If you make complex, repeating setups for your tests, consider creating a custom render function. The idea is to encapsulate common setup steps and test wiring inside a render function suitable for your tests.\n\n### Example\n\n```tsx title=test-utils.ts\n// ...\n\ninterface RenderWithProvidersProps {\n  user?: User | null;\n  theme?: Theme;\n}\n\nexport function renderWithProviders<T>(\n  ui: React.ReactElement<T>,\n  options?: RenderWithProvidersProps\n) {\n  return render(\n    <UserProvider.Provider value={options?.user ?? null}>\n      <ThemeProvider.Provider value={options?.theme ?? 'light'}>{ui}</ThemeProvider.Provider>\n    </UserProvider.Provider>\n  );\n}\n```\n\n```tsx title=custom-render/index.test.tsx\n\n\n// ...\n\ntest('renders WelcomeScreen with user', () => {\n  renderWithProviders(<WelcomeScreen />, { user: { name: 'Jar-Jar' } });\n  expect(screen.getByText(/hello Jar-Jar/i)).toBeOnTheScreen();\n});\n\ntest('renders WelcomeScreen without user', () => {\n  renderWithProviders(<WelcomeScreen />, { user: null });\n  expect(screen.getByText(/hello stranger/i)).toBeOnTheScreen();\n});\n```\n\nExample [full source code]().\n\n### More info\n\n#### Additional params\n\nA custom render function might accept additional parameters to allow for setting up different start conditions for a test, e.g., the initial state for global state management.\n\n```tsx title=SomeScreen.test.tsx\ntest('renders SomeScreen for logged in user', () => {\n  renderScreen(<SomeScreen />, { state: loggedInState });\n  // ...\n});\n```\n\n#### Multiple functions\n\nDepending on the situation, you may declare more than one custom render function. For example, you have one function for testing application flows and a second for testing individual screens.\n\n```tsx title=test-utils.tsx\nfunction renderNavigator(ui, options);\nfunction renderScreen(ui, options);\n```\n\n#### Async function\n\nMake it async if you want to put some async setup in your custom render function.\n\n```tsx title=SomeScreen.test.tsx\ntest('renders SomeScreen', async () => {\n  await renderWithAsync(<SomeScreen />);\n  // ...\n});\n```\n","routePath":"/12.x/cookbook/basics/custom-render","lang":"en","toc":[{"id":"summary","text":"Summary","depth":3,"charIndex":0},{"id":"example","text":"Example","depth":3,"charIndex":297},{"id":"more-info","text":"More info","depth":3,"charIndex":1200},{"id":"additional-params","text":"Additional params","depth":4,"charIndex":1215},{"id":"multiple-functions","text":"Multiple functions","depth":4,"charIndex":1579},{"id":"async-function","text":"Async function","depth":4,"charIndex":1905}],"frontmatter":{},"version":"12.x","description":"Summary RNTL exposes the render function as the primary entry point for tests. If you make complex, repeating setups for your tests, consider creating a custom render function. The idea is to encapsulate common setup steps and test wiring inside a render function suitable for your tests. Example Example full source code. More info Additional params A custom render function might accept additional parameters to allow for setting up different start conditions for a test, e.g., the initial state for global state management. Multiple functions Depending on the situation, you may declare more than one custom render function. For example, you have one function for testing application flows and a second for testing individual screens. Async function Make it async if you want to put some async setup in your custom render function."},{"title":"Introduction","content":"Welcome to the **React Native Testing Library (RNTL) Cookbook**!\nThis app is your go-to resource for learning how to effectively test React Native applications.\nIt provides a collection of **best practices**, **ready-made recipes**, and **tips & tricks** to\nsimplify and improve your testing workflow. Whether you’re a beginner just getting started or a\nseasoned developer looking to sharpen your\nskills, the Cookbook has something for everyone.\n\n## What's Inside the Cookbook?\n\nThe Cookbook is currently organized into **three main chapters**:\n\n- **Basic Recipes**: A great starting point, covering essential testing scenarios such as async\n  operations and custom render functions.\n- **Advanced Recipes**: More complex scenarios like network requests and in the future, navigation\n  testing and more.\n- **State Management Recipes**: Best practices for testing state management libraries\n\nEach recipe includes a clear explanation along with a corresponding code example to help you get\nhands-on with testing. Checkout\nthe [Cookbook App]() to see the\nrecipes in action.\n\n## What's Next?\n\nJoin the conversation\non [GitHub]() here to discuss\nideas, ask questions, or provide feedback.\n","routePath":"/12.x/cookbook/","lang":"en","toc":[{"id":"whats-inside-the-cookbook","text":"What's Inside the Cookbook?","depth":2,"charIndex":447},{"id":"whats-next","text":"What's Next?","depth":2,"charIndex":1071}],"frontmatter":{},"version":"12.x","description":"Welcome to the React Native Testing Library (RNTL) Cookbook!\nThis app is your go-to resource for learning how to effectively test React Native applications.\nIt provides a collection of best practices, ready-made recipes, and tips & tricks to\nsimplify and improve your testing workflow. Whether you’re a beginner just getting started or a\nseasoned developer looking to sharpen your\nskills, the Cookbook has something for everyone."},{"title":"Jotai","content":"## Introduction\n\nJotai is a global state management library for React that uses an atomic approach to optimize\nrenders and solve issues like extra re-renders and the need for memoization. It scales from simple\nstate management to complex enterprise applications, offering utilities and extensions to enhance\nthe developer experience.\n\n## Task List Example\n\nLet's assume we have a simple task list component that uses Jotai for state management. The\ncomponent has a list of tasks, a text input for typing new task name and a button to add a new task to the list.\n\n```tsx title=state-management/jotai/TaskList.tsx\n\n\n\n\n\n\nexport function TaskList() {\n  const [tasks, setTasks] = useAtom(tasksAtom);\n  const [newTaskTitle, setNewTaskTitle] = useAtom(newTaskTitleAtom);\n\n  const handleAddTask = () => {\n    setTasks((tasks) => [\n      ...tasks,\n      {\n        id: nanoid(),\n        title: newTaskTitle,\n      },\n    ]);\n    setNewTaskTitle('');\n  };\n\n  return (\n    <View>\n      {tasks.map((task) => (\n        <Text key={task.id} testID=\"task-item\">\n          {task.title}\n        </Text>\n      ))}\n\n      {!tasks.length ? <Text>No tasks, start by adding one...</Text> : null}\n\n      <TextInput\n        accessibilityLabel=\"New Task\"\n        placeholder=\"New Task...\"\n        value={newTaskTitle}\n        onChangeText={(text) => setNewTaskTitle(text)}\n      />\n\n      <Pressable accessibilityRole=\"button\" onPress={handleAddTask}>\n        <Text>Add Task</Text>\n      </Pressable>\n    </View>\n  );\n}\n```\n\n## Starting with a Simple Test\n\nWe can test our `TaskList` component using React Native Testing Library's (RNTL) regular `render`\nfunction. Although it is sufficient to test the empty state of the `TaskList` component, it is not\nenough to test the component with initial tasks present in the list.\n\n```tsx title=status-management/jotai/__tests__/TaskList.test.tsx\n\n\n\n\n\n\n\njest.useFakeTimers();\n\ntest('renders an empty task list', () => {\n  render(<TaskList />);\n  expect(screen.getByText(/no tasks, start by adding one/i)).toBeOnTheScreen();\n});\n```\n\n## Custom Render Function to populate Jotai Atoms with Initial Values\n\nTo test the `TaskList` component with initial tasks, we need to be able to populate the `tasksAtom` with\ninitial values. We can create a custom render function that uses Jotai's `useHydrateAtoms` hook to\nhydrate the atoms with initial values. This function will accept the initial atoms and their\ncorresponding values as an argument.\n\n```tsx title=status-management/jotai/test-utils.tsx\n\n\n\n\n\n// Jotai types are not well exported, so we will make our life easier by using `any`.\nexport type AtomInitialValueTuple<T> = [PrimitiveAtom<T>, T];\n\nexport interface RenderWithAtomsOptions {\n  initialValues: AtomInitialValueTuple<any>[];\n}\n\n/**\n * Renders a React component with Jotai atoms for testing purposes.\n *\n * @param component - The React component to render.\n * @param options - The render options including the initial atom values.\n * @returns The render result from `@testing-library/react-native`.\n */\nexport const renderWithAtoms = <T,>(\n  component: React.ReactElement,\n  options: RenderWithAtomsOptions\n) => {\n  return render(\n    <HydrateAtomsWrapper initialValues={options.initialValues}>{component}</HydrateAtomsWrapper>\n  );\n};\n\nexport type HydrateAtomsWrapperProps = React.PropsWithChildren<{\n  initialValues: AtomInitialValueTuple<unknown>[];\n}>;\n\n/**\n * A wrapper component that hydrates Jotai atoms with initial values.\n *\n * @param initialValues - The initial values for the Jotai atoms.\n * @param children - The child components to render.\n * @returns The rendered children.\n\n */\nfunction HydrateAtomsWrapper({ initialValues, children }: HydrateAtomsWrapperProps) {\n  useHydrateAtoms(initialValues);\n  return children;\n}\n```\n\n## Testing the `TaskList` Component with initial tasks\n\nWe can now use the `renderWithAtoms` function to render the `TaskList` component with initial tasks. The\n`initialValues` property will contain the `tasksAtom`, `newTaskTitleAtom` and their initial values. We can then test the component to ensure that the initial tasks are rendered correctly.\n\n:::info\nIn our test, we populated only one atom and its initial value, but you can add other Jotai atoms and their corresponding values to the initialValues array as needed.\n:::\n\n```tsx title=status-management/jotai/__tests__/TaskList.test.tsx\n=======\nconst INITIAL_TASKS: Task[] = [{ id: '1', title: 'Buy bread' }];\n\ntest('renders a to do list with 1 items initially, and adds a new item', async () => {\n  renderWithAtoms(<TaskList />, {\n    initialValues: [\n      [tasksAtom, INITIAL_TASKS],\n      [newTaskTitleAtom, ''],\n    ],\n  });\n\n  expect(screen.getByText(/buy bread/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(1);\n\n  const user = userEvent.setup();\n  await user.type(screen.getByPlaceholderText(/new task/i), 'Buy almond milk');\n  await user.press(screen.getByRole('button', { name: /add task/i }));\n\n  expect(screen.getByText(/buy almond milk/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(2);\n});\n```\n\n## Modifying atom outside of React components\n\nIn several cases, you might need to change an atom's state outside a React component. In our case,\nwe have a set of functions to get tasks and set tasks, which change the state of the task list atom.\n\n```tsx title=state-management/jotai/state.ts\n\n\n\nexport const tasksAtom = atom<Task[]>([]);\nexport const newTaskTitleAtom = atom('');\n\n// Available for use outside React components\nexport const store = createStore();\n\n// Selectors\nexport function getAllTasks(): Task[] {\n  return store.get(tasksAtom);\n}\n\n// Actions\nexport function addTask(task: Task) {\n  store.set(tasksAtom, [...getAllTasks(), task]);\n}\n```\n\n## Testing atom outside of React components\n\nYou can test the `getAllTasks` and `addTask` functions outside the React component's scope by setting\nthe initial to-do items in the store and then checking if the functions work as expected.\nNo special setup is required to test these functions, as `store.set` is available by default by\nJotai.\n\n```tsx title=state-management/jotai/__tests__/TaskList.test.tsx\n\n\n//...\n\ntest('modify store outside of React component', () => {\n  // Set the initial to do items in the store\n  store.set(tasksAtom, INITIAL_TASKS);\n  expect(getAllTasks()).toEqual(INITIAL_TASKS);\n\n  const NEW_TASK = { id: '2', title: 'Buy almond milk' };\n  addTask(NEW_TASK);\n  expect(getAllTasks()).toEqual([...INITIAL_TASKS, NEW_TASK]);\n});\n```\n\n## Conclusion\n\nTesting a component or a function that depends on Jotai atoms is straightforward with the help of\nthe `useHydrateAtoms` hook. We've seen how to create a custom render function `renderWithAtoms` that\nsets up atoms and their initial values for testing purposes. We've also seen how to test functions\nthat change the state of atoms outside React components. This approach allows us to test components\nin different states and scenarios, ensuring they behave as expected.\n","routePath":"/12.x/cookbook/state-management/jotai","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2,"charIndex":0},{"id":"task-list-example","text":"Task List Example","depth":2,"charIndex":335},{"id":"starting-with-a-simple-test","text":"Starting with a Simple Test","depth":2,"charIndex":1498},{"id":"custom-render-function-to-populate-jotai-atoms-with-initial-values","text":"Custom Render Function to populate Jotai Atoms with Initial Values","depth":2,"charIndex":2048},{"id":"testing-the-tasklist-component-with-initial-tasks","text":"Testing the `TaskList` Component with initial tasks","depth":2,"charIndex":3763},{"id":"modifying-atom-outside-of-react-components","text":"Modifying atom outside of React components","depth":2,"charIndex":5097},{"id":"testing-atom-outside-of-react-components","text":"Testing atom outside of React components","depth":2,"charIndex":5755},{"id":"conclusion","text":"Conclusion","depth":2,"charIndex":6510}],"frontmatter":{},"version":"12.x"},{"title":"Testing environment","content":":::info\n\nThis document is intended for a more advanced audience who want to understand the internals of our testing environment better, e.g., to contribute to the codebase. You should be able to write integration or component tests without reading this.\n\n:::\n\nReact Native Testing Library allows you to write integration and component tests for your React Native app or library. While the JSX code used in tests closely resembles your React Native app, things are not as simple as they might appear. This document will describe the key elements of our testing environment and highlight things to be aware of when writing more advanced tests or diagnosing issues.\n\n## React renderers\n\nReact allows you to write declarative code using JSX, write function or class components, or use hooks like `useState`. You need to use a renderer to output the results of your components. Every React app uses some renderer:\n\n- React Native is a renderer for mobile apps,\n- React DOM is a renderer for web apps,\n- There are other more [specialized renderers]() that can e.g., render to console or HTML canvas.\n\nWhen you run your tests in the React Native Testing Library, somewhat contrary to what the name suggests, they are actually **not** using React Native renderer. This is because this renderer needs to be run on an iOS or Android operating system, so it would need to run on a device or simulator.\n\n## React Test Renderer\n\nInstead, RNTL uses React Test Renderer, a specialized renderer that allows rendering to pure JavaScript objects without access to mobile OS and can run in a Node.js environment using Jest (or any other JavaScript test runner).\n\nUsing React Test Renderer has pros and cons.\n\nBenefits:\n\n- tests can run on most CIs (Linux, etc) and do not require a mobile device or emulator\n- faster test execution\n- light runtime environment\n\nDisadvantages:\n\n- Tests do not execute native code\n- Tests are unaware of the view state that would be managed by native components, e.g., focus, unmanaged text boxes, etc.\n- Assertions do not operate on native view hierarchy\n- Runtime behaviors are simulated, sometimes imperfectly\n\nIt's worth noting that the React Testing Library (web one) works a bit differently. While RTL also runs in Jest, it has access to a simulated browser DOM environment from the `jsdom` package, which allows it to use a regular React DOM renderer. Unfortunately, there is no similar React Native runtime environment package. This is probably because while the browser environment is well-defined and highly standardized, the React Native environment constantly evolves in sync with the evolution of underlying OS-es. Maintaining such an environment would require duplicating countless React Native behaviors and keeping them in sync as React Native develops.\n\n## Element tree\n\nCalling the `render()` function creates an element tree. This is done internally by invoking `TestRenderer.create()` method. The output tree represents your React Native component tree, and each node of that tree is an \"instance\" of some React component (to be more precise, each node represents a React fiber, and only class components have instances, while function components store the hook state using fibers).\n\nThese tree elements are represented by `ReactTestInstance` type:\n\n```tsx\ninterface ReactTestInstance {\n  type: ElementType;\n  props: { [propName: string]: any };\n  parent: ReactTestInstance | null;\n  children: Array<ReactTestInstance | string>;\n\n  // Other props and methods\n}\n```\n\nBased on: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react-test-renderer/index.d.ts]()\n\n## Host and composite components\n\nOne of the most important aspects of the element tree is that it is composed of both host and composite components:\n\n- [Host components]() will have direct counterparts in the native view tree. Typical examples are `<View>`, `<Text>` , `<TextInput>`, and `<Image>` from React Native. You can think of these as an analog of `<div>`, `<span>` etc on the Web. You can also create custom host views as native modules or import them from 3rd party libraries, like React Navigation or React Native Gesture Handler.\n- [Composite components]() are React code organization units that exist only on the JavaScript side of your app. Typical examples are components you create (function and class components), components imported from React Native (`View`, `Text`, etc.), or 3rd party packages.\n\nThat might initially sound confusing since we put React Native's `View` in both categories. There are two `View` components: composite and host. The relation between them is as follows:\n\n- composite `View` is the type imported from the `react-native` package. It is a JavaScript component that renders the host `View` as its only child in the element tree.\n- host `View`, which you do not render directly. React Native takes the props you pass to the composite `View`, does some processing on them and passes them to the host `View`.\n\nThe part of the tree looks as follows:\n\n```jsx\n* <View> (composite)\n  * <View> (host)\n    * children prop passed in JSX\n```\n\nA similar relation exists between other composite and host pairs: e.g. `Text` , `TextInput`, and `Image` components:\n\n```jsx\n* <Text> (composite)\n  * <Text> (host)\n    * string (or mixed) content\n```\n\nNot all React Native components are organized this way, e.g., when you use `Pressable` (or `TouchableOpacity`), there is no host `Pressable`, but composite `Pressable` is rendering a host `View` with specific props being set:\n\n```jsx\n* <Pressable> (composite)\n  * <View accessible={true} {...}> (host)\n    * children prop passed in JSX\n```\n\n### Differentiating between host and composite elements\n\nAny easy way to differentiate between host and composite elements is the `type` prop of `ReactTestInstance`:\n\n- for host components, it's always a string value representing a component name, e.g., `\"View\"`\n- for composite components, it's a function or class corresponding to the component\n\nYou can use the following code to check if a given element is a host one:\n\n```jsx\nfunction isHostElement(element: ReactTestInstance) {\n  return typeof element.type === 'string';\n}\n```\n\n## Tree nodes\n\nWe encourage you to only assert values on host views in your tests because they represent the user interface view and controls which the user can see and interact with. Users cannot see or interact with composite views as they exist purely in the JavaScript domain and do not generate any visible UI.\n\n### Asserting props\n\nFor example, suppose you assert a `style` prop of a composite element. In that case, there is no guarantee that the style will be visible to the user, as the component author can forget to pass this prop to some underlying `View` or other host component. Similarly `onPress` event handler on a composite prop can be unreachable by the user.\n\n```jsx\nfunction ForgotToPassPropsButton({ title, onPress, style }) {\n  return (\n    <Pressable>\n      <Text>{title}</Text>\n    </Pressable>\n  );\n}\n```\n\nIn the above example, user-defined components accept both `onPress` and `style` props but do not pass them (through `Pressable`) to host views, so they will not affect the user interface. Additionally, React Native and other libraries might pass some of the props under different names or transform their values between composite and host components.\n\n## Tree navigation\n\n:::caution\nYou should avoid navigating over the element tree, as this makes your testing code fragile and may result in false positives. This section is more relevant for people who want to contribute to our codebase.\n:::\n\nYou will encounter host and composite elements when navigating a tree of react elements using `parent` or `children` props of a `ReactTestInstance` element. You should be careful when navigating the element tree, as the tree structure for third-party components can change independently from your code and cause unexpected test failures.\n\nInside RNTL, we have various tree navigation helpers: `getHostParent`, `getHostChildren`, etc. These are intentionally not exported, as using them is not recommended.\n\n## Queries\n\nAll recommended Testing Library queries return host components to encourage the best practices described above.\n\nOnly `UNSAFE_*ByType` and `UNSAFE_*ByProps` queries can return both host and composite components depending on used predicates. They are marked as unsafe precisely because testing composite components makes your test more fragile.\n","routePath":"/12.x/docs/advanced/testing-env","lang":"en","toc":[{"id":"react-renderers","text":"React renderers","depth":2,"charIndex":664},{"id":"react-test-renderer","text":"React Test Renderer","depth":2,"charIndex":1392},{"id":"element-tree","text":"Element tree","depth":2,"charIndex":2783},{"id":"host-and-composite-components","text":"Host and composite components","depth":2,"charIndex":3613},{"id":"differentiating-between-host-and-composite-elements","text":"Differentiating between host and composite elements","depth":3,"charIndex":5633},{"id":"tree-nodes","text":"Tree nodes","depth":2,"charIndex":6166},{"id":"asserting-props","text":"Asserting props","depth":3,"charIndex":6483},{"id":"tree-navigation","text":"Tree navigation","depth":2,"charIndex":7350},{"id":"queries","text":"Queries","depth":2,"charIndex":8100}],"frontmatter":{},"version":"12.x","description":":::info This document is intended for a more advanced audience who want to understand the internals of our testing environment better, e.g., to contribute to the codebase. You should be able to write integration or component tests without reading this. ::: React Native Testing Library allows you to write integration and component tests for your React Native app or library. While the JSX code used in tests closely resembles your React Native app, things are not as simple as they might appear. This document will describe the key elements of our testing environment and highlight things to be aware of when writing more advanced tests or diagnosing issues."},{"title":"Understanding `act` function","content":"When writing RNTL tests one of the things that confuses developers the most are cryptic [`act()`]() function errors logged into console. In this article I will try to build an understanding of the purpose and behaviour of `act()` so you can build your tests with more confidence.\n\n## `act` warnings\n\nLet’s start with typical `act()` warnings logged to console. There are two kinds of these issues, let’s call the first one the \"sync `act()`\" warning:\n\n```\nWarning: An update to Component inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n```\n\nThe second one relates to async usage of `act` so let’s call it the \"async `act`\" error:\n\n```\nWarning: You called act(async () => ...) without await. This could lead to unexpected\ntesting behaviour, interleaving multiple act calls and mixing their scopes. You should\n- await act(async () => ...);\n```\n\n## Synchronous `act`\n\n### Responsibility\n\nThis function is intended only for using in automated tests and works only in development mode. Attempting to use it in production build will throw an error.\n\nThe responsibility for `act` function is to make React renders and updates work in tests in a similar way they work in real application by grouping and executing related units of interaction (e.g. renders, effects, etc) together.\n\nTo showcase that behaviour let make a small experiment. First we define a function component that uses `useEffect` hook in a trivial way.\n\n```jsx\nfunction TestComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n```\n\nIn the following tests we will directly use `ReactTestRenderer` instead of RNTL `render` function to render our component for tests. In order to expose familiar queries like `getByText` we will use `within` function from RNTL.\n\n```jsx\ntest('render without act', () => {\n  const renderer = TestRenderer.create(<TestComponent />);\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.root);\n  expect(view.getByText('Count 0')).toBeOnTheScreen();\n});\n```\n\nWhen testing without `act` call wrapping rendering call, we see that the assertion runs just after the rendering but before `useEffect`hooks effects are applied. Which is not what we expected in our tests.\n\n```jsx\ntest('render with act', () => {\n  let renderer: ReactTestRenderer;\n  act(() => {\n    renderer = TestRenderer.create(<TestComponent />);\n  });\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer!.root);\n  expect(view.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nWhen wrapping rendering call with `act` we see that the changes caused by `useEffect` hook have been applied as we would expect.\n\n### When to use act\n\nThe name `act` comes from [Arrange-Act-Assert]() unit testing pattern. Which means it’s related to part of the test when we execute some actions on the component tree.\n\nSo far we learned that `act` function allows tests to wait for all pending React interactions to be applied before we make our assertions. When using `act` we get guarantee that any state updates will be executed as well as any enqueued effects will be executed.\n\nTherefore, we should use `act` whenever there is some action that causes element tree to render, particularly:\n\n- initial render call - `ReactTestRenderer.create` call\n- re-rendering of component -`renderer.update` call\n- triggering any event handlers that cause component tree render\n\nThankfully, for these basic cases RNTL has got you covered as our `render`, `update` and `fireEvent` methods already wrap their calls in sync `act` so that you do not have to do it explicitly.\n\nNote that `act` calls can be safely nested and internally form a stack of calls. However, overlapping `act` calls, which can be achieved using async version of `act`, [are not supported]().\n\n### Implementation\n\nAs of React version of 18.1.0, the `act` implementation is defined in the [ReactAct.js source file]() inside React repository. This implementation has been fairly stable since React 17.0.\n\nRNTL exports `act` for convenience of the users as defined in the [act.ts source file](). That file refers to [ReactTestRenderer.js source]() file from React Test Renderer package, which finally leads to React act implementation in ReactAct.js (already mentioned above).\n\n## Asynchronous `act`\n\nSo far we have seen synchronous version of `act` which runs its callback immediately. This can deal with things like synchronous effects or mocks using already resolved promises. However, not all component code is synchronous. Frequently our components or mocks contain some asynchronous behaviours like `setTimeout` calls or network calls. Starting from React 16.9, `act` can also be called in asynchronous mode. In such case `act` implementation checks that the passed callback returns [object resembling promise]().\n\n### Asynchronous code\n\nAsynchronous version of `act` also is executed immediately, but the callback is not yet completed because of some asynchronous operations inside.\n\nLets look at a simple example with component using `setTimeout` call to simulate asynchronous behaviour:\n\n```jsx\nfunction TestAsyncComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setTimeout(() => {\n      setCount((c) => c + 1);\n    }, 50);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n```\n\n```jsx\n\n\ntest('render async natively', () => {\n  render(<TestAsyncComponent />);\n  expect(screen.getByText('Count 0')).toBeOnTheScreen();\n});\n```\n\nIf we test our component in a native way without handling its asynchronous behaviour we will end up with sync act warning:\n\n```\nWarning: An update to TestAsyncComponent inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n```\n\nNote that this is not yet the infamous async act warning. It only asks us to wrap our event code with `act` calls. However, this time our immediate state change does not originate from externally triggered events but rather forms an internal part of the component. So how can we apply `act` in such scenario?\n\n### Solution with fake timers\n\nFirst solution is to use Jest's fake timers inside out tests:\n\n```jsx\ntest('render with fake timers', () => {\n  jest.useFakeTimers();\n  render(<TestAsyncComponent />);\n\n  act(() => {\n    jest.runAllTimers();\n  });\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThat way we can wrap `jest.runAllTimers()` call which triggers the `setTimeout` updates inside an `act` call, hence resolving the act warning. Note that this whole code is synchronous thanks to usage of Jest fake timers.\n\n### Solution with real timers\n\nIf we wanted to stick with real timers then things get a bit more complex. Let’s start by applying a crude solution of opening async `act()` call for the expected duration of components updates:\n\n```jsx\ntest('render with real timers - sleep', async () => {\n  render(<TestAsyncComponent />);\n  await act(() => sleep(100)); // Wait a bit longer than setTimeout in `TestAsyncComponent`\n\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis works correctly as we use an explicit async `act()` call that resolves the console error. However, it relies on our knowledge of exact implementation details which is a bad practice.\n\nLet’s try more elegant solution using `waitFor` that will wait for our desired state:\n\n```jsx\ntest('render with real timers - waitFor', async () => {\n  render(<TestAsyncComponent />);\n\n  await waitFor(() => screen.getByText('Count 1'));\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis also works correctly, because `waitFor` call executes async `act()` call internally.\n\nThe above code can be simplified using `findBy` query:\n\n```jsx\ntest('render with real timers - findBy', async () => {\n  render(<TestAsyncComponent />);\n\n  expect(await screen.findByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis also works since `findByText` internally calls `waitFor` which uses async `act()`.\n\nNote that all of the above examples are async tests using & awaiting async `act()` function call.\n\n### Async act warning\n\nIf we modify any of the above async tests and remove `await` keyword, then we will trigger the notorious async `act()`warning:\n\n```jsx\nWarning: You called act(async () => ...) without await. This could lead to unexpected\ntesting behaviour, interleaving multiple act calls and mixing their scopes. You should\n- await act(async () => ...);\n```\n\nReact decides to show this error whenever it detects that async `act()`call [has not been awaited]().\n\nThe exact reasons why you might see async `act()` warnings vary, but finally it means that `act()` has been called with callback that returns `Promise`-like object, but it has not been waited on.\n\n## References\n\n- [React `act` implementation source]()\n- [React testing recipes: `act()`]()\n","routePath":"/12.x/docs/advanced/understanding-act","lang":"en","toc":[{"id":"act-warnings","text":"`act` warnings","depth":2,"charIndex":281},{"id":"synchronous-act","text":"Synchronous `act`","depth":2,"charIndex":1005},{"id":"responsibility","text":"Responsibility","depth":3,"charIndex":1027},{"id":"when-to-use-act","text":"When to use act","depth":3,"charIndex":2870},{"id":"implementation","text":"Implementation","depth":3,"charIndex":3995},{"id":"asynchronous-act","text":"Asynchronous `act`","depth":2,"charIndex":4476},{"id":"asynchronous-code","text":"Asynchronous code","depth":3,"charIndex":5019},{"id":"solution-with-fake-timers","text":"Solution with fake timers","depth":3,"charIndex":6368},{"id":"solution-with-real-timers","text":"Solution with real timers","depth":3,"charIndex":6901},{"id":"async-act-warning","text":"Async act warning","depth":3,"charIndex":8379},{"id":"references","text":"References","depth":2,"charIndex":9045}],"frontmatter":{},"version":"12.x","description":"When writing RNTL tests one of the things that confuses developers the most are cryptic act() function errors logged into console. In this article I will try to build an understanding of the purpose and behaviour of act() so you can build your tests with more confidence."},{"title":"API Overview","content":"React Native Testing Library consists of following APIs:\n\n- [`render` function]() - render your UI components for testing purposes\n- [`screen` object]() - access rendered UI:\n  - [Queries]() - find relevant components by various predicates: role, text, test ids, etc\n  - Lifecycle methods: [`rerender`](), [`unmount`]()\n  - Helpers: [`debug`](), [`toJSON`](), [`root`]()\n- [Jest matchers]() - validate assumptions about your UI\n- [User Event]() - simulate common user interactions like [`press`]() or [`type`]() in a realistic way\n- [Fire Event]() - simulate any component event in a simplified way purposes\n- Misc APIs:\n  - [`renderHook` function]() - render hooks for testing\n  - [Async utils](): `findBy*` queries, `wait`, `waitForElementToBeRemoved`\n  - [Configuration](): `configure`, `resetToDefaults`\n  - [Accessibility](): `isHiddenFromAccessibility`\n  - [Other](): `within`, `act`, `cleanup`\n","routePath":"/12.x/docs/api","lang":"en","toc":[],"frontmatter":{"uri":"/api"},"version":"12.x","description":"React Native Testing Library consists of following APIs: render function - render your UI components for testing purposesscreen object - access rendered UI:Queries - find relevant components by various predicates: role, text, test ids, etcLifecycle methods: rerender, unmountHelpers: debug, toJSON, rootJest matchers - validate assumptions about your UIUser Event - simulate common user interactions like press or type in a realistic wayFire Event - simulate any component event in a simplified way purposesMisc APIs:renderHook function - render hooks for testingAsync utils: findBy* queries, wait, waitForElementToBeRemovedConfiguration: configure, resetToDefaultsAccessibility: isHiddenFromAccessibilityOther: within, act, cleanup"},{"title":"Fire Event API","content":"```ts\nfunction fireEvent(element: ReactTestInstance, eventName: string, ...data: unknown[]): void;\n```\n\n:::note\nFor common events like `press` or `type` it's recommended to use [User Event API]() as it offers\nmore realistic event simulation by emitting a sequence of events with proper event objects that mimic React Native runtime behavior.\n\nUse Fire Event for cases not supported by User Event and for triggering event handlers on composite components.\n:::\n\nThe `fireEvent` API allows you to trigger all kinds of event handlers on both host and composite components. It will try to invoke a single event handler traversing the component tree bottom-up from passed element and trying to find enabled event handler named `onXxx` when `xxx` is the name of the event passed.\n\nUnlike User Event, this API does not automatically pass event object to event handler, this is responsibility of the user to construct such object.\n\n```jsx\n\n\ntest('fire changeText event', () => {\n  const onEventMock = jest.fn();\n  render(\n    // MyComponent renders TextInput which has a placeholder 'Enter details'\n    // and with `onChangeText` bound to handleChangeText\n    <MyComponent handleChangeText={onEventMock} />\n  );\n\n  fireEvent(screen.getByPlaceholderText('change'), 'onChangeText', 'ab');\n  expect(onEventMock).toHaveBeenCalledWith('ab');\n});\n```\n\n:::note\nPlease note that from version `7.0` `fireEvent` performs checks that should prevent events firing on disabled elements.\n:::\n\nAn example using `fireEvent` with native events that aren't already aliased by the `fireEvent` api.\n\n```jsx\n\n\n\nconst onBlurMock = jest.fn();\n\nrender(\n  <View>\n    <TextInput placeholder=\"my placeholder\" onBlur={onBlurMock} />\n  </View>\n);\n\n// you can omit the `on` prefix\nfireEvent(screen.getByPlaceholderText('my placeholder'), 'blur');\n```\n\nFireEvent exposes convenience methods for common events like: `press`, `changeText`, `scroll`.\n\n### `fireEvent.press` {#press}\n\n```\nfireEvent.press: (element: ReactTestInstance, ...data: Array<any>) => void\n```\n\n:::note\nIt is recommended to use the User Event [`press()`]() helper instead as it offers more realistic simulation of press interaction, including pressable support.\n:::\n\nInvokes `press` event handler on the element or parent element in the tree.\n\n```jsx\n\n\n\nconst onPressMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    pageX: 20,\n    pageY: 30,\n  },\n};\n\nrender(\n  <View>\n    <TouchableOpacity onPress={onPressMock}>\n      <Text>Press me</Text>\n    </TouchableOpacity>\n  </View>\n);\n\nfireEvent.press(screen.getByText('Press me'), eventData);\nexpect(onPressMock).toHaveBeenCalledWith(eventData);\n```\n\n### `fireEvent.changeText` {#change-text}\n\n```\nfireEvent.changeText: (element: ReactTestInstance, ...data: Array<any>) => void\n```\n\n:::note\nIt is recommended to use the User Event [`type()`]() helper instead as it offers more realistic simulation of text change interaction, including key-by-key typing, element focus, and other editing events.\n:::\n\nInvokes `changeText` event handler on the element or parent element in the tree.\n\n```jsx\n\n\n\nconst onChangeTextMock = jest.fn();\nconst CHANGE_TEXT = 'content';\n\nrender(\n  <View>\n    <TextInput placeholder=\"Enter data\" onChangeText={onChangeTextMock} />\n  </View>\n);\n\nfireEvent.changeText(screen.getByPlaceholderText('Enter data'), CHANGE_TEXT);\n```\n\n### `fireEvent.scroll` {#scroll}\n\n```\nfireEvent.scroll: (element: ReactTestInstance, ...data: Array<any>) => void\n```\n\nInvokes `scroll` event handler on the element or parent element in the tree.\n\n#### On a `ScrollView`\n\n```jsx\n\n\n\nconst onScrollMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    contentOffset: {\n      y: 200,\n    },\n  },\n};\n\nrender(\n  <ScrollView onScroll={onScrollMock}>\n    <Text>XD</Text>\n  </ScrollView>\n);\n\nfireEvent.scroll(screen.getByText('scroll-view'), eventData);\n```\n\n:::note\n\nPrefer using [`user.scrollTo`]() over `fireEvent.scroll` for `ScrollView`, `FlatList`, and `SectionList` components. User Event provides a more realistic event simulation based on React Native runtime behavior.\n\n:::\n","routePath":"/12.x/docs/api/events/fire-event","lang":"en","toc":[{"id":"press","text":"`fireEvent.press`","depth":3,"charIndex":1909},{"id":"change-text","text":"`fireEvent.changeText`","depth":3,"charIndex":2635},{"id":"scroll","text":"`fireEvent.scroll`","depth":3,"charIndex":3334},{"id":"on-a-scrollview","text":"On a `ScrollView`","depth":4,"charIndex":3531}],"frontmatter":{},"version":"12.x","description":":::note\nFor common events like press or type it's recommended to use User Event API as it offers\nmore realistic event simulation by emitting a sequence of events with proper event objects that mimic React Native runtime behavior. Use Fire Event for cases not supported by User Event and for triggering event handlers on composite components.\n::: The fireEvent API allows you to trigger all kinds of event handlers on both host and composite components. It will try to invoke a single event handler traversing the component tree bottom-up from passed element and trying to find enabled event handler named onXxx when xxx is the name of the event passed. Unlike User Event, this API does not automatically pass event object to event handler, this is responsibility of the user to construct such object. :::note\nPlease note that from version 7.0 fireEvent performs checks that should prevent events firing on disabled elements.\n::: An example using fireEvent with native events that aren't already aliased by the fireEvent api. FireEvent exposes convenience methods for common events like: press, changeText, scroll. fireEvent.press {#press} :::note\nIt is recommended to use the User Event press() helper instead as it offers more realistic simulation of press interaction, including pressable support.\n::: Invokes press event handler on the element or parent element in the tree. fireEvent.changeText {#change-text} :::note\nIt is recommended to use the User Event type() helper instead as it offers more realistic simulation of text change interaction, including key-by-key typing, element focus, and other editing events.\n::: Invokes changeText event handler on the element or parent element in the tree. fireEvent.scroll {#scroll} Invokes scroll event handler on the element or parent element in the tree. On a ScrollView :::note Prefer using user.scrollTo over fireEvent.scroll for ScrollView, FlatList, and SectionList components. User Event provides a more realistic event simulation based on React Native runtime behavior. :::"},{"title":"User Event interactions","content":":::info RNTL minimal version\n\nUser Event interactions require RNTL v12.2.0 or later.\n\n:::\n\n## Comparison with Fire Event API\n\nFire Event is our original event simulation API. It can invoke **any event handler** declared on **either host or composite elements**. Suppose the element does not have `onEventName` event handler for the passed `eventName` event, or the element is disabled. In that case, Fire Event will traverse up the component tree, looking for an event handler on both host and composite elements along the way. By default, it will **not pass any event data**, but the user might provide it in the last argument.\n\nIn contrast, User Event provides realistic event simulation for user interactions like `press` or `type`. Each interaction will trigger a **sequence of events** corresponding to React Native runtime behavior. These events will be invoked **only on host elements**, and **will automatically receive event data** corresponding to each event.\n\nIf User Event supports a given interaction, you should always prefer it over the Fire Event counterpart, as it will make your tests much more realistic and, hence, reliable. In other cases, e.g., when User Event does not support the given event or when invoking event handlers on composite elements, you have to use Fire Event as the only available option.\n\n## `setup()`\n\n```ts\nuserEvent.setup(options?: {\n  delay: number;\n  advanceTimers: (delay: number) => Promise<void> | void;\n})\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\n```\n\nCreates a User Event object instance, which can be used to trigger events.\n\n### Options {#setup-options}\n\n- `delay` controls the default delay between subsequent events, e.g., keystrokes.\n- `advanceTimers` is a time advancement utility function that should be used for fake timers. The default setup handles both real timers and Jest fake timers.\n\n## `press()`\n\n```ts\npress(\n  element: ReactTestInstance,\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.press(element);\n```\n\nThis helper simulates a press on any pressable element, e.g. `Pressable`, `TouchableOpacity`, `Text`, `TextInput`, etc. Unlike `fireEvent.press()`, a more straightforward API that will only call the `onPress` prop, this function simulates the entire press interaction in a more realistic way by reproducing the event sequence emitted by React Native runtime. This helper will trigger additional events like `pressIn` and `pressOut`.\n\nThis event will take a minimum of 130 ms to run due to the internal React Native logic. Consider using fake timers to speed up test execution for tests involving `press` and `longPress` interactions.\n\n## `longPress()`\n\n```ts\nlongPress(\n  element: ReactTestInstance,\n  options: { duration: number } = { duration: 500 }\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.longPress(element);\n```\n\nSimulates a long press user interaction. In React Native, the `longPress` event is emitted when the press duration exceeds the long press threshold (by default, 500 ms). In other aspects, this action behaves similarly to regular `press` action, e.g., by emitting `pressIn` and `pressOut` events. The press duration is customizable through the options. This should be useful if you use the `delayLongPress` prop.\n\nThis event will, by default, take 500 ms to run. Due to internal React Native logic, it will take at least 130 ms regardless of the duration option passed. Consider using fake timers to speed up test execution for tests involving `press` and `longPress` interactions.\n\n### Options {#longpress-options}\n\n- `duration` - duration of the press in milliseconds. The default value is 500 ms.\n\n## `type()`\n\n```ts\ntype(\n  element: ReactTestInstance,\n  text: string,\n  options?: {\n    skipPress?: boolean;\n    skipBlur?: boolean;\n    submitEditing?: boolean;\n  }\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.type(textInput, 'Hello world!');\n```\n\nThis helper simulates the user focusing on a `TextInput` element, typing `text` one character at a time, and leaving the element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n:::note\nThis function will add text to the text already present in the text input (as specified by `value` or `defaultValue` props). To replace existing text, use [`clear()`]() helper first.\n:::\n\n### Options {#type-options}\n\n- `skipPress` - if true, `pressIn` and `pressOut` events will not be triggered.\n- `skipBlur` - if true, `endEditing` and `blur` events will not be triggered when typing is complete.\n- `submitEditing` - if true, `submitEditing` event will be triggered after typing the text.\n\n### Sequence of events {#type-sequence}\n\nThe sequence of events depends on the `multiline` prop and the passed options.\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `pressIn` (optional)\n- `focus`\n- `pressOut` (optional)\n\nThe `pressIn` and `pressOut` events are sent by default but can be skipped by passing the `skipPress: true` option.\n\n**Typing (for each character)**:\n\n- `keyPress`\n- `change`\n- `changeText`\n- `selectionChange`\n- `contentSizeChange` (only multiline)\n\n**Leaving the element**:\n\n- `submitEditing` (optional)\n- `endEditing`\n- `blur`\n\nThe `submitEditing` event is skipped by default. It can sent by setting the `submitEditing: true` option.\nThe `endEditing` and `blur` events can be skipped by passing the `skipBlur: true` option.\n\n## `clear()`\n\n```ts\nclear(\n  element: ReactTestInstance,\n)\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.clear(textInput);\n```\n\nThis helper simulates the user clearing the content of a `TextInput` element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n### Sequence of events {#clear-sequence}\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `focus`\n\n**Selecting all content**:\n\n- `selectionChange`\n\n**Pressing backspace**:\n\n- `keyPress`\n- `change`\n- `changeText`\n- `selectionChange`\n\n**Leaving the element**:\n\n- `endEditing`\n- `blur`\n\n## `paste()`\n\n```ts\npaste(\n  element: ReactTestInstance,\n  text: string,\n)\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.paste(textInput, 'Text to paste');\n```\n\nThis helper simulates the user pasting given text to a `TextInput` element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n### Sequence of events {#paste-sequence}\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `focus`\n\n**Selecting all content**:\n\n- `selectionChange`\n\n**Pasting the text**:\n\n- `change`\n- `changeText`\n- `selectionChange`\n\n**Leaving the element**:\n\n- `endEditing`\n- `blur`\n\n## `scrollTo()` {#scroll-to}\n\n:::note\n`scrollTo` interaction has been introduced in RNTL v12.4.0.\n:::\n\n```ts\nscrollTo(\n  element: ReactTestInstance,\n  options: {\n    y: number,\n    momentumY?: number,\n    contentSize?: { width: number, height: number },\n    layoutMeasurement?: { width: number, height: number },\n  } | {\n    x: number,\n    momentumX?: number,\n    contentSize?: { width: number, height: number },\n    layoutMeasurement?: { width: number, height: number },\n  }\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.scrollTo(scrollView, { y: 100, momentumY: 200 });\n```\n\nThis helper simulates the user scrolling a host `ScrollView` element.\n\nThis function supports only host `ScrollView` elements, passing other element types will result in an error. Note that `FlatList` is accepted as it renders to a host `ScrollView` element.\n\nScroll interaction should match the `ScrollView` element direction:\n\n- for a vertical scroll view (default or `horizontal={false}`), you should pass only the `y` option (and optionally also `momentumY`).\n- for a horizontal scroll view (`horizontal={true}`), you should pass only the `x` option (and optionally `momentumX`).\n\nEach scroll interaction consists of a mandatory drag scroll part, which simulates the user dragging the scroll view with his finger (the `y` or `x` option). This may optionally be followed by a momentum scroll movement, which simulates the inertial movement of scroll view content after the user lifts his finger (`momentumY` or `momentumX` options).\n\n### Options {#scroll-to-options}\n\n- `y` - target vertical drag scroll offset\n- `x` - target horizontal drag scroll offset\n- `momentumY` - target vertical momentum scroll offset\n- `momentumX` - target horizontal momentum scroll offset\n- `contentSize` - passed to `ScrollView` events and enabling `FlatList` updates\n- `layoutMeasurement` - passed to `ScrollView` events and enabling `FlatList` updates\n\nUser Event will generate several intermediate scroll steps to simulate user scroll interaction. You should not rely on exact number or values of these scrolls steps as they might be change in the future version.\n\nThis function will remember where the last scroll ended, so subsequent scroll interaction will starts from that position. The initial scroll position will be assumed to be `{ y: 0, x: 0 }`.\n\nTo simulate a `FlatList` (and other controls based on `VirtualizedList`) scrolling, you should pass the `contentSize` and `layoutMeasurement` options, which enable the underlying logic to update the currently visible window.\n\n### Sequence of events {#scroll-sequence}\n\nThe sequence of events depends on whether the scroll includes an optional momentum scroll component.\n\n**Drag scroll**:\n\n- `contentSizeChange`\n- `scrollBeginDrag`\n- `scroll` (multiple events)\n- `scrollEndDrag`\n\n**Momentum scroll (optional)**:\n\n- `momentumScrollBegin`\n- `scroll` (multiple events)\n- `momentumScrollEnd`\n","routePath":"/12.x/docs/api/events/user-event","lang":"en","toc":[{"id":"comparison-with-fire-event-api","text":"Comparison with Fire Event API","depth":2,"charIndex":91},{"id":"setup","text":"`setup()`","depth":2,"charIndex":1329},{"id":"setup-options","text":"Options","depth":3,"charIndex":1588},{"id":"press","text":"`press()`","depth":2,"charIndex":1860},{"id":"longpress","text":"`longPress()`","depth":2,"charIndex":2653},{"id":"longpress-options","text":"Options","depth":3,"charIndex":1588},{"id":"type","text":"`type()`","depth":2,"charIndex":3675},{"id":"type-options","text":"Options","depth":3,"charIndex":1588},{"id":"type-sequence","text":"Sequence of events","depth":3,"charIndex":4692},{"id":"clear","text":"`clear()`","depth":2,"charIndex":5495},{"id":"clear-sequence","text":"Sequence of events","depth":3,"charIndex":4692},{"id":"paste","text":"`paste()`","depth":2,"charIndex":6172},{"id":"paste-sequence","text":"Sequence of events","depth":3,"charIndex":4692},{"id":"scroll-to","text":"`scrollTo()`","depth":2,"charIndex":6865},{"id":"scroll-to-options","text":"Options","depth":3,"charIndex":1588},{"id":"scroll-sequence","text":"Sequence of events","depth":3,"charIndex":4692}],"frontmatter":{},"version":"12.x","description":":::info RNTL minimal version User Event interactions require RNTL v12.2.0 or later. :::"},{"title":"Jest matchers","content":":::info RNTL minimal version\n\nBuilt-in Jest matchers require RNTL v12.4.0 or later.\n\n:::\n\nThis guide describes built-in Jest matchers, we recommend using these matchers as they provide readable tests, accessibility support, and a better developer experience.\n\n## Setup\n\nYou can use the built-in matchers by adding the following line to your `jest-setup.ts` file (configured using [`setupFilesAfterEnv`]()):\n\n```ts title=jest-setup.ts\nimport '@testing-library/react-native/extend-expect';\n```\n\nAlternatively, you can add above script to your Jest configuration (usually located either in the `jest.config.js` file or in the `package.json` file under the `\"jest\"` key):\n\n```json title=jest.config.js\n{\n  \"preset\": \"react-native\",\n  \"setupFilesAfterEnv\": [\"@testing-library/react-native/extend-expect\"]\n}\n```\n\n## Migration from legacy Jest Native matchers.\n\nIf you are already using legacy Jest Native matchers we have a [migration guide]() for moving to the built-in matchers.\n\n## Checking element existence\n\n### `toBeOnTheScreen()`\n\n```ts\nexpect(element).toBeOnTheScreen();\n```\n\nThis allows you to assert whether an element is attached to the element tree or not. If you hold a reference to an element and it gets unmounted during the test it will no longer pass this assertion.\n\n## Element Content\n\n### `toHaveTextContent()`\n\n```ts\nexpect(element).toHaveTextContent(\n  text: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nThis allows you to assert whether the given element has the given text content or not. It accepts either `string` or `RegExp` matchers, as well as [text match options]() of `exact` and `normalizer`.\n\n### `toContainElement()`\n\n```ts\nexpect(container).toContainElement(\n  element: ReactTestInstance | null,\n)\n```\n\nThis allows you to assert whether the given container element does contain another host element.\n\n### `toBeEmptyElement()`\n\n```ts\nexpect(element).toBeEmptyElement();\n```\n\nThis allows you to assert whether the given element does not have any host child elements or text content.\n\n## Checking element state\n\n### `toHaveDisplayValue()`\n\n```ts\nexpect(element).toHaveDisplayValue(\n  value: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nThis allows you to assert whether the given `TextInput` element has a specified display value. It accepts either `string` or `RegExp` matchers, as well as [text match options]() of `exact` and `normalizer`.\n\n### `toHaveAccessibilityValue()`\n\n```ts\nexpect(element).toHaveAccessibilityValue(\n  value: {\n    min?: number;\n    max?: number;\n    now?: number;\n    text?: string | RegExp;\n  },\n)\n```\n\nThis allows you to assert whether the given element has a specified accessible value.\n\nThis matcher will assert accessibility value based on `aria-valuemin`, `aria-valuemax`, `aria-valuenow`, `aria-valuetext` and `accessibilityValue` props. Only defined value entries will be used in the assertion, the element might have additional accessibility value entries and still be matched.\n\nWhen querying by `text` entry a string or `RegExp` might be used.\n\n### `toBeEnabled()` / `toBeDisabled` {#tobeenabled}\n\n```ts\nexpect(element).toBeEnabled();\nexpect(element).toBeDisabled();\n```\n\nThese allow you to assert whether the given element is enabled or disabled from the user's perspective. It relies on the accessibility disabled state as set by `aria-disabled` or `accessibilityState.disabled` props. It will consider a given element disabled when it or any of its ancestors is disabled.\n\n:::note\nThese matchers are the negation of each other, and both are provided to avoid double negations in your assertions.\n:::\n\n### `toBeSelected()`\n\n```ts\nexpect(element).toBeSelected();\n```\n\nThis allows you to assert whether the given element is selected from the user's perspective. It relies on the accessibility selected state as set by `aria-selected` or `accessibilityState.selected` props.\n\n### `toBeChecked()` / `toBePartiallyChecked()` {#tobechecked}\n\n```ts\nexpect(element).toBeChecked();\nexpect(element).toBePartiallyChecked();\n```\n\nThese allow you to assert whether the given element is checked or partially checked from the user's perspective. It relies on the accessibility checked state as set by `aria-checked` or `accessibilityState.checked` props.\n\n:::note\n\n- `toBeChecked()` matcher works only on `Switch` host elements and accessibility elements with `checkbox`, `radio` or `switch` role.\n- `toBePartiallyChecked()` matcher works only on elements with `checkbox` role.\n\n:::\n\n### `toBeExpanded()` / `toBeCollapsed()` {#tobeexpanded}\n\n```ts\nexpect(element).toBeExpanded();\nexpect(element).toBeCollapsed();\n```\n\nThese allows you to assert whether the given element is expanded or collapsed from the user's perspective. It relies on the accessibility disabled state as set by `aria-expanded` or `accessibilityState.expanded` props.\n\n:::note\nThese matchers are the negation of each other for expandable elements (elements with explicit `aria-expanded` or `accessibilityState.expanded` props). However, both won't pass for non-expandable elements (ones without explicit `aria-expanded` or `accessibilityState.expanded` props).\n:::\n\n### `toBeBusy()`\n\n```ts\nexpect(element).toBeBusy();\n```\n\nThis allows you to assert whether the given element is busy from the user's perspective. It relies on the accessibility selected state as set by `aria-busy` or `accessibilityState.busy` props.\n\n## Checking element style\n\n### `toBeVisible()`\n\n```ts\nexpect(element).toBeVisible();\n```\n\nThis allows you to assert whether the given element is visible from the user's perspective.\n\nThe element is considered invisible when itself or any of its ancestors has `display: none` or `opacity: 0` styles, as well as when it's hidden from accessibility.\n\n### `toHaveStyle()`\n\n```ts\nexpect(element).toHaveStyle(\n  style: StyleProp<Style>,\n)\n```\n\nThis allows you to assert whether the given element has given styles.\n\n## Other matchers\n\n### `toHaveAccessibleName()`\n\n```ts\nexpect(element).toHaveAccessibleName(\n  name?: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nThis allows you to assert whether the given element has a specified accessible name. It accepts either `string` or `RegExp` matchers, as well as [text match options]() of `exact` and `normalizer`.\n\nThe accessible name will be computed based on `aria-labelledby`, `accessibilityLabelledBy`, `aria-label`, and `accessibilityLabel` props, in the absence of these props, the element text content will be used.\n\nWhen the `name` parameter is `undefined` it will only check if the element has any accessible name.\n\n### `toHaveProp()`\n\n```ts\nexpect(element).toHaveProp(\n  name: string,\n  value?: unknown,\n)\n```\n\nThis allows you to assert whether the given element has a given prop. When the `value` parameter is `undefined` it will only check for existence of the prop, and when `value` is defined it will check if the actual value matches passed value.\n\n:::note\nThis matcher should be treated as an escape hatch to be used when all other matchers are not suitable.\n:::\n","routePath":"/12.x/docs/api/jest-matchers","lang":"en","toc":[{"id":"setup","text":"Setup","depth":2,"charIndex":260},{"id":"migration-from-legacy-jest-native-matchers","text":"Migration from legacy Jest Native matchers.","depth":2,"charIndex":807},{"id":"checking-element-existence","text":"Checking element existence","depth":2,"charIndex":976},{"id":"tobeonthescreen","text":"`toBeOnTheScreen()`","depth":3,"charIndex":1007},{"id":"element-content","text":"Element Content","depth":2,"charIndex":1279},{"id":"tohavetextcontent","text":"`toHaveTextContent()`","depth":3,"charIndex":1299},{"id":"tocontainelement","text":"`toContainElement()`","depth":3,"charIndex":1682},{"id":"tobeemptyelement","text":"`toBeEmptyElement()`","depth":3,"charIndex":1892},{"id":"checking-element-state","text":"Checking element state","depth":2,"charIndex":2073},{"id":"tohavedisplayvalue","text":"`toHaveDisplayValue()`","depth":3,"charIndex":2100},{"id":"tohaveaccessibilityvalue","text":"`toHaveAccessibilityValue()`","depth":3,"charIndex":2494},{"id":"tobeenabled","text":"`toBeEnabled()` / `toBeDisabled`","depth":3,"charIndex":3132},{"id":"tobeselected","text":"`toBeSelected()`","depth":3,"charIndex":3691},{"id":"tobechecked","text":"`toBeChecked()` / `toBePartiallyChecked()`","depth":3,"charIndex":3962},{"id":"tobeexpanded","text":"`toBeExpanded()` / `toBeCollapsed()`","depth":3,"charIndex":4558},{"id":"tobebusy","text":"`toBeBusy()`","depth":3,"charIndex":5209},{"id":"checking-element-style","text":"Checking element style","depth":2,"charIndex":5460},{"id":"tobevisible","text":"`toBeVisible()`","depth":3,"charIndex":5487},{"id":"tohavestyle","text":"`toHaveStyle()`","depth":3,"charIndex":5808},{"id":"other-matchers","text":"Other matchers","depth":2,"charIndex":5969},{"id":"tohaveaccessiblename","text":"`toHaveAccessibleName()`","depth":3,"charIndex":5988},{"id":"tohaveprop","text":"`toHaveProp()`","depth":3,"charIndex":6686}],"frontmatter":{},"version":"12.x","description":":::info RNTL minimal version Built-in Jest matchers require RNTL v12.4.0 or later. ::: This guide describes built-in Jest matchers, we recommend using these matchers as they provide readable tests, accessibility support, and a better developer experience."},{"title":"Accessibility","content":"## `isHiddenFromAccessibility`\n\n```ts\nfunction isHiddenFromAccessibility(element: ReactTestInstance | null): boolean {}\n```\n\nAlso available as `isInaccessible()` alias for React Testing Library compatibility.\n\nChecks if given element is hidden from assistive technology, e.g. screen readers.\n\n:::note\nLike [`isInaccessible`]() function from DOM Testing Library this function considers both accessibility elements and presentational elements (regular `View`s) to be accessible, unless they are hidden in terms of host platform.\n\nThis covers only part of [ARIA notion of Accessiblity Tree](), as ARIA excludes both hidden and presentational elements from the Accessibility Tree.\n:::\n\nFor the scope of this function, element is inaccessible when it, or any of its ancestors, meets any of the following conditions:\n\n- it has `display: none` style\n- it has [`aria-hidden`]() prop set to `true`\n- it has [`accessibilityElementsHidden`]() prop set to `true`\n- it has [`importantForAccessibility`]() prop set to `no-hide-descendants`\n- it has sibling host element with either [`aria-modal`]() or [`accessibilityViewIsModal`]() prop set to `true`\n\nSpecifying `accessible={false}`, `accessiblityRole=\"none\"`, or `importantForAccessibility=\"no\"` props does not cause the element to become inaccessible.\n","routePath":"/12.x/docs/api/misc/accessibility","lang":"en","toc":[{"id":"ishiddenfromaccessibility","text":"`isHiddenFromAccessibility`","depth":2,"charIndex":0}],"frontmatter":{},"version":"12.x"},{"title":"Async utilities","content":"## `findBy*` queries\n\nThe `findBy*` queries are used to find elements that are not instantly available but will be added as a result of some asynchronous action. Learn more details [here]().\n\n## `waitFor`\n\n```tsx\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: { timeout: number; interval: number }\n): Promise<T>;\n```\n\nWaits for a period of time for the `expectation` callback to pass. `waitFor` may run the callback a number of times until timeout is reached, as specified by the `timeout` and `interval` options. The callback must throw an error when the expectation is not met. Returning any value, including a falsy one, will be treated as meeting the expectation, and the callback result will be returned to the caller of `waitFor` function.\n\n```tsx\nawait waitFor(() => expect(mockFunction).toHaveBeenCalledWith());\n```\n\n`waitFor` function will be executing `expectation` callback every `interval` (default: every 50 ms) until `timeout` (default: 1000 ms) is reached. The repeated execution of callback is stopped as soon as it does not throw an error, in such case the value returned by the callback is returned to `waitFor` caller. Otherwise, when it reaches the timeout, the final error thrown by `expectation` will be re-thrown by `waitFor` to the calling code.\n\n```tsx\n// ❌ `waitFor` will return immediately because callback does not throw\nawait waitFor(() => false);\n```\n\n`waitFor` is an async function so you need to `await` the result to pause test execution.\n\n```jsx\n// ❌ missing `await`: `waitFor` will just return Promise that will be rejected when the timeout is reached\nwaitFor(() => expect(1).toBe(2));\n```\n\n:::note\nYou can enforce awaiting `waitFor` by using the [await-async-utils]() rule from [eslint-plugin-testing-library]().\n:::\n\nSince `waitFor` is likely to run `expectation` callback multiple times, it is highly recommended for it [not to perform any side effects]() in `waitFor`.\n\n```jsx\nawait waitFor(() => {\n  // ❌ button will be pressed on each waitFor iteration\n  fireEvent.press(screen.getByText('press me'));\n  expect(mockOnPress).toHaveBeenCalled();\n});\n```\n\n:::note\nAvoiding side effects in `expectation` callback can be partially enforced with the [`no-wait-for-side-effects` rule]().\n:::\n\nIt is also recommended to have a [single assertion per each `waitFor`]() for more consistency and faster failing tests. If you want to make several assertions, then they should be in seperate `waitFor` calls. In many cases you won't actually need to wrap the second assertion in `waitFor` since the first one will do the waiting required for asynchronous change to happen.\n\n### Using a React Native version < 0.71 with Jest fake timers\n\n:::caution\nWhen using a version of React Native < 0.71 and modern fake timers (the default for `Jest` >= 27), `waitFor` won't work (it will always timeout even if `expectation()` doesn't throw) unless you use the custom [@testing-library/react-native preset]().\n:::\n\n`waitFor` checks whether Jest fake timers are enabled and adapts its behavior in such case. The following snippet is a simplified version of how it behaves when fake timers are enabled:\n\n```tsx\nlet fakeTimeRemaining = timeout;\nlet lastError;\n\nwhile (fakeTimeRemaining > 0) {\n  fakeTimeRemaining = fakeTimeRemaining - interval;\n  jest.advanceTimersByTime(interval);\n  try {\n    // resolve\n    return expectation();\n  } catch (error) {\n    lastError = error;\n  }\n}\n\n// reject\nthrow lastError;\n```\n\nIn the following example we test that a function is called after 10 seconds using fake timers. Since we're using fake timers, the test won't depend on real time passing and thus be much faster and more reliable. Also we don't have to advance fake timers through Jest fake timers API because `waitFor` already does this for us.\n\n```tsx\n// in component\nsetTimeout(() => {\n  someFunction();\n}, 10000);\n\n// in test\njest.useFakeTimers();\n\nawait waitFor(() => {\n  expect(someFunction).toHaveBeenCalledWith();\n}, 10000);\n```\n\n:::info\nIn order to properly use `waitFor` you need at least React >=16.9.0 (featuring async `act`) or React Native >=0.61 (which comes with React >=16.9.0).\n:::\n\n:::note\nIf you receive warnings related to `act()` function consult our [Understanding Act]() function document.\n:::\n\n## `waitForElementToBeRemoved`\n\n```ts\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: { timeout: number; interval: number }\n): Promise<T>;\n```\n\nWaits for non-deterministic periods of time until queried element is removed or times out. `waitForElementToBeRemoved` periodically calls `expectation` every `interval` milliseconds to determine whether the element has been removed or not.\n\n```jsx\n\n\ntest('waiting for an Banana to be removed', async () => {\n  render(<Banana />);\n\n  await waitForElementToBeRemoved(() => screen.getByText('Banana ready'));\n});\n```\n\nThis method expects that the element is initially present in the render tree and then is removed from it. If the element is not present when you call this method it throws an error.\n\nYou can use any of `getBy`, `getAllBy`, `queryBy` and `queryAllBy` queries for `expectation` parameter.\n\n:::info\nIn order to properly use `waitForElementToBeRemoved` you need at least React >=16.9.0 (featuring async `act`) or React Native >=0.61 (which comes with React >=16.9.0).\n:::\n\n:::note\nIf you receive warnings related to `act()` function consult our [Understanding Act]() function document.\n:::\n","routePath":"/12.x/docs/api/misc/async","lang":"en","toc":[{"id":"findby-queries","text":"`findBy*` queries","depth":2,"charIndex":0},{"id":"waitfor","text":"`waitFor`","depth":2,"charIndex":192},{"id":"using-a-react-native-version--071-with-jest-fake-timers","text":"Using a React Native version < 0.71 with Jest fake timers","depth":3,"charIndex":2611},{"id":"waitforelementtoberemoved","text":"`waitForElementToBeRemoved`","depth":2,"charIndex":4237}],"frontmatter":{},"version":"12.x"},{"title":"Configuration","content":"## `configure`\n\n```ts\ntype Config = {\n  asyncUtilTimeout: number;\n  defaultHidden: boolean;\n  defaultDebugOptions: Partial<DebugOptions>;\n  concurrentRoot: boolean;\n};\n\nfunction configure(options: Partial<Config>) {}\n```\n\n### `asyncUtilTimeout` option\n\nDefault timeout, in ms, for async helper functions (`waitFor`, `waitForElementToBeRemoved`) and `findBy*` queries. Defaults to 1000 ms.\n\n### `defaultIncludeHiddenElements` option\n\nDefault value for [includeHiddenElements]() query option for all queries. The default value is set to `false`, so all queries will not match [elements hidden from accessibility](). This is because the users of the app would not be able to see such elements.\n\nThis option is also available as `defaultHidden` alias for compatibility with [React Testing Library]().\n\n### `defaultDebugOptions` option\n\nDefault [debug options]() to be used when calling `debug()`. These default options will be overridden by the ones you specify directly when calling `debug()`.\n\n### `concurrentRoot` option {#concurrent-root}\n\nSet to `true` to enable concurrent rendering used in the React Native New Architecture. Otherwise `render` will default to legacy synchronous rendering.\n\n## `resetToDefaults()`\n\n```ts\nfunction resetToDefaults() {}\n```\n\n## Environment variables\n\n### `RNTL_SKIP_AUTO_CLEANUP`\n\nSet to `true` to disable automatic `cleanup()` after each test. It works the same as importing `react-native-testing-library/dont-cleanup-after-each` or using `react-native-testing-library/pure`.\n\n```shell\n$ RNTL_SKIP_AUTO_CLEANUP=true jest\n```\n\n### `RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`\n\nSet to `true` to disable auto-detection of fake timers. This might be useful in rare cases when you want to use non-Jest fake timers. See [issue #886]() for more details.\n\n```shell\n$ RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS=true jest\n```\n","routePath":"/12.x/docs/api/misc/config","lang":"en","toc":[{"id":"configure","text":"`configure`","depth":2,"charIndex":0},{"id":"asyncutiltimeout-option","text":"`asyncUtilTimeout` option","depth":3,"charIndex":222},{"id":"defaultincludehiddenelements-option","text":"`defaultIncludeHiddenElements` option","depth":3,"charIndex":390},{"id":"defaultdebugoptions-option","text":"`defaultDebugOptions` option","depth":3,"charIndex":798},{"id":"concurrent-root","text":"`concurrentRoot` option","depth":3,"charIndex":992},{"id":"resettodefaults","text":"`resetToDefaults()`","depth":2,"charIndex":1194},{"id":"environment-variables","text":"Environment variables","depth":2,"charIndex":1259},{"id":"rntl_skip_auto_cleanup","text":"`RNTL_SKIP_AUTO_CLEANUP`","depth":3,"charIndex":1285},{"id":"rntl_skip_auto_detect_fake_timers","text":"`RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`","depth":3,"charIndex":1561}],"frontmatter":{},"version":"12.x"},{"title":"Other helpers","content":"## `within`, `getQueriesForElement` {#within}\n\n```jsx\nfunction within(element: ReactTestInstance): Queries {}\n\nfunction getQueriesForElement(element: ReactTestInstance): Queries {}\n```\n\n`within` (also available as `getQueriesForElement` alias) performs [queries]() scoped to given element.\n\n:::note\nPlease note that additional `render` specific operations like `update`, `unmount`, `debug`, `toJSON` are *not* included.\n:::\n\n```jsx\nconst detailsScreen = within(screen.getByA11yHint('Details Screen'));\nexpect(detailsScreen.getByText('Some Text')).toBeOnTheScreen();\nexpect(detailsScreen.getByDisplayValue('Some Value')).toBeOnTheScreen();\nexpect(detailsScreen.queryByLabelText('Some Label')).toBeOnTheScreen();\nawait expect(detailsScreen.findByA11yHint('Some Label')).resolves.toBeOnTheScreen();\n```\n\nUse cases for scoped queries include:\n\n- queries scoped to a single item inside a FlatList containing many items\n- queries scoped to a single screen in tests involving screen transitions (e.g. with react-navigation)\n\n## `act`\n\nUseful function to help testing components that use hooks API. By default any `render`, `update`, `fireEvent`, and `waitFor` calls are wrapped by this function, so there is no need to wrap it manually. This method is re-exported from [`react-test-renderer`]().\n\nConsult our [Understanding Act function]() document for more understanding of its intricacies.\n\n## `cleanup`\n\n```ts\nconst cleanup: () => void;\n```\n\nUnmounts React trees that were mounted with `render` and clears `screen` variable that holds latest `render` output.\n\n:::info\nPlease note that this is done automatically if the testing framework you're using supports the `afterEach` global (like mocha, Jest, and Jasmine). If not, you will need to do manual cleanups after each test.\n:::\n\nFor example, if you're using the `jest` testing framework, then you would need to use the `afterEach` hook like so:\n\n```jsx\n\n\n\nafterEach(cleanup);\n\nit('renders a view', () => {\n  render(<View />);\n  // ...\n});\n```\n\nThe `afterEach(cleanup)` call also works in `describe` blocks:\n\n```jsx\ndescribe('when logged in', () => {\n  afterEach(cleanup);\n\n  it('renders the user', () => {\n    render(<SiteHeader />);\n    // ...\n  });\n});\n```\n\nFailing to call `cleanup` when you've called `render` could result in a memory leak and tests which are not \"idempotent\" (which can lead to difficult to debug errors in your tests).\n","routePath":"/12.x/docs/api/misc/other","lang":"en","toc":[{"id":"within","text":"`within`, `getQueriesForElement`","depth":2,"charIndex":0},{"id":"act","text":"`act`","depth":2,"charIndex":1018},{"id":"cleanup","text":"`cleanup`","depth":2,"charIndex":1386}],"frontmatter":{},"version":"12.x"},{"title":"`renderHook` function","content":"```ts\nfunction renderHook<Result, Props>(\n  callback: (props?: Props) => Result,\n  options?: RenderHookOptions<Props>\n): RenderHookResult<Result, Props>;\n```\n\nRenders a test component that will call the provided `callback`, including any hooks it calls, every time it renders. Returns [`RenderHookResult`]() object, which you can interact with.\n\n```ts\n\n\n\nit('should increment count', () => {\n  const { result } = renderHook(() => useCount());\n\n  expect(result.current.count).toBe(0);\n  act(() => {\n    // Note that you should wrap the calls to functions your hook returns with `act` if they trigger an update of your hook's state to ensure pending useEffects are run before your next assertion.\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n```\n\n```ts\n// useCount.js\nexport const useCount = () => {\n  const [count, setCount] = useState(0);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  return { count, increment };\n};\n```\n\nThe `renderHook` function accepts the following arguments:\n\nCallback is a function that is called each `render` of the test component. This function should call one or more hooks for testing.\n\nThe `props` passed into the callback will be the `initialProps` provided in the `options` to `renderHook`, unless new props are provided by a subsequent `rerender` call.\n\n## `options`\n\nA `RenderHookOptions<Props>` object to modify the execution of the `callback` function, containing the following properties:\n\n### `initialProps`\n\nThe initial values to pass as `props` to the `callback` function of `renderHook`. The `Props` type is determined by the type passed to or inferred by the `renderHook` call.\n\n### `wrapper`\n\nA React component to wrap the test component in when rendering. This is usually used to add context providers from `React.createContext` for the hook to access with `useContext`.\n\n## `RenderHookResult`\n\n```ts\ninterface RenderHookResult<Result, Props> {\n  result: { current: Result };\n  rerender: (props: Props) => void;\n  unmount: () => void;\n}\n```\n\nThe `renderHook` function returns an object that has the following properties:\n\n### `result`\n\nThe `current` value of the `result` will reflect the latest of whatever is returned from the `callback` passed to `renderHook`. The `Result` type is determined by the type passed to or inferred by the `renderHook` call.\n\n### `rerender`\n\nA function to rerender the test component, causing any hooks to be recalculated. If `newProps` are passed, they will replace the `callback` function's `initialProps` for subsequent rerenders. The `Props` type is determined by the type passed to or inferred by the `renderHook` call.\n\n### `unmount`\n\nA function to unmount the test component. This is commonly used to trigger cleanup effects for `useEffect` hooks.\n\n## Examples\n\nHere we present some extra examples of using `renderHook` API.\n\n### With `initialProps`\n\n```ts\nconst useCount = (initialCount: number) => {\n  const [count, setCount] = useState(initialCount);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  useEffect(() => {\n    setCount(initialCount);\n  }, [initialCount]);\n\n  return { count, increment };\n};\n\nit('should increment count', () => {\n  const { result, rerender } = renderHook((initialCount: number) => useCount(initialCount), {\n    initialProps: 1,\n  });\n\n  expect(result.current.count).toBe(1);\n\n  act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(2);\n  rerender(5);\n  expect(result.current.count).toBe(5);\n});\n```\n\n### With `wrapper`\n\n```tsx\nit('should use context value', () => {\n  function Wrapper({ children }: { children: ReactNode }) {\n    return <Context.Provider value=\"provided\">{children}</Context.Provider>;\n  }\n\n  const { result } = renderHook(() => useHook(), { wrapper: Wrapper });\n  // ...\n});\n```\n","routePath":"/12.x/docs/api/misc/render-hook","lang":"en","toc":[{"id":"options","text":"`options`","depth":2,"charIndex":1354},{"id":"initialprops","text":"`initialProps`","depth":3,"charIndex":1494},{"id":"wrapper","text":"`wrapper`","depth":3,"charIndex":1688},{"id":"renderhookresult","text":"`RenderHookResult`","depth":2,"charIndex":1883},{"id":"result","text":"`result`","depth":3,"charIndex":2133},{"id":"rerender","text":"`rerender`","depth":3,"charIndex":2368},{"id":"unmount","text":"`unmount`","depth":3,"charIndex":2668},{"id":"examples","text":"Examples","depth":2,"charIndex":2798},{"id":"with-initialprops","text":"With `initialProps`","depth":3,"charIndex":2875},{"id":"with-wrapper","text":"With `wrapper`","depth":3,"charIndex":3541}],"frontmatter":{},"version":"12.x","description":"Renders a test component that will call the provided callback, including any hooks it calls, every time it renders. Returns RenderHookResult object, which you can interact with. The renderHook function accepts the following arguments: Callback is a function that is called each render of the test component. This function should call one or more hooks for testing. The props passed into the callback will be the initialProps provided in the options to renderHook, unless new props are provided by a subsequent rerender call."},{"title":"Queries","content":"Queries are one of the main building blocks for the React Native Testing Library. They enable you to find relevant elements in the element tree, which represents your application's user interface when running under tests.\n\n## Accessing queries\n\nAll queries described below are accessible in two main ways: through the `screen` object or by capturing the `render` function call result.\n\n### Using `screen` object\n\n```tsx\n\n\ntest('accessing queries using \"screen\" object', () => {\n  render(...);\n\n  screen.getByRole(\"button\", { name: \"Start\" });\n})\n```\n\nThe modern and recommended way of accessing queries is to use the `screen` object exported by the `@testing-library/react-native` package. This object will contain methods of all available queries bound to the most recently rendered UI.\n\n### Using `render` result\n\n```tsx\n\n\ntest('accessing queries using \"render\" result', () => {\n  const { getByRole } = render(...);\n  getByRole(\"button\", { name: \"Start\" });\n})\n```\n\nThe classic way is to capture query functions, as they are returned from the `render` function call. This provides access to the same functions as in the case of the `screen` object.\n\n## Query parts\n\nEach query is composed of two parts: variant and predicate, which are separated by the `by` word in the middle of the name.\n\nConsider the following query:\n\n```\ngetByRole()\n```\n\nFor this query, `getBy*` is the query variant, and `*ByRole` is the predicate.\n\n## Query variant\n\nThe query variants describe the expected number (and timing) of matching elements, so they differ in their return type.\n\n| Variant           | Assertion                     | Return type                            | Is Async? |\n| ----------------- | ----------------------------- | -------------------------------------- | --------- |\n| [`getBy*`]()      | Exactly one matching element  | `ReactTestInstance`                    | No        |\n| [`getAllBy*`]()   | At least one matching element | `Array<ReactTestInstance>`             | No        |\n| [`queryBy*`]()    | Zero or one matching element  | <code>ReactTestInstance \\| null</code> | No        |\n| [`queryAllBy*`]() | No assertion                  | `Array<ReactTestInstance>`             | No        |\n| [`findBy*`]()     | Exactly one matching element  | `Promise<ReactTestInstance>`           | Yes       |\n| [`findAllBy*`]()  | At least one matching element | `Promise<Array<ReactTestInstance>>`    | Yes       |\n\nQueries work as implicit assertions on the number of matching elements and will throw an error when the assertion fails.\n\n### `getBy*` queries {#get-by}\n\n```ts\ngetByX(...): ReactTestInstance\n```\n\n`getBy*` queries return the single matching element for a query, and throw an error if no elements match or if more than one match is found. If you need to find more than one element, then use `getAllBy`.\n\n### `getAllBy*` queries {#get-all-by}\n\n```ts\ngetAllByX(...): ReactTestInstance[]\n```\n\n`getAllBy*` queries return an array of all matching elements for a query and throw an error if no elements match.\n\n### `queryBy*` queries {#query-by}\n\n```ts\nqueryByX(...): ReactTestInstance | null\n```\n\n`queryBy*` queries return the first matching node for a query, and return `null` if no elements match. This is useful for asserting an element that is not present. This throws if more than one match is found (use `queryAllBy` instead).\n\n### `queryAllBy*` queries {#query-all-by}\n\n```ts\nqueryAllByX(...): ReactTestInstance[]\n```\n\n`queryAllBy*` queries return an array of all matching nodes for a query and return an empty array (`[]`) when no elements match.\n\n### `findBy*` queries {#find-by}\n\n```ts\nfindByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<ReactTestInstance>\n```\n\n`findBy*` queries return a promise which resolves when a matching element is found. The promise is rejected if no elements match or if more than one match is found after a default timeout of 1000 ms. If you need to find more than one element use `findAllBy*` queries.\n\n### `findAllBy*` queries {#find-all-by}\n\n```ts\nfindAllByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<ReactTestInstance[]>\n```\n\n`findAllBy*` queries return a promise which resolves to an array of matching elements. The promise is rejected if no elements match after a default timeout of 1000 ms.\n\n:::info\n`findBy*` and `findAllBy*` queries accept optional `waitForOptions` object arguments, which can contain `timeout`, `interval` and `onTimeout` properties which have the same meaning as respective options for [`waitFor`]() function.\n:::\n\n:::info\nIn cases when your `findBy*` and `findAllBy*` queries throw when unable to find matching elements, it is helpful to pass `onTimeout: () => { screen.debug(); }` callback using the `waitForOptions` parameter.\n:::\n\n## Query predicates\n\n*Note: most methods like this one return a [`ReactTestInstance`]() with following properties that you may be interested in:*\n\n```typescript\ntype ReactTestInstance = {\n  type: string | Function;\n  props: { [propName: string]: any };\n  parent: ReactTestInstance | null;\n  children: Array<ReactTestInstance | string>;\n};\n```\n\n### `*ByRole` {#by-role}\n\n> getByRole, getAllByRole, queryByRole, queryAllByRole, findByRole, findAllByRole\n\n```ts\ngetByRole(\n  role: TextMatch,\n  options?: {\n    name?: TextMatch\n    disabled?: boolean,\n    selected?: boolean,\n    checked?: boolean | 'mixed',\n    busy?: boolean,\n    expanded?: boolean,\n    value: {\n      min?: number;\n      max?: number;\n      now?: number;\n      text?: TextMatch;\n    },\n    includeHiddenElements?: boolean;\n  }\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` with matching `role` or `accessibilityRole` prop.\n\n:::info\nIn order for `*ByRole` queries to match an element it needs to be considered an accessibility element:\n\n1. `Text`, `TextInput` and `Switch` host elements are these by default.\n2. `View` host elements need an explicit [`accessible`]() prop set to `true`\n3. Some React Native composite components like `Pressable` & `TouchableOpacity` render host `View` element with `accessible` prop already set.\n\n:::\n\n```jsx\n\n\nrender(\n  <Pressable accessibilityRole=\"button\" disabled>\n    <Text>Hello</Text>\n  </Pressable>\n);\nconst element = screen.getByRole('button');\nconst element2 = screen.getByRole('button', { name: 'Hello' });\nconst element3 = screen.getByRole('button', { name: 'Hello', disabled: true });\n```\n\n#### Options {#by-role-options}\n\n- `name`: Finds an element with given `role`/`accessibilityRole` and an accessible name (= accessability label or text content).\n\n- `disabled`: You can filter elements by their disabled state (coming either from `aria-disabled` prop or `accessbilityState.disabled` prop). The possible values are `true` or `false`. Querying `disabled: false` will also match elements with `disabled: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `disabled` state.\n  - This option can alternatively be expressed using the [`toBeEnabled()` / `toBeDisabled()`]() Jest matchers.\n\n- `selected`: You can filter elements by their selected state (coming either from `aria-selected` prop or `accessbilityState.selected` prop). The possible values are `true` or `false`. Querying `selected: false` will also match elements with `selected: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `selected` state.\n  - This option can alternatively be expressed using the [`toBeSelected()`]() Jest matcher.\n\n* `checked`: You can filter elements by their checked state (coming either from `aria-checked` prop or `accessbilityState.checked` prop). The possible values are `true`, `false`, or `\"mixed\"`.\n  - See [React Native's accessibilityState]() docs to learn more about the `checked` state.\n  - This option can alternatively be expressed using the [`toBeChecked()` / `toBePartiallyChecked()`]() Jest matchers.\n\n* `busy`: You can filter elements by their busy state (coming either from `aria-busy` prop or `accessbilityState.busy` prop). The possible values are `true` or `false`. Querying `busy: false` will also match elements with `busy: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `busy` state.\n  - This option can alternatively be expressed using the [`toBeBusy()`]() Jest matcher.\n\n* `expanded`: You can filter elements by their expanded state (coming either from `aria-expanded` prop or `accessbilityState.expanded` prop). The possible values are `true` or `false`.\n  - See [React Native's accessibilityState]() docs to learn more about the `expanded` state.\n  - This option can alternatively be expressed using the [`toBeExpanded()` / `toBeCollapsed()`]() Jest matchers.\n\n* `value`: Filter elements by their accessibility value, based on either `aria-valuemin`, `aria-valuemax`, `aria-valuenow`, `aria-valuetext` or `accessibilityValue` props. Accessiblity value conceptually consists of numeric `min`, `max` and `now` entries, as well as string `text` entry.\n  - See React Native [accessibilityValue]() docs to learn more about the accessibility value concept.\n  - This option can alternatively be expressed using the [`toHaveAccessibilityValue()`]() Jest matcher.\n\n### `*ByLabelText` {#by-label-text}\n\n> getByLabelText, getAllByLabelText, queryByLabelText, queryAllByLabelText, findByLabelText, findAllByLabelText\n\n```ts\ngetByLabelText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` with matching label:\n\n- either by matching [`aria-label`]()/[`accessibilityLabel`]() prop\n- or by matching text content of view referenced by [`aria-labelledby`]()/[`accessibilityLabelledBy`]() prop\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByLabelText('my-label');\n```\n\n### `*ByPlaceholderText` {#by-placeholder-text}\n\n> getByPlaceholderText, getAllByPlaceholderText, queryByPlaceholderText, queryAllByPlaceholderText, findByPlaceholderText, findAllByPlaceholderText\n\n```ts\ngetByPlaceholderText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` for a `TextInput` with a matching placeholder – may be a string or regular expression.\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByPlaceholderText('username');\n```\n\n### `*ByDisplayValue` {#by-display-value}\n\n> getByDisplayValue, getAllByDisplayValue, queryByDisplayValue, queryAllByDisplayValue, findByDisplayValue, findAllByDisplayValue\n\n```ts\ngetByDisplayValue(\n  value: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` for a `TextInput` with a matching display value – may be a string or regular expression.\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByDisplayValue('username');\n```\n\n### `*ByText` {#by-text}\n\n> getByText, getAllByText, queryByText, queryAllByText, findByText, findAllByText\n\n```ts\ngetByText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` with matching text – may be a string or regular expression.\n\nThis method will join `<Text>` siblings to find matches, similarly to [how React Native handles these components](). This will allow for querying for strings that will be visually rendered together, but may be semantically separate React components.\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByText('banana');\n```\n\n### `*ByHintText` {#by-hint-text}\n\n> getByA11yHint, getAllByA11yHint, queryByA11yHint, queryAllByA11yHint, findByA11yHint, findAllByA11yHint\n> getByAccessibilityHint, getAllByAccessibilityHint, queryByAccessibilityHint, queryAllByAccessibilityHint, findByAccessibilityHint, findAllByAccessibilityHint\n> getByHintText, getAllByHintText, queryByHintText, queryAllByHintText, findByHintText, findAllByHintText\n\n```ts\ngetByHintText(\n  hint: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` with matching `accessibilityHint` prop.\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByHintText('Plays a song');\n```\n\n:::info\nPlease consult [Apple guidelines on how `accessibilityHint` should be used]().\n:::\n\n### `*ByTestId` {#by-test-id}\n\n> getByTestId, getAllByTestId, queryByTestId, queryAllByTestId, findByTestId, findAllByTestId\n\n```ts\ngetByTestId(\n  testId: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): ReactTestInstance;\n```\n\nReturns a `ReactTestInstance` with matching `testID` prop. `testID` – may be a string or a regular expression.\n\n```jsx\n\n\nrender(<MyComponent />);\nconst element = screen.getByTestId('unique-id');\n```\n\n:::info\nIn the spirit of [the guiding principles](), it is recommended to use this only after the other queries don't work for your use case. Using `testID` attributes do not resemble how your software is used and should be avoided if possible. However, they are particularly useful for end-to-end testing on real devices, e.g. using Detox and it's an encouraged technique to use there. Learn more from the blog post [\"Making your UI tests resilient to change\"]().\n:::\n\n### Common options\n\nUsually query first argument can be a **string** or a **regex**. All queries take at least the [`hidden`]() option as an optionnal second argument and some queries accept more options which change string matching behaviour. See [TextMatch]() for more info.\n\n#### `includeHiddenElements` option\n\nAll queries have the `includeHiddenElements` option which affects whether [elements hidden from accessibility]() are matched by the query. By default queries will not match hidden elements, because the users of the app would not be able to see such elements.\n\nYou can configure the default value with the [`configure` function]().\n\nThis option is also available as `hidden` alias for compatibility with [React Testing Library]().\n\n**Examples**\n\n```tsx\nrender(<Text style={{ display: 'none' }}>Hidden from accessibility</Text>);\n\n// Exclude hidden elements\nexpect(\n  screen.queryByText('Hidden from accessibility', {\n    includeHiddenElements: false,\n  })\n).not.toBeOnTheScreen();\n\n// Include hidden elements\nexpect(screen.getByText('Hidden from accessibility')).toBeOnTheScreen();\nexpect(\n  screen.getByText('Hidden from accessibility', { includeHiddenElements: true })\n).toBeOnTheScreen();\n```\n\n## TextMatch type\n\n```ts\ntype TextMatch = string | RegExp;\n```\n\nMost of the query APIs take a `TextMatch` as an argument, which means the argument can be either a *string* or *regex*.\n\n### Examples\n\nGiven the following render:\n\n```jsx\nrender(<Text>Hello World</Text>);\n```\n\nWill **find a match**:\n\n```js\n// Matching a string:\nscreen.getByText('Hello World'); // full string match\nscreen.getByText('llo Worl', { exact: false }); // substring match\nscreen.getByText('hello world', { exact: false }); // ignore case-sensitivity\n\n// Matching a regex:\nscreen.getByText(/World/); // substring match\nscreen.getByText(/world/i); // substring match, ignore case\nscreen.getByText(/^hello world$/i); // full string match, ignore case-sensitivity\nscreen.getByText(/Hello W?oRlD/i); // advanced regex\n```\n\nWill **NOT find a match**\n\n```js\n// substring does not match\nscreen.getByText('llo Worl');\n// full string does not match\nscreen.getByText('Goodbye World');\n\n// case-sensitive regex with different case\nscreen.getByText(/hello world/);\n```\n\n### Options {#text-match-options}\n\n#### Precision\n\n```typescript\ntype TextMatchOptions = {\n  exact?: boolean;\n  normalizer?: (text: string) => string;\n};\n```\n\nQueries that take a `TextMatch` also accept an object as the second argument that can contain options that affect the precision of string matching:\n\n- `exact`: Defaults to `true`; matches full strings, case-sensitive. When false, matches substrings and is not case-sensitive.\n  - `exact` has no effect on regex argument.\n  - In most cases using a `regex` instead of a string gives you more control over fuzzy matching and should be preferred over `{ exact: false }`.\n- `normalizer`: An optional function which overrides normalization behavior. See [Normalization]().\n\n`exact` option defaults to `true` but if you want to search for a text slice or make text matching case-insensitive you can override it. That being said we advise you to use regex in more complex scenarios.\n\n#### Normalization\n\nBefore running any matching logic against text, it is automatically normalized. By default, normalization consists of trimming whitespace from the start and end of text, and collapsing multiple adjacent whitespace characters into a single space.\n\nIf you want to prevent that normalization, or provide alternative normalization (e.g. to remove Unicode control characters), you can provide a `normalizer` function in the options object. This function will be given a string and is expected to return a normalized version of that string.\n\n:::info\nSpecifying a value for `normalizer` replaces the built-in normalization, but you can call `getDefaultNormalizer` to obtain a built-in normalizer, either to adjust that normalization or to call it from your own normalizer.\n:::\n\n`getDefaultNormalizer` take options object which allows the selection of behaviour:\n\n- `trim`: Defaults to `true`. Trims leading and trailing whitespace.\n- `collapseWhitespace`: Defaults to `true`. Collapses inner whitespace (newlines, tabs repeated spaces) into a single space.\n\n##### Normalization Examples\n\nTo perform a match against text without trimming:\n\n```typescript\nscreen.getByText(node, 'text', {\n  normalizer: getDefaultNormalizer({ trim: false }),\n});\n```\n\nTo override normalization to remove some Unicode characters whilst keeping some (but not all) of the built-in normalization behavior:\n\n```typescript\nscreen.getByText(node, 'text', {\n  normalizer: (str) => getDefaultNormalizer({ trim: false })(str).replace(/[\\u200E-\\u200F]*/g, ''),\n});\n```\n\n## Legacy unit testing helpers\n\n`render` from `@testing-library/react-native` exposes additional queries that **should not be used in integration or component testing**, but some users (like component library creators) interested in unit testing some components may find helpful.\n\nThe interface is the same as for other queries, but we won't provide full names so that they're harder to find by search engines.\n\n### `UNSAFE_ByType`\n\n> UNSAFE\\_getByType, UNSAFE\\_getAllByType, UNSAFE\\_queryByType, UNSAFE\\_queryAllByType\n\nReturns a `ReactTestInstance` with matching a React component type.\n\n:::caution\nThis query has been marked unsafe, since it requires knowledge about implementation details of the component. Use responsibly.\n:::\n\n### `UNSAFE_ByProps`\n\n> UNSAFE\\_getByProps, UNSAFE\\_getAllByProps, UNSAFE\\_queryByProps, UNSAFE\\_queryAllByProps\n\nReturns a `ReactTestInstance` with matching props object.\n\n:::caution\nThis query has been marked unsafe, since it requires knowledge about implementation details of the component. Use responsibly.\n:::\n","routePath":"/12.x/docs/api/queries","lang":"en","toc":[{"id":"accessing-queries","text":"Accessing queries","depth":2,"charIndex":223},{"id":"using-screen-object","text":"Using `screen` object","depth":3,"charIndex":386},{"id":"using-render-result","text":"Using `render` result","depth":3,"charIndex":789},{"id":"query-parts","text":"Query parts","depth":2,"charIndex":1152},{"id":"query-variant","text":"Query variant","depth":2,"charIndex":1425},{"id":"get-by","text":"`getBy*` queries","depth":3,"charIndex":2543},{"id":"get-all-by","text":"`getAllBy*` queries","depth":3,"charIndex":2823},{"id":"query-by","text":"`queryBy*` queries","depth":3,"charIndex":3024},{"id":"query-all-by","text":"`queryAllBy*` queries","depth":3,"charIndex":3348},{"id":"find-by","text":"`findBy*` queries","depth":3,"charIndex":3570},{"id":"find-all-by","text":"`findAllBy*` queries","depth":3,"charIndex":4001},{"id":"query-predicates","text":"Query predicates","depth":2,"charIndex":4808},{"id":"by-role","text":"`*ByRole`","depth":3,"charIndex":5152},{"id":"by-role-options","text":"Options","depth":4,"charIndex":6421},{"id":"by-label-text","text":"`*ByLabelText`","depth":3,"charIndex":9324},{"id":"by-placeholder-text","text":"`*ByPlaceholderText`","depth":3,"charIndex":9982},{"id":"by-display-value","text":"`*ByDisplayValue`","depth":3,"charIndex":10587},{"id":"by-text","text":"`*ByText`","depth":3,"charIndex":11166},{"id":"by-hint-text","text":"`*ByHintText`","depth":3,"charIndex":11882},{"id":"by-test-id","text":"`*ByTestId`","depth":3,"charIndex":12733},{"id":"common-options","text":"Common options","depth":3,"charIndex":13716},{"id":"includehiddenelements-option","text":"`includeHiddenElements` option","depth":4,"charIndex":13994},{"id":"textmatch-type","text":"TextMatch type","depth":2,"charIndex":14927},{"id":"examples","text":"Examples","depth":3,"charIndex":15112},{"id":"text-match-options","text":"Options","depth":3,"charIndex":6422},{"id":"precision","text":"Precision","depth":4,"charIndex":15994},{"id":"normalization","text":"Normalization","depth":4,"charIndex":16894},{"id":"legacy-unit-testing-helpers","text":"Legacy unit testing helpers","depth":2,"charIndex":18446},{"id":"unsafe_bytype","text":"`UNSAFE_ByType`","depth":3,"charIndex":18858},{"id":"unsafe_byprops","text":"`UNSAFE_ByProps`","depth":3,"charIndex":19179}],"frontmatter":{},"version":"12.x","description":"Queries are one of the main building blocks for the React Native Testing Library. They enable you to find relevant elements in the element tree, which represents your application's user interface when running under tests."},{"title":"`render` function","content":"```jsx\nfunction render(\n  component: React.Element<any>,\n  options?: RenderOptions\n): RenderResult\n```\n\nThe `render` function is the entry point for writing React Native Testing Library tests. It deeply renders the given React element and returns helpers to query the output components' structure.\n\n```jsx\n\n\ntest('basic test', () => {\n  render(<MyApp />);\n  expect(screen.getAllByRole('button', { name: 'start' })).toBeOnTheScreen();\n});\n```\n\n> When using React context providers, like Redux Provider, you'll likely want to wrap rendered component with them. In such cases, it's convenient to create your own custom `render` method. [Follow this great guide on how to set this up]().\n\n### Options {#render-options}\n\nThe behavior of the `render` method can be customized by passing various options as a second argument of the `RenderOptions` type:\n\n#### `wrapper` option\n\n```ts\nwrapper?: React.ComponentType<any>,\n```\n\nThis option allows you to wrap the tested component, passed as the first option to the `render()` function, in an additional wrapper component. This is useful for creating reusable custom render functions for common React Context providers.\n\n#### `concurrentRoot` option {#concurrent-root}\n\nSet to `true` to enable concurrent rendering used in the React Native New Architecture. Otherwise `render` will default to legacy synchronous rendering.\n\n#### `createNodeMock` option\n\n```ts\ncreateNodeMock?: (element: React.Element) => unknown,\n```\n\nThis option allows you to pass `createNodeMock` option to `ReactTestRenderer.create()` method in order to allow for custom mock refs. You can learn more about this option from [React Test Renderer documentation]().\n\n#### `unstable_validateStringsRenderedWithinText` option\n\n```ts\nunstable_validateStringsRenderedWithinText?: boolean;\n```\n\n:::note\nThis options is experimental, in some cases it might not work as intended, and its behavior might change without observing [SemVer]() requirements for breaking changes.\n:::\n\nThis **experimental** option allows you to replicate React Native behavior of throwing `Invariant Violation: Text strings must be rendered within a <Text> component` error when you try to render `string` value under components different than `<Text>`, e.g., under `<View>`.\n\nReact Test Renderer does not enforce this check; hence, by default, React Native Testing Library also does not check this. That might result in runtime errors when running your code on a device, while the code works without errors in tests.\n\n### Result {#render-result}\n\nThe `render` function returns the same queries and utilities as the [`screen`]() object. We recommended using the `screen` object as more developer-friendly way.\n\nSee [this article]() from Kent C. Dodds for more details.\n","routePath":"/12.x/docs/api/render","lang":"en","toc":[{"id":"render-options","text":"Options","depth":3,"charIndex":685},{"id":"wrapper-option","text":"`wrapper` option","depth":4,"charIndex":848},{"id":"concurrent-root","text":"`concurrentRoot` option","depth":4,"charIndex":1160},{"id":"createnodemock-option","text":"`createNodeMock` option","depth":4,"charIndex":1363},{"id":"unstable_validatestringsrenderedwithintext-option","text":"`unstable_validateStringsRenderedWithinText` option","depth":4,"charIndex":1674},{"id":"render-result","text":"Result","depth":3,"charIndex":2496}],"frontmatter":{},"version":"12.x","description":"The render function is the entry point for writing React Native Testing Library tests. It deeply renders the given React element and returns helpers to query the output components' structure. When using React context providers, like Redux Provider, you'll likely want to wrap rendered component with them. In such cases, it's convenient to create your own custom render method. Follow this great guide on how to set this up. Options {#render-options} The behavior of the render method can be customized by passing various options as a second argument of the RenderOptions type: wrapper option This option allows you to wrap the tested component, passed as the first option to the render() function, in an additional wrapper component. This is useful for creating reusable custom render functions for common React Context providers. concurrentRoot option {#concurrent-root} Set to true to enable concurrent rendering used in the React Native New Architecture. Otherwise render will default to legacy synchronous rendering. createNodeMock option This option allows you to pass createNodeMock option to ReactTestRenderer.create() method in order to allow for custom mock refs. You can learn more about this option from React Test Renderer documentation. unstable_validateStringsRenderedWithinText option :::note\nThis options is experimental, in some cases it might not work as intended, and its behavior might change without observing SemVer requirements for breaking changes.\n::: This experimental option allows you to replicate React Native behavior of throwing Invariant Violation: Text strings must be rendered within a <Text> component error when you try to render string value under components different than <Text>, e.g., under <View>. React Test Renderer does not enforce this check; hence, by default, React Native Testing Library also does not check this. That might result in runtime errors when running your code on a device, while the code works without errors in tests. Result {#render-result} The render function returns the same queries and utilities as the screen object. We recommended using the screen object as more developer-friendly way. See this article from Kent C. Dodds for more details."},{"title":"`screen` object","content":"```ts\nlet screen: {\n  ...queries;\n  rerender(element: React.Element<unknown>): void;\n  unmount(): void;\n  debug(options?: DebugOptions): void\n  toJSON(): ReactTestRendererJSON | null;\n  root: ReactTestInstance;\n  UNSAFE_root: ReactTestInstance;\n};\n```\n\nThe `screen` object offers a recommended way to access queries and utilities for the currently rendered UI.\n\nThis object is assigned after the `render` call and cleared after each test by calling [`cleanup`](). If no `render` call has been made in a given test, then it holds a special object and throws a helpful error on each property and method access.\n\n### `...queries`\n\nThe most important feature of `screen` is providing a set of helpful queries that allow you to find certain elements in the view hierarchy.\n\nSee [Queries]() for a complete list.\n\n#### Example\n\n```jsx\n\n\nrender(<MyComponent />);\nconst buttonStart = screen.getByRole('button', { name: 'start' });\n```\n\n### `rerender`\n\n*Also available under `update` alias*\n\n```ts\nfunction rerender(element: React.Element<unknown>): void;\n```\n\nRe-render the in-memory tree with a new root element. This simulates a React update render at the root. If the new element has the same type (and `key`) as the previous element, the tree will be updated; otherwise, it will re-mount a new tree, in both cases triggering the appropriate lifecycle events.\n\n### `unmount`\n\n```ts\nfunction unmount(): void;\n```\n\nUnmount the in-memory tree, triggering the appropriate lifecycle events.\n\n:::note\nUsually you should not need to call `unmount` as it is done automatically if your test runner supports `afterEach` hook (like Jest, mocha, Jasmine).\n:::\n\n### `debug`\n\n```ts\nfunction debug(options?: { message?: string; mapProps?: MapPropsFunction }): void;\n```\n\nPretty prints deeply rendered component passed to `render`.\n\n#### `message` option {#debug-message-option}\n\nYou can provide a message that will be printed on top.\n\n```jsx\nrender(<Component />);\nscreen.debug({ message: 'optional message' });\n```\n\nlogs optional message and colored JSX:\n\n```jsx\noptional message\n\n<View\n  onPress={[Function bound fn]}\n>\n  <Text>Press me</Text>\n</View>\n```\n\n#### `mapProps` option {#debug-map-props-option}\n\n```ts\nfunction debug({ mapProps: (props) => ({}) });\n```\n\nYou can use the `mapProps` option to transform the props that will be printed :\n\n```jsx\nrender(<View style={{ backgroundColor: 'red' }} />);\nscreen.debug({ mapProps: ({ style, ...props }) => ({ props }) });\n```\n\nThis will log the rendered JSX without the `style` props.\n\nThe `children` prop cannot be filtered out so the following will print all rendered components with all props but `children` filtered out.\n\nThis option can be used to target specific props when debugging a query (for instance, keeping only the `children` prop when debugging a `getByText` query).\n\nYou can also transform prop values so that they are more readable (e.g., flatten styles).\n\n```ts\n\n\nscreen.debug({ mapProps : {({ style, ...props })} => ({ style : StyleSheet.flatten(style), ...props }) });\n```\n\nOr remove props that have little value when debugging tests, e.g. path prop for svgs\n\n```ts\nscreen.debug({ mapProps: ({ path, ...props }) => ({ ...props }) });\n```\n\n### `toJSON`\n\n```ts\nfunction toJSON(): ReactTestRendererJSON | null;\n```\n\nGet the rendered component JSON representation, e.g. for snapshot testing.\n\n### `root`\n\n```ts\nconst root: ReactTestInstance;\n```\n\nReturns the rendered root [host element]().\n\nThis API is primarily useful for component tests, as it allows you to access root host view without using `*ByTestId` queries or similar methods.\n\n### `UNSAFE_root`\n\n:::caution\nThis API typically will return a composite view, which goes against recommended testing practices. This API is primarily available for legacy test suites that rely on such testing.\n:::\n\n```ts\nconst UNSAFE_root: ReactTestInstance;\n```\n\nReturns the rendered [composite root element]().\n\n:::note\nThis API has been previously named `container` for compatibility with [React Testing Library](). However, despite the same name, the actual behavior has been significantly different; hence, we decided to change the name to `UNSAFE_root`.\n:::\n","routePath":"/12.x/docs/api/screen","lang":"en","toc":[{"id":"queries","text":"`...queries`","depth":3,"charIndex":610},{"id":"example","text":"Example","depth":4,"charIndex":807},{"id":"rerender","text":"`rerender`","depth":3,"charIndex":927},{"id":"unmount","text":"`unmount`","depth":3,"charIndex":1355},{"id":"debug","text":"`debug`","depth":3,"charIndex":1643},{"id":"debug-message-option","text":"`message` option","depth":4,"charIndex":1811},{"id":"debug-map-props-option","text":"`mapProps` option","depth":4,"charIndex":2138},{"id":"tojson","text":"`toJSON`","depth":3,"charIndex":3191},{"id":"root","text":"`root`","depth":3,"charIndex":3341},{"id":"unsafe_root","text":"`UNSAFE_root`","depth":3,"charIndex":3587}],"frontmatter":{},"version":"12.x","description":"The screen object offers a recommended way to access queries and utilities for the currently rendered UI. This object is assigned after the render call and cleared after each test by calling cleanup. If no render call has been made in a given test, then it holds a special object and throws a helpful error on each property and method access. ...queries The most important feature of screen is providing a set of helpful queries that allow you to find certain elements in the view hierarchy. See Queries for a complete list. Example rerender Also available under update alias Re-render the in-memory tree with a new root element. This simulates a React update render at the root. If the new element has the same type (and key) as the previous element, the tree will be updated; otherwise, it will re-mount a new tree, in both cases triggering the appropriate lifecycle events. unmount Unmount the in-memory tree, triggering the appropriate lifecycle events. :::note\nUsually you should not need to call unmount as it is done automatically if your test runner supports afterEach hook (like Jest, mocha, Jasmine).\n::: debug Pretty prints deeply rendered component passed to render. message option {#debug-message-option} You can provide a message that will be printed on top. logs optional message and colored JSX: mapProps option {#debug-map-props-option} You can use the mapProps option to transform the props that will be printed : This will log the rendered JSX without the style props. The children prop cannot be filtered out so the following will print all rendered components with all props but children filtered out. This option can be used to target specific props when debugging a query (for instance, keeping only the children prop when debugging a getByText query). You can also transform prop values so that they are more readable (e.g., flatten styles). Or remove props that have little value when debugging tests, e.g. path prop for svgs toJSON Get the rendered component JSON representation, e.g. for snapshot testing. root Returns the rendered root host element. This API is primarily useful for component tests, as it allows you to access root host view without using *ByTestId queries or similar methods. UNSAFE_root :::caution\nThis API typically will return a composite view, which goes against recommended testing practices. This API is primarily available for legacy test suites that rely on such testing.\n::: Returns the rendered composite root element. :::note\nThis API has been previously named container for compatibility with React Testing Library. However, despite the same name, the actual behavior has been significantly different; hence, we decided to change the name to UNSAFE_root.\n:::"},{"title":"Community resources","content":"## Recommended content\n\n- [The Testing Trophy and Testing Classifications]() by Kent C. Dodds (2021) - classic article explaining testing philosophy behind all Testing Library implementations.\n- [Common mistakes with React Testing Library]() by Kent C. Dodds (2020) - classic article explaining React Testing Library best practices, highly applicable to RNTL as well.\n- [React Native — UI Testing (Ultimate Guide)]() by Anisur Rahman - comprehensive guide to RNTL testing\n- [React Native Testing examples repo]() by Steve Galili - extensive repo with RN testing examples for RNTL and Maestro\n\n## Older, potentially outdated content\n\n- [Where and how to start testing 🧪 your react-native app ⚛️ and how to keep on testin’]() by Steve Galili (2020) - article referencing Steve's examples repo.\n- [Intro to React Native Testing Library & Jest Native]() by Alireza Ghamkhar (2020) - video tutorial on RNTL setup and testing.\n","routePath":"/12.x/docs/guides/community-resources","lang":"en","toc":[{"id":"recommended-content","text":"Recommended content","depth":2,"charIndex":0},{"id":"older-potentially-outdated-content","text":"Older, potentially outdated content","depth":2,"charIndex":593}],"frontmatter":{},"version":"12.x"},{"title":"FAQ","content":"## Can I test the native features of React Native apps?\n\nShort answer: no.\n\nReact Native Testing Library does not provide an entire React Native runtime since that would require running on a physical device\nor iOS simulator/Android emulator to provision the underlying OS and platform APIs.\n\nInstead of using React Native renderer, it simulates only the JavaScript part of its runtime\nusing [React Test Renderer]() while providing queries\nand event APIs ([User Event](), [Fire Event]()) that mimicking certain behaviors from the actual runtime.\n\nYou can learn more about our testing environment [here]().\n\nThis approach has specific benefits and shortfalls. On the positive side:\n\n- it allows testing most of the logic of regular React Native apps\n- it allows running tests on any OS supported by Jest or other test runners, e.g., on CI\n- it uses much less resources than full runtime simulation\n- you can use Jest fake timers\n\nOn the negative side:\n\n- you cannot test native features\n- it might not perfectly simulate certain JavaScript features, but we are working on it\n\nThe [User Event interactions]() solve some of the simulation issues, as they offer more realistic event handling than the basic [Fire Event API]().\n\n## Should I use/migrate to `screen` queries?\n\nThere is no need to migrate existing test code to use `screen`-bases queries. You can still use\nqueries and other functions returned by `render`. The `screen` object captures the latest `render` result.\n\nFor new code, you are encouraged to use `screen` as there are some good reasons for that, which are described in [this article]() by Kent C. Dodds.\n\n## Should I use/migrate to User Event interactions?\n\nWe encourage you to migrate existing tests to use the [User Event interactions](), which offer more realistic event handling than the basic [Fire Event API](). Hence, it will provide more confidence in the quality of your code.\n","routePath":"/12.x/docs/guides/faq","lang":"en","toc":[{"id":"can-i-test-the-native-features-of-react-native-apps","text":"Can I test the native features of React Native apps?","depth":2,"charIndex":0},{"id":"should-i-usemigrate-to-screen-queries","text":"Should I use/migrate to `screen` queries?","depth":2,"charIndex":1223},{"id":"should-i-usemigrate-to-user-event-interactions","text":"Should I use/migrate to User Event interactions?","depth":2,"charIndex":1622}],"frontmatter":{},"version":"12.x"},{"title":"How should I query?","content":"React Native Testing Library provides various query types, allowing great flexibility in finding views appropriate for your tests. At the same time, the number of queries might be confusing. This guide aims to help you pick the correct queries for your test scenarios.\n\n## Query parts\n\nEach query is composed of two parts: variant and predicate, which are separated by the `by` word in the middle of the query.\n\nConsider the following query:\n\n```ts\ngetByRole();\n```\n\nFor this query, `getBy*` is the query variant, and `*ByRole` is the predicate.\n\n## Query variant\n\nThe query variants describe the expected number (and timing) of matching elements, so they differ in their return type.\n\n| Variant           | Assertion                     | Return type                            | Is Async? |\n| ----------------- | ----------------------------- | -------------------------------------- | --------- |\n| [`getBy*`]()      | Exactly one matching element  | `ReactTestInstance`                    | No        |\n| [`getAllBy*`]()   | At least one matching element | `Array<ReactTestInstance>`             | No        |\n| [`queryBy*`]()    | Zero or one matching element  | <code>ReactTestInstance \\| null</code> | No        |\n| [`queryAllBy*`]() | No assertion                  | `Array<ReactTestInstance>`             | No        |\n| [`findBy*`]()     | Exactly one matching element  | `Promise<ReactTestInstance>`           | Yes       |\n| [`findAllBy*`]()  | At least one matching element | `Promise<Array<ReactTestInstance>>`    | Yes       |\n\nQueries work as implicit assertions on the number of matching elements and will throw an error when the assertion fails.\n\n### Idiomatic query variants\n\nIdiomatic query variants clarify test intent and the expected number of matching elements. They will also throw helpful errors if assertions fail to help diagnose the issues.\n\nHere are general guidelines for picking idiomatic query variants:\n\n1. Use `getBy*` in the most common case when you expect a **single matching element**. Use other queries only in more specific cases.\n2. Use `findBy*` when an element is not yet in the element tree, but you expect it to be there as a **result of some asynchronous action**.\n3. Use `getAllBy*` (and `findAllBy*` for async) if you expect **more than one matching element**, e.g. in a list.\n4. Use `queryBy*` only when element **should not exist** to use it together with e.g. [`not.toBeOnTheScreen()`]() matcher.\n\nAvoid using `queryAllBy*` in regular tests, as it provides no assertions on the number of matching elements. You may still find it useful when building reusable custom testing tools.\n\n## Query predicate\n\nThe query predicate describes how you decide whether to match the given element.\n\n| Predicate                | Supported elements | Inspected props                                                                             |\n| ------------------------ | ------------------ | ------------------------------------------------------------------------------------------- |\n| [`*ByRole`]()            | all host elements  | `role`, `accessibilityRole`,<br /> optional: accessible name, accessibility state and value |\n| [`*ByLabelText`]()       | all host elements  | `aria-label`, `aria-labelledby`,<br /> `accessibilityLabel`, `accessibilityLabelledBy`      |\n| [`*ByDisplayValue`]()    | `TextInput`        | `value`, `defaultValue`                                                                     |\n| [`*ByPlaceholderText`]() | `TextInput`        | `placeholder`                                                                               |\n| [`*ByText`]()            | `Text`             | `children` (text content)                                                                   |\n| [`*ByHintText`]()        | all host elements  | `accessibilityHint`                                                                         |\n| [`*ByTestId`]()          | all host elements  | `testID`                                                                                    |\n\n### Idiomatic query predicates\n\nChoosing the proper query predicate helps better express the test's intent and make the tests resemble how users interact with your code (components, screens, etc.) as much as possible following our [Guiding Principles](). Additionally, most predicates promote the usage of proper accessibility props, which add a semantic layer on top of an element tree composed primarily of [`View`]() elements.\n\nIt is recommended to use query predicates in the following order of priority:\n\n### 1. By Role query {#by-role-query}\n\nThe first and most versatile predicate is [`*ByRole`](), which starts with the semantic role of the element and can be further narrowed down with additional options. React Native has two role systems, the web/ARIA-compatible one based on [`role`]() prop and the traditional one based on [`accessibilityRole`]() prop, you can use either of these.\n\nIn most cases, you need to set accessibility roles explicitly (or your component library can set some of them for you). These roles allow assistive technologies (like screen readers) and testing code to understand your view hierarchy better.\n\nSome frequently used roles include:\n\n- `alert` - important text to be presented to the user, e.g., error message\n- `button`\n- `checkbox` & `switch` - on/off controls\n- `heading` (`header`) - header for content section, e.g., the title of navigation bar\n- `img` (`image`)\n- `link`\n- `menu` & `menuitem`\n- `progressbar`\n- `radiogroup` & `radio`\n- `searchbox` (`search`)\n- `slider` (`adjustable`)\n- `summary`\n- `tablist` & `tab`\n- `text` - static text that cannot change\n- `toolbar` - container for action buttons\n\n#### Name option {#by-role-query-name-option}\n\nFrequently, you will want to add the [`name`]() option, which will match both the element's role and its accessible name (= element's accessibility label or text content).\n\nHere are a couple of examples:\n\n- start button: `getByRole(\"button\", { name: \"Start\" })`\n- silent mode switch: `getByRole(\"switch\", { name: \"Silent Mode\" })`\n- screen header: `getByRole(\"header\", { name: \"Settings\" })`\n- undo menu item: `getByRole(\"menuitem\", { name: \"Undo\" })`\n- error messages: `getByRole(\"alert\", { name: /Not logged in/ })`\n\n### 2. Text input queries {#text-input-queries}\n\nQuerying [`TextInput`]() elements presents a unique challenge as there is no separate role for `TextInput` elements. There is a `searchbox`/`search` role, which can be assigned to `TextInput`, but it should be only used in the context of search inputs, leaving other text inputs without a role to query with.\n\nTherefore, you can use the following queries to find relevant text inputs:\n\n1. [`*ByLabelText`]() - will match the accessibility label of the element. This query will match any host elements, including `TextInput` elements.\n2. [`*ByPlaceholderText`]() - will match the placeholder of `TextInput` element. This query will match only `TextInput` elements.\n3. [`*ByDisplayValue`]() - will the current (or default) value of `TextInput` element. This query will match only `TextInput` elements.\n\n### 3. Other accessible queries {#other-accessible-queries}\n\nThese queries reflect the apps' user experience, both visual and through assistive technologies (e.g. screen reader).\n\nThese queries include:\n\n- [`*ByText`]() - will match the text content of the element. This query will match only `Text` elements.\n- [`*ByLabelText`]() - will match the accessibility label of the element.\n- [`*ByHintText`]() - will match the accessibility hint of the element.\n\n### 4. Test ID query {#test-id-query}\n\nAs a final predicate, you can use the `testID` prop to find relevant views. Using the [`*ByTestId`]() predicate offers the most flexibility, but at the same time, it does not represent the user experience, as users are not aware of test IDs.\n\nNote that using test IDs is a widespread technique in end-to-end testing due to various issues with querying views through other means **in its specific context**. Nevertheless, we still encourage you to use recommended RNTL queries as it will make your integration and component test more reliable and resilient.\n","routePath":"/12.x/docs/guides/how-to-query","lang":"en","toc":[{"id":"query-parts","text":"Query parts","depth":2,"charIndex":270},{"id":"query-variant","text":"Query variant","depth":2,"charIndex":547},{"id":"idiomatic-query-variants","text":"Idiomatic query variants","depth":3,"charIndex":1665},{"id":"query-predicate","text":"Query predicate","depth":2,"charIndex":2634},{"id":"idiomatic-query-predicates","text":"Idiomatic query predicates","depth":3,"charIndex":4033},{"id":"by-role-query","text":"1. By Role query","depth":3,"charIndex":4543},{"id":"by-role-query-name-option","text":"Name option","depth":4,"charIndex":5684},{"id":"text-input-queries","text":"2. Text input queries","depth":3,"charIndex":6250},{"id":"other-accessible-queries","text":"3. Other accessible queries","depth":3,"charIndex":7100},{"id":"test-id-query","text":"4. Test ID query","depth":3,"charIndex":7557}],"frontmatter":{},"version":"12.x","description":"React Native Testing Library provides various query types, allowing great flexibility in finding views appropriate for your tests. At the same time, the number of queries might be confusing. This guide aims to help you pick the correct queries for your test scenarios."},{"title":"Troubleshooting","content":"This guide describes common issues found by users when integrating React Native Test Library to their projects:\n\n## Matching React Native, React & React Test Renderer versions\n\nCheck that you have matching versions of core dependencies:\n\n- React Native\n- React\n- React Test Renderer\n\nReact Native uses different versioning scheme from React, you can use [React Native Upgrade Helper]() to find the correct matching between React Native & React versions. In case you use Expo, run `npx expo install --fix` in your project to validate and install compatible versions of these dependencies.\n\nReact Test Renderer usually has same major & minor version as React, as they are closely related and React Test Renderer is part of [React monorepo]().\n\nRelated issues: [#1061](), [#938](), [#920]()\n\nErrors that might indicate that you are facing this issue:\n\n- `TypeError: Cannot read property 'current' of undefined` when calling `render()`\n- `TypeError: Cannot read property 'isBatchingLegacy' of undefined` when calling `render()`\n\n## Example repository\n\nWe maintain an [example repository]() that showcases a modern React Native Testing Library setup with TypeScript, etc.\n\nIn case something does not work in your setup you can refer to this repository for recommended configuration.\n\n## Undefined component error\n\n> Warning: React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined.\n\nThis frequently happens when you mock a complex module incorrectly, e.g.:\n\n```ts\njest.mock('@react-navigation/native', () => {\n  return {\n    useNavigation: jest.fn(),\n  };\n});\n```\n\nThe above mock will mock `useNavigation` hook as intended, but at the same time all other exports from `@react-navigation/native` package are now `undefined`. If you want to use `NavigationContainer` component from the same package it will be `undefined` and result in the error above.\n\nIn order to mock only a part of given package you should re-export all other exports using `jest.requireActual` helper:\n\n```ts\njest.mock('@react-navigation/native', () => {\n  return {\n    ...jest.requireActual('@react-navigation/native'),\n    useNavigation: jest.fn(),\n  };\n});\n```\n\nThat way the mock will re-export all of the `@react-navigation/native` members and overwrite only the `useNavigation` hook.\n\nAlternatively, you can use `jest.spyOn` to mock package exports selectively.\n\n### Mocking React Native\n\nIn case of mocking `react-native` package you should not mock the whole package at once, as this approach has issues with `jest.requireActual` call. In this case it is recommended to mock particular library paths inside the package, e.g.:\n\n```ts title=jest-setup.ts\njest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');\n```\n\n## Act warnings\n\nWhen writing tests you may encounter warnings connected with `act()` function. There are two kinds of these warnings:\n\n- sync `act()` warning - `Warning: An update to Component inside a test was not wrapped in act(...)`\n- async `act()` warning - `Warning: You called act(async () => ...) without await`\n\nYou can read more about `act()` function in our [understanding `act` function guide]().\n\nNormally, you should not encounter sync `act()` warnings, but if that happens this probably indicate an issue with your test and should be investigated.\n\nIn case of async `act()` function this might happen more or less randomly, especially if your components contain async logic. So far this warning does not seem to affect test correctness.\n","routePath":"/12.x/docs/guides/troubleshooting","lang":"en","toc":[{"id":"matching-react-native-react--react-test-renderer-versions","text":"Matching React Native, React & React Test Renderer versions","depth":2,"charIndex":113},{"id":"example-repository","text":"Example repository","depth":2,"charIndex":1025},{"id":"undefined-component-error","text":"Undefined component error","depth":2,"charIndex":1279},{"id":"mocking-react-native","text":"Mocking React Native","depth":3,"charIndex":2417},{"id":"act-warnings","text":"Act warnings","depth":2,"charIndex":2783}],"frontmatter":{},"version":"12.x","description":"This guide describes common issues found by users when integrating React Native Test Library to their projects:"},{"title":"Migration to built-in Jest matchers","content":"This guide describes the steps necessary to migrate from [legacy Jest Native matchers v5]() to [built-in Jest matchers]().\n\n## General notes\n\nAll of the built-in Jest matchers provided by the React Native Testing Library support only host elements. This should not be an issue, as all RNTL v12 queries already return only host elements. When this guide states that a given matcher should work the same it assumes behavior only host elements. If you need to assert the status of composite elements use Jest Native matchers in [legacy mode]().\n\n## Usage\n\nYou can use the built-in matchers by adding the following line to your `jest-setup.ts` file (configured using [`setupFilesAfterEnv`]()):\n\n```ts title=jest-setup.ts\nimport '@testing-library/react-native/extend-expect';\n```\n\n### Gradual migration\n\nYou can use the built-in matchers alongside legacy Jest Native matchers by changing their import in your `jest-setup.ts` file:\n\n```ts\n// Replace this:\n// import '@testing-library/jest-native/extend-expect';\n\n// With this:\nimport '@testing-library/react-native/extend-expect';\nimport '@testing-library/jest-native/legacy-extend-expect';\n```\n\nIn this case legacy matchers will be available using the `legacy_` prefix, e.g.:\n\n```ts\nexpect(element).legacy_toHaveAccessibilityState({ busy: true });\n```\n\n## Migration details\n\n### Matchers not requiring changes\n\nThe following matchers should work the same:\n\n- [`toBeEmptyElement()`]()\n- [`toBeEnabled()` / `toBeDisabled()`]()\n- [`toBeOnTheScreen()`]()\n- [`toBeVisible()`]()\n- [`toContainElement()`]()\n- [`toHaveAccessibilityValue()`]()\n- [`toHaveDisplayValue()`]()\n- [`toHaveProp()`]()\n- [`toHaveStyle()`]()\n- [`toHaveTextContent()`]()\n\n### Replaced matchers\n\nThe `toHaveAccessibilityState()` matcher has been replaced by the following matchers:\n\n- enabled state: [`toBeEnabled()` / `toBeDisabled()`]()\n- checked state: [`toBeChecked()` / `toBePartiallyChecked()`]()\n- selected state: [`toBeSelected()`]()\n- expanded state: [`toBeExpanded()` / `toBeCollapsed()`]()\n- busy state: [`toBeBusy()`]()\n\nThe new matchers support both `accessibilityState` and `aria-*` props.\n\n### Added matchers\n\nNew [`toHaveAccessibleName()`]() has been added.\n\n### Noteworthy details\n\nYou should be aware of the following details:\n\n- [`toBeEnabled()` / `toBeDisabled()`]() matchers also check the disabled state for the element's ancestors and not only the element itself. This is the same as in legacy Jest Native matchers of the same name but differs from the removed `toHaveAccessibilityState()` matcher.\n- [`toBeChecked()`]() matcher supports only elements with a `checkbox`, `radio` and 'switch' role\n- [`toBePartiallyChecked()`]() matcher supports only elements with `checkbox` role\n","routePath":"/12.x/docs/migration/jest-matchers","lang":"en","toc":[{"id":"general-notes","text":"General notes","depth":2,"charIndex":124},{"id":"usage","text":"Usage","depth":2,"charIndex":543},{"id":"gradual-migration","text":"Gradual migration","depth":3,"charIndex":776},{"id":"migration-details","text":"Migration details","depth":2,"charIndex":1298},{"id":"matchers-not-requiring-changes","text":"Matchers not requiring changes","depth":3,"charIndex":1320},{"id":"replaced-matchers","text":"Replaced matchers","depth":3,"charIndex":1681},{"id":"added-matchers","text":"Added matchers","depth":3,"charIndex":2113},{"id":"noteworthy-details","text":"Noteworthy details","depth":3,"charIndex":2183}],"frontmatter":{},"version":"12.x","description":"This guide describes the steps necessary to migrate from legacy Jest Native matchers v5 to built-in Jest matchers."},{"title":"Migration to 11.x","content":"Migration to React Native Testing Library version 11 from version 9.x or 10.x should be a relatively easy task due small amount of breaking changes.\n\n## Breaking changes\n\n### Update to Jest 28 if you use fake timers\n\nIf you use fake timers in any of your tests you should update your Jest dependencies to version 28. This is due to the fact that [`jest.useFakeTimers()` config structure]() has changed.\n\n### Refactor legacy `waitForOptions` position\n\nIn version 9 we introducted query `options` parameters for each query type. This affected all `findBy` and `findAllBy` queries because their signatures changed e.g. from:\n\n```ts\nfunction findByText(text: TextMatch, waitForOptions?: WaitForOptions);\nfunction findAllByText(text: TextMatch, waitForOptions?: WaitForOptions);\n```\n\nto\n\n```ts\nfunction findByText(text: TextMatch, options?: TextMatchOptions, waitForOptions?: WaitForOptions);\nfunction findAllByText(\n  text: TextMatch,\n  options?: TextMatchOptions,\n  waitForOptions?: WaitForOptions\n);\n```\n\nIn order to facilitate transition, in version 9 and 10, we provided a temporary possibility to pass `WaitForOptions` like `timeout`, `interval`, etc inside `options` argument. From this release we require passing these as the proper third parameter.\n\nThis change is easy to implement:\n\n```ts\nfindByText(/Text/, { timeout: 1000 });\n```\n\nshould become\n\n```ts\nfindByText(/Text/, {}, { timeout: 1000 });\n```\n\n### Triggering non-touch events on targets with `pointerEvents=\"box-none\"` prop\n\nUp to version 10, RNTL disables all events for a target with `pointerEvents=\"box-none\"`. This behavior is counter to how React Native itself functions.\n\nFrom version 11, RNTL continues to disable `press` event for these targets but allows triggering other events, e.g. `layout`.\n\n## Full Changelog\n\n[https://github.com/callstack/react-native-testing-library/compare/v10.1.1...v11.0.0]()\n","routePath":"/12.x/docs/migration/previous/v11","lang":"en","toc":[{"id":"breaking-changes","text":"Breaking changes","depth":2,"charIndex":150},{"id":"update-to-jest-28-if-you-use-fake-timers","text":"Update to Jest 28 if you use fake timers","depth":3,"charIndex":171},{"id":"refactor-legacy-waitforoptions-position","text":"Refactor legacy `waitForOptions` position","depth":3,"charIndex":404},{"id":"triggering-non-touch-events-on-targets-with-pointereventsbox-none-prop","text":"Triggering non-touch events on targets with `pointerEvents=\"box-none\"` prop","depth":3,"charIndex":1408},{"id":"full-changelog","text":"Full Changelog","depth":2,"charIndex":1769}],"frontmatter":{},"version":"12.x","description":"Migration to React Native Testing Library version 11 from version 9.x or 10.x should be a relatively easy task due small amount of breaking changes."},{"title":"Migration to 2.x","content":"This guide describes steps necessary to migrate from React Native Testing Library `v1.x` to `v2.x`.\n\n## Dropping Node 8\n\nNode 8 reached its EOL more than 5 months ago, so it's about time to target the library to Node 10. If you used lower version, you'll have to upgrade to v10, but we recommend using the latest LTS version.\n\n## Auto Cleanup\n\n`cleanup()` function is now called automatically after every test if your testing framework supports `afterEach` hook (like Jest, Mocha, and Jasmine).\n\nYou should be able to remove all `afterEach(cleanup)` calls in your code.\n\nThis change might break your code, if you tests are not isolated, i.e. you call `render` outside `test` block. Generally, you should [keep your tests isolated](). But if you can't or don't want to do this right away you can prevent this behavior using any of the following ways:\n\n- by importing `'react-native-testing-library/pure'` instead of `'react-native-testing-library'`\n\n- by importing `'react-native-testing-library/dont-cleanup-after-each'` before importing `'react-native-testing-library'`. You can do it in a global way by using Jest's `setupFiles` like this:\n\n  ```json\n  {\n    \"setupFiles\": [\"react-native-testing-library/dont-cleanup-after-each\"];\n  }\n  ```\n\n- by setting `RNTL_SKIP_AUTO_CLEANUP` env variable to `true`. You can do this with `cross-evn` like this:\n\n  ```sh\n  cross-env RNTL_SKIP_AUTO_CLEANUP=true jest\n  ```\n\n## WaitFor API changes\n\nWe renamed `waitForElement` function to `waitFor` for consistency with React Testing Library. Additionally, the signature has slightly changed from:\n\n```jsx\nexport default function waitForElement<T>(\n  expectation: () => T,\n  timeout?: number,\n  interval?: number\n): Promise<T> {}\n```\n\nto:\n\n```jsx\nexport default function waitFor<T>(\n  expectation: () => T,\n  options: {\n    timeout?: number,\n    interval?: number,\n  }\n): Promise<T> {}\n```\n\nBoth changes should improve code readibility.\n\n`waitFor` calls (and hence also `findBy` queries) are now wrapped in `act` by default, so that you should no longer need to use `act` directly in your tests.\n\n:::tip\nYou can usually avoid `waitFor` by a proper use of `findBy` asynchronous queries. It will result in more streamlined testing experience.\n:::\n\n## Removed global `debug` function\n\nThe `debug()` method returned from `render()` function is all you need. We removed the global export to avoid confusion.\n\n## Removed global `shallow` function\n\nShallow rendering React component is usually not a good idea, so we decided to remove the API. But, if you find it useful or need to support legacy tests, feel free to use this implementation:\n\n```js\n\n\nexport function shallow(instance: ReactTestInstance | React.Element<any>) {\n  const renderer = new ShallowRenderer();\n  renderer.render(React.createElement(instance.type, instance.props));\n\n  return { output: renderer.getRenderOutput() };\n}\n```\n\n## Removed functions\n\nFollowing query functions have been removed after being deprecated for more than a year now:\n\n- `getByName`\n- `getAllByName`\n- `queryByName`\n- `queryAllByName`\n\nThe `*ByType` and `*ByProps` queries has been prefixed with `UNSAFE_`. These `UNSAFE_` functions are not planned for removal in future versions but their usage is discouraged. You can rename them using global search/replace in your project:\n\n- `getByType` -> `UNSAFE_getByType`\n- `getAllByType` -> `UNSAFE_getAllByType`\n- `queryByType` -> `UNSAFE_queryByType`\n- `queryAllByType` -> `UNSAFE_queryAllByType`\n- `getByProps` -> `UNSAFE_getByProps`\n- `getAllByProps` -> `UNSAFE_getAllByProps`\n- `queryByProps` -> `UNSAFE_queryByProps`\n- `queryAllByProps` -> `UNSAFE_queryAllByProps`\n\n## Some `ByTestId` queries behavior changes\n\nIn version `1.x` the `getByTestId` and `queryByTestId` queries could return non-native instances. This was a serious bug. Other query functions like `getAllByTestId`, `queryAllByTestId`, `findByTestId` and `findAllByTestId` didn't have this issue. These correctly returned only native components instances (e.g. `View`, `Text`, etc) that got the `testID`.\n\nIn v2 we fixed this inconsistency, which may result in failing tests, if you relied on this behavior. There are few ways to handle these failures:\n\n- pass the `testID` prop down so it can reach a native component, like `View` or `Text`\n- replace `testID` with proper `accessibilityHint` or `accessibilityLabel` if it benefits the user\n- use safe queries like `*ByText` or `*ByA11yHint`\n\n## Deprecated `flushMicrotasksQueue`\n\nWe have deprecated `flushMicrotasksQueue` and plan to remove it in the next major. We have better alternatives available for helping you write async tests – `findBy` async queries and `waitFor` helper.\n\nIf you can't or don't want to migrate your tests, don't worry. You can use the same implementation we have today:\n\n```js\nfunction flushMicrotasksQueue() {\n  return new Promise((resolve) => setImmediate(resolve));\n}\n```\n","routePath":"/12.x/docs/migration/previous/v2","lang":"en","toc":[{"id":"dropping-node-8","text":"Dropping Node 8","depth":2,"charIndex":101},{"id":"auto-cleanup","text":"Auto Cleanup","depth":2,"charIndex":327},{"id":"waitfor-api-changes","text":"WaitFor API changes","depth":2,"charIndex":1411},{"id":"removed-global-debug-function","text":"Removed global `debug` function","depth":2,"charIndex":2232},{"id":"removed-global-shallow-function","text":"Removed global `shallow` function","depth":2,"charIndex":2390},{"id":"removed-functions","text":"Removed functions","depth":2,"charIndex":2876},{"id":"some-bytestid-queries-behavior-changes","text":"Some `ByTestId` queries behavior changes","depth":2,"charIndex":3638},{"id":"deprecated-flushmicrotasksqueue","text":"Deprecated `flushMicrotasksQueue`","depth":2,"charIndex":4427}],"frontmatter":{},"version":"12.x","description":"This guide describes steps necessary to migrate from React Native Testing Library v1.x to v2.x."},{"title":"Migration to 7.x","content":":::info\n\nWe renamed the `react-native-testing-library` npm package to `@testing-library/react-native`, officially joining the \"Testing Library\" family 🎉.\n\n:::\n\nAs the version 7.0 involves merging two libraries together, there are two variants for migration guide, dependent on library you used previously:\n\n## Guide for `react-native-testing-library` users\n\nThis guide describes steps necessary to migrate from React Native Testing Library `v2.x` or `v6.0` to `v7.0`.\n\n### Renaming the library\n\n1. Install `@testing-library/react-native`.\n2. Uninstall `react-native-testing-library`.\n3. Rename all references of `react-native-testing-library` to `@testing-library/react-native`.\n\nYou may have noticed a strange v2 to v7 upgrade, skipping versions 3, 4, 5 and 6. This is because we renamed the `react-native-testing-library` npm package to `@testing-library/react-native`, officially joining the \"Testing Library\" family 🎉. We're merging existing two libraries into a single one. The [native-testing-library]() repository, which had v6, will soon be archived and using `@testing-library/react-native` below v7, sourced from mentioned repository, is deprecated.\n\nFor branding purposes we keep the \"React Native Testing Library\" name, similar to \"React Testing Library\". Only the npm published package is changing. The code repository also stays the same under Callstack governance.\n\n### New aliases\n\nTo improve compatibility with React Testing Library, and ease the migration for `@testing-library/react-native` users using version below v7, we've introduced new aliases to our accessibility queries:\n\n- `ByLabelText` aliasing `ByA11yLabel` queries\n- `ByHintText` aliasing `ByA11yHint` queries\n- `ByRole` aliasing `ByA11yRole` queries\n\nWe like the new names and consider removing the aliases in future releases.\n\n### Renaming `ByPlaceholder` queries\n\nTo improve compatibility with React Testing Library, and to ease the migration for `@testing-library/react-native` users using version below v7, we've renamed following queries:\n\n- `ByPlaceholder` -> `ByPlaceholderText`\n\nPlease replace all occurrences of these queries in your codebase.\n\n### `fireEvent` support for disabled components\n\nTo improve compatibility with the real React Native environment `fireEvent` now performs checks whether the component is \"disabled\" before firing an event on it. It uses the Responder system to establish should the event fire, which resembles the actual React Native runtime closer than we used to.\n\nIf your code contained any workarounds for preventing events firing on disabled events, you should now be able to remove them.\n\n## Guide for `@testing-library/react-native` users\n\nThis guide describes steps necessary to migrate from `@testing-library/react-native` from `v6.0` to `v7.0`. Although the name stays the same, this is a different library, sourced at [Callstack GitHub repository](). We made sure the upgrade path is as easy for you as possible.\n\n### Renaming \"wait\" helpers\n\nThe `wait` and `waitForElement` helpers are replaced by `waitFor`. Please rename all occurrences of these in your codebase.\n\n### Changes to `ByTestId` queries\n\nThe `ByTestId` queries don't accept RegExps. Please use strings instead. We're happy to accept PRs adding this functionality :).\n\n### No `ByTitle` queries\n\nOur library doesn't implement `ByTitle` queries, which are targetting components with `title` prop, specifically `Button` and `RefreshControl`. If your tests only use `ByTitle` to target `Button` components, you can replace them with `ByText` queries, since React Native renders `Text` under the hood.\n\nIf you need to query `RefreshControl` component and can't figure out other way around it, you can use e.g. `UNSAFE_getByProps({title})` query.\n\n### No custom Jest configuration\n\nUse the official React Native preset for Jest:\n\n```diff\n{\n  \"jest\": {\n-    \"preset\": \"@testing-library/react-native\"\n+    \"preset\": \"react-native\"\n  }\n}\n```\n\nWe're told this also speeds up your tests startup on cold cache. Using official preset has another benefit – the library is compatible with any version of React Native without introducing breaking changes.\n\n### Cleanup is included by default\n\nCleaning up (unmounting) components after each test is included by default in the same manner as in React Testing Library. Please remove this setup file from Jest config:\n\n```diff\n{\n  \"jest\": {\n-    \"setupFilesAfterEnv\": [\"@testing-library/react-native/cleanup-after-each\"]\n  }\n}\n```\n\nYou can opt-out of this behavior by running tests with `RNTL_SKIP_AUTO_CLEANUP=true` flag or importing from `@testing-library/react-native/pure`. We encourage you to keep the default though.\n\n### No [NativeTestInstance]() abstraction\n\nWe don't provide any abstraction over `ReactTestInstance` returned by queries, but allow to use it directly to access queried component's `props` or `type` for that example.\n\n### No `container` nor `baseElement` returned from `render`\n\nThere's no `container` returned from the `render` function. If you must, use `react-test-renderer` directly, although we advise against doing so. We also don't implement `baseElement` because of that, since there's no `document.documentElement` nor `container`.\n\n### Firing events changes\n\nThere are slight differences in how `fireEvent` works in both libraries:\n\n1. Our library doesn't perform validation checks for events fired upon tested components.\n2. Signature is different:\n   ```diff\n   -fireEvent[eventName](node: FiberRoot, eventProperties: NativeTestEvent)\n   +fireEvent(element: ReactTestInstance, eventName: string, ...data: Array<any>)\n   ```\n3. There is no `NativeTestEvent` - second and rest arguments are used instead.\n4. There are only 3 short-hand events: [`fireEvent.press`](), [`fireEvent.changeText`]() and [`fireEvent.scroll`](). For all other or custom events you can use the base signature.\n","routePath":"/12.x/docs/migration/previous/v7","lang":"en","toc":[{"id":"guide-for-react-native-testing-library-users","text":"Guide for `react-native-testing-library` users","depth":2,"charIndex":308},{"id":"renaming-the-library","text":"Renaming the library","depth":3,"charIndex":470},{"id":"new-aliases","text":"New aliases","depth":3,"charIndex":1383},{"id":"renaming-byplaceholder-queries","text":"Renaming `ByPlaceholder` queries","depth":3,"charIndex":1813},{"id":"fireevent-support-for-disabled-components","text":"`fireEvent` support for disabled components","depth":3,"charIndex":2139},{"id":"guide-for-testing-libraryreact-native-users","text":"Guide for `@testing-library/react-native` users","depth":2,"charIndex":2616},{"id":"renaming-wait-helpers","text":"Renaming \"wait\" helpers","depth":3,"charIndex":2946},{"id":"changes-to-bytestid-queries","text":"Changes to `ByTestId` queries","depth":3,"charIndex":3100},{"id":"no-bytitle-queries","text":"No `ByTitle` queries","depth":3,"charIndex":3265},{"id":"no-custom-jest-configuration","text":"No custom Jest configuration","depth":3,"charIndex":3738},{"id":"cleanup-is-included-by-default","text":"Cleanup is included by default","depth":3,"charIndex":4137},{"id":"no-nativetestinstance-abstraction","text":"No NativeTestInstance abstraction","depth":3,"charIndex":-1},{"id":"no-container-nor-baseelement-returned-from-render","text":"No `container` nor `baseElement` returned from `render`","depth":3,"charIndex":4868},{"id":"firing-events-changes","text":"Firing events changes","depth":3,"charIndex":5192}],"frontmatter":{},"version":"12.x","description":":::info We renamed the react-native-testing-library npm package to @testing-library/react-native, officially joining the \"Testing Library\" family 🎉. ::: As the version 7.0 involves merging two libraries together, there are two variants for migration guide, dependent on library you used previously:"},{"title":"Migration to 9.x","content":"Version 7.0 brought React Native Testing Library into the `@testing-library` family. Since it has been implemented independently from its web counterpart – the React Testing Library – there are some differences in the API and behavior. Version 9.0 solves several of these problems.\n\n## Support for text match options a.k.a string precision API\n\nThis is a backward compatible change.\n\nWhen querying text, it is now possible to pass a [`TextMatch`]() to most text based queries, which lets you configure how `@testing-library/react-native` should match your text. For instance, passing `exact: false` will allow matching substrings and will ignore case:\n\n```jsx\nconst { getByText } = render(<Text>Hello World</Text>);\n\ngetByText('Hello World'); // Matches\ngetByText('Hello'); // Doesn't match\ngetByText('hello', { exact: false }); // ignore case-sensitivity and does partial matching\n```\n\nPlease note that the `findBy*` queries used to take a `waitForOptions` parameter as a second argument, which has now been moved to the third argument:\n\n```diff\n-findByText('Hello world', { timeout: 3000 }); // old findBy* API\n+findByText('Hello world', {}, { timeout: 3000 }); // new findBy* API\n```\n\nFor backward compatibility RNTL v9 can still read `waitForOptions` from the second argument but will print a deprecation warning.\n\n## Reverted matching text across several nodes\n\n:::caution\nThis is a breaking change.\n:::\n\nIn v1.14 we've introduced a feature allowing to match text when it's spread across several nodes:\n\n```tsx\nconst { getByText } = render(\n  <Text>\n    Hello <Text>world</Text>\n  </Text>\n);\ngetByText('Hello world'); // matches\n```\n\nHowever this behavior was different than the web one, and wouldn't always be straightforward to reason about. For instance it could match text nodes far from each other on the screen. It also prevented us from implementing the string precision API. From v9, this type of match will not work.\n\nA work around is to use `within`:\n\n```tsx\n\n\n\nconst { getByText } = render(<Text>Hello <Text>world</Text</Text>)\n\nwithin(getByText('Hello', {exact: false})).getByText('world')\n```\n\n## Future plans\n\nThis release changes a lot of internal logic in the library, paving the way for more improvements to bring us closer to our web counterpart, with a possibly better story for accessibility queries.\n\nWe're also [migrating the codebase to TypeScript](). Please let us know if you're interested in helping us with this effort.\n\nStay safe!\n","routePath":"/12.x/docs/migration/previous/v9","lang":"en","toc":[{"id":"support-for-text-match-options-aka-string-precision-api","text":"Support for text match options a.k.a string precision API","depth":2,"charIndex":283},{"id":"reverted-matching-text-across-several-nodes","text":"Reverted matching text across several nodes","depth":2,"charIndex":1319},{"id":"future-plans","text":"Future plans","depth":2,"charIndex":2112}],"frontmatter":{},"version":"12.x","description":"Version 7.0 brought React Native Testing Library into the @testing-library family. Since it has been implemented independently from its web counterpart – the React Testing Library – there are some differences in the API and behavior. Version 9.0 solves several of these problems."},{"title":"Migration to 12.x","content":":::info\n\nIf you are already using legacy `@testing-library/jest-native` Jest Matchers, we have a [migration guide]() for moving to the built-in matchers.\n\n:::\n\nReact Native Testing Library 12 introduces a handful of breaking changes compared to 11.x versions. We believe they were necessary to improve the experience using the library and help the users [fall into the pit of success]() when writing meaningful tests. You will find migration instructions for each and every change described below.\n\n## Breaking changes\n\n### 1. All queries exclude elements hidden from accessibility by default\n\nElements that are hidden from accessiblity, e.g. elements on non-active screen when using React Navigation, now will not be matched by default by all queries. This is the effect of switching the default value for global config option `defaultIncludeHiddenElements`(api#defaultincludehiddenelements-option) to `false`.\n\nPrevious behaviour of matching hidden elements can be enabled on query level using [includeHiddenElements]() query options or globally using `defaultIncludeHiddenElements`(api#defaultincludehiddenelements-option) configuration option.\n\n### 2. `*ByRole` queries now return only accessibility elements\n\n`*ByRole` queries now return only accessibility elements, either explicitly marked with `accessible` prop or implicit ones where this status is derived from component type itself (e.g `Text`, `TextInput`, `Switch`, but not `View`).\n\nYou may need to adjust relevant components under test to make sure they pass `isAccessibilityElement` check.\n\n#### Examples\n\nLet's assume we are using `getByRole(\"button\")` query.\n\nFollowing elements will match:\n\n```tsx\n// Explicit \"accessible\" prop for View\n<View accessible accessibilityRole=\"button\" />\n\n// No need to \"accessible\" prop for Text, as it is implicitly accessible element.\n<Text accessibilityRole=\"button\">Button</Text>\n```\n\nWhile following elements will not match:\n\n```tsx\n// Missing \"accessible\" prop for View\n<View accessibilityRole=\"button\" />\n\n// Explicit \"accessible={false}\" prop for View\n<View accessible={false} accessibilityRole=\"button\" />\n\n// Explicit \"accessible={false}\" for Text, which is implicitly accessible element\n<Text accessible={false} accessibilityRole=\"button\">Button</Text>\n```\n\n### 3. `*ByText`, `*ByDisplayValue`, `*ByPlaceholderText` queries now return host elements\n\n`*ByText`, `*ByDisplayValue`, `*ByPlaceholderText` queries now return [host elements](), which is consistent with other queries.\n\nWhile potentially breaking, this should not cause issues in tests if you are using recommended queries and Jest Matchers from Jest Native package.\n\nProblematic cases may include: directly checking some prop values (without using Jest Native matchers), referencing other nodes using `parent` or `children` props, examining `type` property of `ReactTestInstance`, etc.\n\n### 4. `container` API has been renamed to `UNSAFE_root`.\n\nHistorically `container` was supposed to mimic the [RTL's container](). However it turned out not so relevant in RNTL's environment, where we actually used it to return React Test Renderer's root instance.\n\nRNTL v12 introduces `root` API as an alternative that returns a root **host** element. The difference between `root` and `UNSAFE_root` properties is that that `root` will always represents a host element, while `UNSAFE_root` will typically represent a composite element.\n\nIf you use `toBeOnTheScreen` matcher from [@testing-library/jest-native]() your tests will fail because it uses the `container` api. To fix this, update `@testing-library/jest-native` to version 5.4.2.\n\n## Full Changelog\n\n[https://github.com/callstack/react-native-testing-library/compare/v11.5.2...v12.0.0]()\n","routePath":"/12.x/docs/migration/v12","lang":"en","toc":[{"id":"breaking-changes","text":"Breaking changes","depth":2,"charIndex":499},{"id":"1-all-queries-exclude-elements-hidden-from-accessibility-by-default","text":"1. All queries exclude elements hidden from accessibility by default","depth":3,"charIndex":520},{"id":"2-byrole-queries-now-return-only-accessibility-elements","text":"2. `*ByRole` queries now return only accessibility elements","depth":3,"charIndex":1149},{"id":"examples","text":"Examples","depth":4,"charIndex":1557},{"id":"3-bytext-bydisplayvalue-byplaceholdertext-queries-now-return-host-elements","text":"3. `*ByText`, `*ByDisplayValue`, `*ByPlaceholderText` queries now return host elements","depth":3,"charIndex":2268},{"id":"4-container-api-has-been-renamed-to-unsafe_root","text":"4. `container` API has been renamed to `UNSAFE_root`.","depth":3,"charIndex":2858},{"id":"full-changelog","text":"Full Changelog","depth":2,"charIndex":3599}],"frontmatter":{},"version":"12.x","description":":::info If you are already using legacy @testing-library/jest-native Jest Matchers, we have a migration guide for moving to the built-in matchers. ::: React Native Testing Library 12 introduces a handful of breaking changes compared to 11.x versions. We believe they were necessary to improve the experience using the library and help the users fall into the pit of success when writing meaningful tests. You will find migration instructions for each and every change described below."},{"title":"Introduction","content":"## The problem\n\nYou want to write maintainable tests for your React Native components. As a part of this goal, you want your tests to avoid including implementation details of your components and focus on making your tests give you the confidence they are intended. As part of this, you want your tests to be maintainable in the long run so refactors of your components (changes to implementation but not functionality) don't break your tests and slow you and your team down.\n\n## This solution\n\nThe React Native Testing Library (RNTL) is a lightweight solution for testing React Native components. It provides light utility functions on top of React Test Renderer, in a way that encourages better testing practices. Its primary guiding principle is:\n\n> The more your tests resemble how your software is used, the more confidence they can give you.\n\nThis project is inspired by [React Testing Library](). It is tested to work with Jest, but it should work with other test runners as well.\n\n## Example\n\n```jsx\n\n\n\ntest('form submits two answers', async () => {\n  const questions = ['q1', 'q2'];\n  const onSubmit = jest.fn();\n\n  const user = userEvent.setup();\n  render(<QuestionsBoard questions={questions} onSubmit={onSubmit} />);\n\n  const answerInputs = screen.getAllByLabelText('answer input');\n  await user.type(answerInputs[0], 'a1');\n  await user.type(answerInputs[1], 'a2');\n  await user.press(screen.getByRole('button', { name: 'Submit' }));\n\n  expect(onSubmit).toHaveBeenCalledWith({\n    1: { q: 'q1', a: 'a1' },\n    2: { q: 'q2', a: 'a2' },\n  });\n});\n```\n\nYou can find the source of the `QuestionsBoard` component and this example [here]().\n","routePath":"/12.x/docs/start/intro","lang":"en","toc":[{"id":"the-problem","text":"The problem","depth":2,"charIndex":0},{"id":"this-solution","text":"This solution","depth":2,"charIndex":477},{"id":"example","text":"Example","depth":2,"charIndex":989}],"frontmatter":{},"version":"12.x"},{"title":"Quick Start","content":"## Installation\n\nOpen a Terminal in your project's folder and run:\n\n\\<PackageManagerTabs\ncommand={{\nyarn: 'yarn add -D @testing-library/react-native',\nnpm: 'npm install -D @testing-library/react-native',\n}}\n/>\n\nThis library has a peer dependency for `react-test-renderer` package. Make sure that your `react-test-renderer` version matches exactly your `react` version.\n\n### Jest matchers\n\nTo set up React Native-specific Jest matchers, add the following line to your `jest-setup.ts` file (configured using [`setupFilesAfterEnv`]()):\n\n```ts title=jest-setup.ts\nimport '@testing-library/react-native/extend-expect';\n```\n\n### ESLint plugin\n\nWe recommend setting up [`eslint-plugin-testing-library`]() package to help you avoid common Testing Library mistakes and bad practices.\n\nInstall the plugin (assuming you already have `eslint` installed & configured):\n\n\\<PackageManagerTabs\ncommand={{\nyarn: 'yarn add -D eslint-plugin-testing-library',\nnpm: 'npm install -D eslint-plugin-testing-library',\n}}\n/>\n\nThen, add relevant entry to your ESLint config (e.g., `.eslintrc.js`). We recommend extending the `react` plugin:\n\n```js title=.eslintrc.js\nmodule.exports = {\n  overrides: [\n    {\n      // Test files only\n      files: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[jt]s?(x)'],\n      extends: ['plugin:testing-library/react'],\n    },\n  ],\n};\n```\n","routePath":"/12.x/docs/start/quick-start","lang":"en","toc":[{"id":"installation","text":"Installation","depth":2,"charIndex":0},{"id":"jest-matchers","text":"Jest matchers","depth":3,"charIndex":370},{"id":"eslint-plugin","text":"ESLint plugin","depth":3,"charIndex":619}],"frontmatter":{},"version":"12.x"}]