[{"id":67,"title":"Network Requests","content":"#\n\n\nIntroduction#\n\nMocking network requests is an essential part of testing React Native\napplications. By mocking network requests, you can control the data that is\nreturned from the server and test how your application behaves in different\nscenarios, such as when the request is successful or when it fails.\n\nIn this guide, we will show you how to mock network requests and guard your test\nsuits from unwanted and unmocked/unhandled network requests\n\nINFO\n\nTo simulate a real-world scenario, we will use the Random User Generator API\nthat provides random user data.\n\n\nPhonebook Example#\n\nLet's assume we have a simple phonebook application that uses fetch for fetching\nData from a server. In our case, we have a list of contacts and favorites that\nwe want to display in our application.\n\nThis is how the root of the application looks like:\n\n\n\nWe fetch the contacts from the server using the getAllFavorites function that\nutilizes fetch.\n\n\n\nWe have similar function for fetching the favorites, but this time limiting the\nresults to 10.\n\n\n\nOur FavoritesList component is a simple component that displays the list of\nfavorite contacts and their avatars horizontally.\n\n\n\nOur ContactsList component is similar to the FavoritesList component, but it\ndisplays the list of all contacts vertically.\n\n\n\n\nStart testing with a simple test#\n\nIn our initial test we would like to test if the PhoneBook component renders the\nFavoritesList and ContactsList components correctly. We will need to mock the\nnetwork requests and their corresponding responses to ensure that the component\nbehaves as expected. To mock the network requests we will use MSW (Mock Service\nWorker).\n\nNOTE\n\nWe recommend using the Mock Service Worker (MSW) library to declaratively mock\nAPI communication in your tests instead of stubbing fetch, or relying on\nthird-party adapters.\n\nINFO\n\nYou can install MSW by running npm install msw --save-dev or yarn add msw --dev.\nMore info regarding installation can be found in MSW's getting started guide.\n\nPlease make sure you're also aware of MSW's setup guide. Please be minded that\nthe MSW's setup guide is potentially incomplete and might contain\ndiscrepancies/missing pieces.\n\n\n\nINFO\n\nMore info regarding how to describe the network using request handlers,\nintercepting a request and handling its response can be found in the MSW's\ndocumentation.\n\n\nTesting error handling#\n\nAs we are dealing with network requests, and things can go wrong, we should also\ncover the case when the API request fails. In this case, we would like to test\nhow our application behaves when the API request fails.\n\nINFO\n\nThe nature of the network can be highly dynamic, which makes it challenging to\ndescribe it completely in a fixed list of request handlers..use() API. More info\ncan be found in MSW's Network behavior overrides documentation\n\nMSW provides us the means to override any particular network behavior using the\ndesignated\n\n\n\n\nGlobal guarding against unwanted API requests#\n\nAs mistakes may happen, we might forget to mock a network request in one of our\ntests in the future. To prevent us from happening, and alert when a certain\nnetwork request is left unhandled, you may choose to move MSW's server\nmanagement from PhoneBook.test.tsx to Jest's setup file via setupFilesAfterEnv.\n\n\n\nThis setup will ensure you have the MSW server running before any test suite\nstarts and stops it after all tests are done. Which will result in a warning in\nthe console if you forget to mock an API request in your test suite.\n\n\n\n\nConclusion#\n\nTesting a component that makes network requests in combination with MSW takes\nsome initial preparation to configure and describe the overridden networks. We\ncan achieve that by using MSW's request handlers and intercepting APIs.\n\nOnce up and running we gain full grip over the network requests, their\nresponses, statuses. Doing so is crucial to be able to test how our application\nbehaves in different scenarios, such as when the request is successful or when\nit fails.\n\nWhen global configuration is in place, MSW's will also warn us when an unhandled\nnetwork requests has occurred throughout a test suite.\n\n\nFurther Reading and Alternatives#\n\nExplore more advanced scenarios for mocking network requests with MSW:\n\n * MSW's Basics - Intercepting requests and/or Mocking responses\n * MSW's Network behavior - how to describe REST and/or GraphQL APIs","routePath":"/react-native-testing-library/14.x/cookbook/advanced/network-requests","lang":"","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":3},{"text":"Phonebook Example","id":"phonebook-example","depth":2,"charIndex":568},{"text":"Start testing with a simple test","id":"start-testing-with-a-simple-test","depth":2,"charIndex":1294},{"text":"Testing error handling","id":"testing-error-handling","depth":2,"charIndex":2353},{"text":"Global guarding against unwanted API requests","id":"global-guarding-against-unwanted-api-requests","depth":2,"charIndex":2920},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":3508},{"text":"Further Reading and Alternatives","id":"further-reading-and-alternatives","depth":2,"charIndex":4130}],"domain":"","frontmatter":{},"version":"14.x"},{"id":68,"title":"Async tests","content":"#\n\n\nSummary#\n\nTypically, you would write synchronous tests, as they are simple and get the\nwork done. However, there are cases when using asynchronous (async) tests might\nbe necessary or beneficial. The two most common cases are:\n\n 1. Testing Code with asynchronous operations: When your code relies on\n    asynchronous operations, such as network calls or database queries, async\n    tests are essential. Even though you should mock these network calls, the\n    mock should act similarly to the actual behavior and hence by async.\n 2. UserEvent API: Using the User Event API in your tests creates more realistic\n    event handling. These interactions introduce delays (even though these are\n    typically event-loop ticks with 0 ms delays), requiring async tests to\n    handle the timing correctly.\n\nUsing async tests when needed ensures your tests are reliable\nand simulate real-world conditions accurately.\n\n\nExample#\n\nConsider a basic asynchronous test for a user signing in with correct\ncredentials:\n\n\n\n\nAsync utilities#\n\nThere are several asynchronous utilities you might use in your tests.\n\n\nfindBy* queries#\n\nThe most common are the findBy* queries. These are useful when waiting for a\nmatching element to appear. They can be understood as a getBy* queries used in\nconjunction with a waitFor function.\n\nThey accept the same predicates as getBy* queries like findByRole, findByTest,\netc. They also have a multiple elements variant called findAllBy*.\n\n\n\nEach query has a default timeout value of 1000 ms and a default interval of 50\nms. Custom timeout and check intervals can be specified if needed, as shown\nbelow:\n\nExample#\n\n\n\nAlternatively, a default global timeout value can be set using the configure\nfunction:\n\n\n\n\nwaitFor function#\n\nThe waitFor function is another option, serving as a lower-level utility in more\nadvanced cases.\n\n\n\nIt accepts an expectation to be validated and repeats the check every defined\ninterval until it no longer throws an error. Similarly to findBy* queries they\naccept timeout and interval options and have the same default values of 1000ms\nfor timeout, and a checking interval of 50 ms.\n\nExample#\n\n\n\nIf you want to use it with getBy* queries, use the findBy* queries instead, as\nthey essentially do the same, but offer better developer experience.\n\n\nwaitForElementToBeRemoved function#\n\nA specialized function, waitForElementToBeRemoved, is used to verify that a\nmatching element was present but has since been removed.\n\n\n\nThis function is, in a way, the negation of waitFor as it expects the initial\nexpectation to be true (not throw an error), only to turn invalid (start\nthrowing errors) on subsequent runs. It operates using the same timeout and\ninterval parameters as findBy* queries and waitFor.\n\nExample#\n\n\n\n\nFake Timers#\n\nAsynchronous tests can take long to execute due to the delays introduced by\nasynchronous operations. To mitigate this, fake timers can be used. These are\nparticularly useful when delays are mere waits, such as the 130 milliseconds\nwait introduced by the UserEvent press() event due to React Native runtime\nbehavior or simulated 1000 wait in a API call mock. Fake timers allow for\nprecise fast-forwarding through these wait periods.\n\nHere are the basics of using Jest fake timers:\n\n * Enable fake timers with: jest.useFakeTimers()\n * Disable fake timers with: jest.useRealTimers()\n * Advance fake timers forward with: jest.advanceTimersByTime(interval)\n * Run all timers to completion with: jest.runAllTimers()\n * Run currently pending timers to completion with: jest.runOnlyPendingTimers()\n\nBe cautious when running all timers to completion as it might create an infinite\nloop if these timers schedule follow-up timers. In such cases, it's safer to use\njest.runOnlyPendingTimers() to avoid ending up in an infinite loop of scheduled\ntasks.\n\nYou can use both built-in Jest fake timers, as well as Sinon.JS fake timers.\n\nNote: you do not need to advance timers by hand when using User Event API, as\nit's automatically.","routePath":"/react-native-testing-library/14.x/cookbook/basics/async-tests","lang":"","toc":[{"text":"Summary","id":"summary","depth":2,"charIndex":3},{"text":"Example","id":"example","depth":3,"charIndex":911},{"text":"Async utilities","id":"async-utilities","depth":2,"charIndex":1008},{"text":"`findBy*` queries","id":"findby-queries","depth":3,"charIndex":-1},{"text":"Example","id":"example-1","depth":4,"charIndex":1622},{"text":"`waitFor` function","id":"waitfor-function","depth":3,"charIndex":-1},{"text":"Example","id":"example-2","depth":4,"charIndex":2128},{"text":"`waitForElementToBeRemoved` function","id":"waitforelementtoberemoved-function","depth":3,"charIndex":-1},{"text":"Example","id":"example-3","depth":4,"charIndex":2743},{"text":"Fake Timers","id":"fake-timers","depth":2,"charIndex":2756}],"domain":"","frontmatter":{},"version":"14.x"},{"id":69,"title":"Custom `render` function","content":"Custom render function#\n\n\nSummary#\n\nRNTL exposes the render function as the primary entry point for tests. If you\nmake complex, repeating setups for your tests, consider creating a custom render\nfunction. The idea is to encapsulate common setup steps and test wiring inside a\nrender function suitable for your tests.\n\n\nExample#\n\n\n\n\n\nExample full source code.\n\n\nMore info#\n\nAdditional params#\n\nA custom render function might accept additional parameters to allow for setting\nup different start conditions for a test, e.g., the initial state for global\nstate management.\n\n\n\nMultiple functions#\n\nDepending on the situation, you may declare more than one custom render\nfunction. For example, you have one function for testing application flows and a\nsecond for testing individual screens.\n\n\n\nAsync function#\n\nMake it async if you want to put some async setup in your custom render\nfunction.\n\n","routePath":"/react-native-testing-library/14.x/cookbook/basics/custom-render","lang":"","toc":[{"text":"Summary","id":"summary","depth":3,"charIndex":25},{"text":"Example","id":"example","depth":3,"charIndex":318},{"text":"More info","id":"more-info","depth":3,"charIndex":360},{"text":"Additional params","id":"additional-params","depth":4,"charIndex":372},{"text":"Multiple functions","id":"multiple-functions","depth":4,"charIndex":571},{"text":"Async function","id":"async-function","depth":4,"charIndex":787}],"domain":"","frontmatter":{},"version":"14.x"},{"id":70,"title":"Introduction","content":"#\n\nWelcome to the React Native Testing Library (RNTL) Cookbook! This app is your\ngo-to resource for learning how to effectively test React Native applications.\nIt provides a collection of best practices, ready-made recipes, and tips &\ntricks to simplify and improve your testing workflow. Whether you’re a beginner\njust getting started or a seasoned developer looking to sharpen your skills, the\nCookbook has something for everyone.\n\n\nWhat's Inside the Cookbook?#\n\nThe Cookbook is currently organized into three main chapters:\n\n * Basic Recipes: A great starting point, covering essential testing scenarios\n   such as async operations and custom render functions.\n * Advanced Recipes: More complex scenarios like network requests and in the\n   future, navigation testing and more.\n * State Management Recipes: Best practices for testing state management\n   libraries\n\nEach recipe includes a clear explanation along with a corresponding code example\nto help you get hands-on with testing. Checkout the Cookbook App to see the\nrecipes in action.\n\n\nWhat's Next?#\n\nJoin the conversation on GitHub here to discuss ideas, ask questions, or provide\nfeedback.","routePath":"/react-native-testing-library/14.x/cookbook/","lang":"","toc":[{"text":"What's Inside the Cookbook?","id":"whats-inside-the-cookbook","depth":2,"charIndex":434},{"text":"What's Next?","id":"whats-next","depth":2,"charIndex":1045}],"domain":"","frontmatter":{},"version":"14.x"},{"id":71,"title":"Jotai","content":"#\n\n\nIntroduction#\n\nJotai is a global state management library for React that uses an atomic\napproach to optimize renders and solve issues like extra re-renders and the need\nfor memoization. It scales from simple state management to complex enterprise\napplications, offering utilities and extensions to enhance the developer\nexperience.\n\n\nTask List Example#\n\nLet's assume we have a simple task list component that uses Jotai for state\nmanagement. The component has a list of tasks, a text input for typing new task\nname and a button to add a new task to the list.\n\n\n\n\nStarting with a Simple Test#\n\nWe can test our TaskList component using React Native Testing Library's (RNTL)\nregular render function. Although it is sufficient to test the empty state of\nthe TaskList component, it is not enough to test the component with initial\ntasks present in the list.\n\n\n\n\nCustom Render Function to populate Jotai Atoms with Initial Values#\n\nTo test the TaskList component with initial tasks, we need to be able to\npopulate the tasksAtom with initial values. We can create a custom render\nfunction that uses Jotai's useHydrateAtoms hook to hydrate the atoms with\ninitial values. This function will accept the initial atoms and their\ncorresponding values as an argument.\n\n\n\n\nTesting the TaskList Component with initial tasks#\n\nWe can now use the renderWithAtoms function to render the TaskList component\nwith initial tasks. The initialValues property will contain the tasksAtom,\nnewTaskTitleAtom and their initial values. We can then test the component to\nensure that the initial tasks are rendered correctly.\n\nINFO\n\nIn our test, we populated only one atom and its initial value, but you can add\nother Jotai atoms and their corresponding values to the initialValues array as\nneeded.\n\n\n\n\nModifying atom outside of React components#\n\nIn several cases, you might need to change an atom's state outside a React\ncomponent. In our case, we have a set of functions to get tasks and set tasks,\nwhich change the state of the task list atom.\n\n\n\n\nTesting atom outside of React components#\n\nYou can test the getAllTasks and addTask functions outside the React component's\nscope by setting the initial to-do items in the store and then checking if the\nfunctions work as expected. No special setup is required to test these\nfunctions, as store.set is available by default by Jotai.\n\n\n\n\nConclusion#\n\nTesting a component or a function that depends on Jotai atoms is straightforward\nwith the help of the useHydrateAtoms hook. We've seen how to create a custom\nrender function renderWithAtoms that sets up atoms and their initial values for\ntesting purposes. We've also seen how to test functions that change the state of\natoms outside React components. This approach allows us to test components in\ndifferent states and scenarios, ensuring they behave as expected.","routePath":"/react-native-testing-library/14.x/cookbook/state-management/jotai","lang":"","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":3},{"text":"Task List Example","id":"task-list-example","depth":2,"charIndex":337},{"text":"Starting with a Simple Test","id":"starting-with-a-simple-test","depth":2,"charIndex":566},{"text":"Custom Render Function to populate Jotai Atoms with Initial Values","id":"custom-render-function-to-populate-jotai-atoms-with-initial-values","depth":2,"charIndex":860},{"text":"Testing the `TaskList` Component with initial tasks","id":"testing-the-tasklist-component-with-initial-tasks","depth":2,"charIndex":-1},{"text":"Modifying atom outside of React components","id":"modifying-atom-outside-of-react-components","depth":2,"charIndex":1773},{"text":"Testing atom outside of React components","id":"testing-atom-outside-of-react-components","depth":2,"charIndex":2022},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":2358}],"domain":"","frontmatter":{},"version":"14.x"},{"id":72,"title":"Testing environment","content":"#\n\nINFO\n\nThis document is intended for a more advanced audience who want to understand\nthe internals of our testing environment better, e.g., to contribute to the\ncodebase. You should be able to write integration or component tests without\nreading this.\n\nReact Native Testing Library allows you to write integration and component tests\nfor your React Native app or library. While the JSX code used in tests closely\nresembles your React Native app, things are not as simple as they might appear.\nThis document will describe the key elements of our testing environment and\nhighlight things to be aware of when writing more advanced tests or diagnosing\nissues.\n\n\nReact renderers#\n\nReact allows you to write declarative code using JSX, write function or class\ncomponents, or use hooks like useState. You need to use a renderer to output the\nresults of your components. Every React app uses some renderer:\n\n * React Native is a renderer for mobile apps,\n * React DOM is a renderer for web apps,\n * There are other more specialized renderers that can e.g., render to console\n   or HTML canvas.\n\nWhen you run your tests in the React Native Testing Library, somewhat contrary\nto what the name suggests, they are actually not using React Native renderer.\nThis is because this renderer needs to be run on an iOS or Android operating\nsystem, so it would need to run on a device or simulator.\n\n\nTest Renderer#\n\nInstead, RNTL uses Test Renderer, a modern, actively maintained renderer that\nallows rendering to pure JavaScript objects without access to mobile OS and can\nrun in a Node.js environment using Jest (or any other JavaScript test runner).\nTest Renderer replaces the deprecated react-test-renderer package and provides\nbetter compatibility with React 19 and improved type safety.\n\nUsing Test Renderer has pros and cons.\n\nBenefits:\n\n * tests can run on most CIs (Linux, etc) and do not require a mobile device or\n   emulator\n * faster test execution\n * light runtime environment\n\nDisadvantages:\n\n * Tests do not execute native code\n * Tests are unaware of the view state that would be managed by native\n   components, e.g., focus, unmanaged text boxes, etc.\n * Assertions do not operate on native view hierarchy\n * Runtime behaviors are simulated, sometimes imperfectly\n\nIt's worth noting that the React Testing Library (web one) works a bit\ndifferently. While RTL also runs in Jest, it has access to a simulated browser\nDOM environment from the jsdom package, which allows it to use a regular React\nDOM renderer. Unfortunately, there is no similar React Native runtime\nenvironment package. This is probably because while the browser environment is\nwell-defined and highly standardized, the React Native environment constantly\nevolves in sync with the evolution of underlying OS-es. Maintaining such an\nenvironment would require duplicating countless React Native behaviors and\nkeeping them in sync as React Native develops.\n\n\nElement tree#\n\nCalling the render() function creates an element tree. This is done internally\nby invoking the renderer's create() method from Test Renderer. The output tree\nrepresents your React Native component tree, and each node of that tree is an\n\"instance\" of some React component (to be more precise, each node represents a\nReact fiber, and only class components have instances, while function components\nstore the hook state using fibers).\n\nThese tree elements are represented by HostElement type from Test Renderer:\n\n\n\nFor more details, see the Test Renderer documentation.\n\n\nHost and composite components#\n\nOne of the most important aspects of the element tree is that it is composed of\nboth host and composite components:\n\n * Host components will have direct counterparts in the native view tree.\n   Typical examples are <View>, <Text> , <TextInput>, and <Image> from React\n   Native. You can think of these as an analog of <div>, <span> etc on the Web.\n   You can also create custom host views as native modules or import them from\n   3rd party libraries, like React Navigation or React Native Gesture Handler.\n * Composite components are React code organization units that exist only on the\n   JavaScript side of your app. Typical examples are components you create\n   (function and class components), components imported from React Native (View,\n   Text, etc.), or 3rd party packages.\n\nThat might initially sound confusing since we put React Native's View in both\ncategories. There are two View components: composite and host. The relation\nbetween them is as follows:\n\n * composite View is the type imported from the react-native package. It is a\n   JavaScript component that renders the host View as its only child in the\n   element tree.\n * host View, which you do not render directly. React Native takes the props you\n   pass to the composite View, does some processing on them and passes them to\n   the host View.\n\nThe part of the tree looks as follows:\n\n\n\nA similar relation exists between other composite and host pairs: e.g. Text ,\nTextInput, and Image components:\n\n\n\nNot all React Native components are organized this way, e.g., when you use\nPressable (or TouchableOpacity), there is no host Pressable, but composite\nPressable is rendering a host View with specific props being set:\n\n\n\n\nDifferentiating between host and composite elements#\n\nAny easy way to differentiate between host and composite elements is the type\nprop of HostElement:\n\n * for host components, it's always a string value representing a component\n   name, e.g., \"View\"\n * for composite components, it's a function or class corresponding to the\n   component\n\nYou can use the following code to check if a given element is a host one:\n\n\n\n\nTree nodes#\n\nWe encourage you to only assert values on host views in your tests because they\nrepresent the user interface view and controls which the user can see and\ninteract with. Users cannot see or interact with composite views as they exist\npurely in the JavaScript domain and do not generate any visible UI.\n\n\nAsserting props#\n\nFor example, suppose you assert a style prop of a composite element. In that\ncase, there is no guarantee that the style will be visible to the user, as the\ncomponent author can forget to pass this prop to some underlying View or other\nhost component. Similarly onPress event handler on a composite prop can be\nunreachable by the user.\n\n\n\nIn the above example, user-defined components accept both onPress and style\nprops but do not pass them (through Pressable) to host views, so they will not\naffect the user interface. Additionally, React Native and other libraries might\npass some of the props under different names or transform their values between\ncomposite and host components.\n\n\nTree navigation#\n\nCAUTION\n\nYou should avoid navigating over the element tree, as this makes your testing\ncode fragile and may result in false positives. This section is more relevant\nfor people who want to contribute to our codebase.\n\nYou will encounter host and composite elements when navigating a tree of react\nelements using parent or children props of a HostElement element. You should be\ncareful when navigating the element tree, as the tree structure for third-party\ncomponents can change independently from your code and cause unexpected test\nfailures.\n\nInside RNTL, we have various tree navigation helpers: getHostParent,\ngetHostChildren, etc. These are intentionally not exported, as using them is not\nrecommended.\n\n\nQueries#\n\nAll recommended Testing Library queries return host components to encourage the\nbest practices described above.\n\nOnly UNSAFE_*ByType and UNSAFE_*ByProps queries can return both host and\ncomposite components depending on used predicates. They are marked as unsafe\nprecisely because testing composite components makes your test more fragile.","routePath":"/react-native-testing-library/14.x/docs/advanced/testing-env","lang":"","toc":[{"text":"React renderers","id":"react-renderers","depth":2,"charIndex":659},{"text":"Test Renderer","id":"test-renderer","depth":2,"charIndex":1382},{"text":"Element tree","id":"element-tree","depth":2,"charIndex":2921},{"text":"Host and composite components","id":"host-and-composite-components","depth":2,"charIndex":3505},{"text":"Differentiating between host and composite elements","id":"differentiating-between-host-and-composite-elements","depth":3,"charIndex":5229},{"text":"Tree nodes","id":"tree-nodes","depth":2,"charIndex":5648},{"text":"Asserting props","id":"asserting-props","depth":3,"charIndex":5964},{"text":"Tree navigation","id":"tree-navigation","depth":2,"charIndex":6667},{"text":"Queries","id":"queries","depth":2,"charIndex":7394}],"domain":"","frontmatter":{},"version":"14.x"},{"id":73,"title":"Third-Party Library Integration","content":"#\n\nThe React Native Testing Library is designed to simulate the core behaviors of\nReact Native. However, it does not replicate the internal logic of third-party\nlibraries. This guide explains how to integrate your library with RNTL.\n\n\nHandling Events in Third-Party Libraries#\n\nRNTL provides two subsystems to simulate events:\n\n * Fire Event: A lightweight simulation system that can trigger event handlers\n   defined on both host and composite components.\n * User Event: A more realistic interaction simulation system that can trigger\n   event handlers defined only on host components.\n\nIn many third-party libraries, event handling involves native code, which means\nRNTL cannot fully simulate the event flow, as it runs only JavaScript code. To\naddress this limitation, you can use testOnly_on* props on host components to\nexpose custom events to RNTL’s event subsystems. Both subsystems will first\nattempt to locate the standard on* event handlers; if these are not available,\nthey fall back to the testOnly_on* handlers.\n\n\nExample: React Native Gesture Handler#\n\nReact Native Gesture Handler (RNGH) provides a composite Pressable component\nwith onPress* props. These event handlers are not exposed on the rendered host\nviews; instead, they are invoked via RNGH’s internal event flow, which involves\nnative modules. As a result, they are not accessible to RNTL’s event subsystems.\n\nTo enable RNTL to interact with RNGH’s Pressable component, the library exposes\ntestOnly_onPress* props on the NativeButton host component rendered by\nPressable. This adjustment allows RNTL to simulate interactions during testing.\n\n","routePath":"/react-native-testing-library/14.x/docs/advanced/third-party-integration","lang":"","toc":[{"text":"Handling Events in Third-Party Libraries","id":"handling-events-in-third-party-libraries","depth":2,"charIndex":234},{"text":"Example: React Native Gesture Handler","id":"example-react-native-gesture-handler","depth":3,"charIndex":1026}],"domain":"","frontmatter":{},"version":"14.x"},{"id":74,"title":"Understanding `act` function","content":"Understanding act function#\n\nWhen writing RNTL tests one of the things that confuses developers the most are\ncryptic act() function errors logged into console. In this article I will try to\nbuild an understanding of the purpose and behaviour of act() so you can build\nyour tests with more confidence.\n\n\nact warnings#\n\nLet’s start with typical act() warnings logged to console. There are two kinds\nof these issues, let’s call the first one the \"sync act()\" warning:\n\n\n\nThe second one relates to async usage of act so let’s call it the \"async act\"\nerror:\n\n\n\n\nSynchronous act#\n\n\nResponsibility#\n\nThis function is intended only for using in automated tests and works only in\ndevelopment mode. Attempting to use it in production build will throw an error.\n\nThe responsibility for act function is to make React renders and updates work in\ntests in a similar way they work in real application by grouping and executing\nrelated units of interaction (e.g. renders, effects, etc) together.\n\nTo showcase that behaviour let make a small experiment. First we define a\nfunction component that uses useEffect hook in a trivial way.\n\n\n\nIn the following tests we will directly use ReactTestRenderer instead of RNTL\nrender function to render our component for tests. In order to expose familiar\nqueries like getByText we will use within function from RNTL.\n\n\n\nWhen testing without act call wrapping rendering call, we see that the assertion\nruns just after the rendering but before useEffecthooks effects are applied.\nWhich is not what we expected in our tests.\n\n\n\nNote: In v14, act is now async by default and always returns a Promise. Even if\nyour callback is synchronous, you should use await act(async () => ...).\n\nWhen wrapping rendering call with act we see that the changes caused by\nuseEffect hook have been applied as we would expect.\n\n\nWhen to use act#\n\nThe name act comes from Arrange-Act-Assert unit testing pattern. Which means\nit’s related to part of the test when we execute some actions on the component\ntree.\n\nSo far we learned that act function allows tests to wait for all pending React\ninteractions to be applied before we make our assertions. When using act we get\nguarantee that any state updates will be executed as well as any enqueued\neffects will be executed.\n\nTherefore, we should use act whenever there is some action that causes element\ntree to render, particularly:\n\n * initial render call - ReactTestRenderer.create call\n * re-rendering of component -renderer.update call\n * triggering any event handlers that cause component tree render\n\nThankfully, for these basic cases RNTL has got you covered as our render, update\nand fireEvent methods already wrap their calls in act so that you do not have to\ndo it explicitly.\n\nNote that act calls can be safely nested and internally form a stack of calls.\nHowever, overlapping act calls, which can be achieved using async version of\nact, are not supported.\n\n\nImplementation#\n\nAs of React version of 18.1.0, the act implementation is defined in the\nReactAct.js source file inside React repository. This implementation has been\nfairly stable since React 17.0.\n\nRNTL exports act for convenience of the users as defined in the act.ts source\nfile. In v14, act is now async by default and always returns a Promise, making\nit compatible with React 19, React Suspense, and React.use(). The underlying\nimplementation still uses React's act function, but wraps it to ensure\nconsistent async behavior.\n\n\nAsynchronous act#\n\nSo far we have seen synchronous version of act which runs its callback\nimmediately. This can deal with things like synchronous effects or mocks using\nalready resolved promises. However, not all component code is synchronous.\nFrequently our components or mocks contain some asynchronous behaviours like\nsetTimeout calls or network calls. Starting from React 16.9, act can also be\ncalled in asynchronous mode. In such case act implementation checks that the\npassed callback returns object resembling promise.\n\n\nAsynchronous code#\n\nAsynchronous version of act also is executed immediately, but the callback is\nnot yet completed because of some asynchronous operations inside.\n\nLets look at a simple example with component using setTimeout call to simulate\nasynchronous behaviour:\n\n\n\n\n\nIf we test our component in a native way without handling its asynchronous\nbehaviour we will end up with sync act warning:\n\n\n\nNote that this is not yet the infamous async act warning. It only asks us to\nwrap our event code with act calls. However, this time our immediate state\nchange does not originate from externally triggered events but rather forms an\ninternal part of the component. So how can we apply act in such scenario?\n\n\nSolution with fake timers#\n\nFirst solution is to use Jest's fake timers inside out tests:\n\n\n\nNote: In v14, act is now async by default, so you should await it even when\nusing fake timers.\n\nThat way we can wrap jest.runAllTimers() call which triggers the setTimeout\nupdates inside an act call, hence resolving the act warning. Note that this\nwhole code is synchronous thanks to usage of Jest fake timers.\n\n\nSolution with real timers#\n\nIf we wanted to stick with real timers then things get a bit more complex. Let’s\nstart by applying a crude solution of opening async act() call for the expected\nduration of components updates:\n\n\n\nThis works correctly as we use an explicit async act() call that resolves the\nconsole error. However, it relies on our knowledge of exact implementation\ndetails which is a bad practice.\n\nLet’s try more elegant solution using waitFor that will wait for our desired\nstate:\n\n\n\nThis also works correctly, because waitFor call executes async act() call\ninternally.\n\nThe above code can be simplified using findBy query:\n\n\n\nThis also works since findByText internally calls waitFor which uses async\nact().\n\nNote that all of the above examples are async tests using & awaiting async act()\nfunction call.\n\n\nAsync act warning#\n\nIf we modify any of the above async tests and remove await keyword, then we will\ntrigger the notorious async act()warning:\n\n\n\nReact decides to show this error whenever it detects that async act()call has\nnot been awaited.\n\nThe exact reasons why you might see async act() warnings vary, but finally it\nmeans that act() has been called with callback that returns Promise-like object,\nbut it has not been waited on.\n\n\nReferences#\n\n * React act implementation source\n * React testing recipes: act()","routePath":"/react-native-testing-library/14.x/docs/advanced/understanding-act","lang":"","toc":[{"text":"`act` warnings","id":"act-warnings","depth":2,"charIndex":-1},{"text":"Synchronous `act`","id":"synchronous-act","depth":2,"charIndex":-1},{"text":"Responsibility","id":"responsibility","depth":3,"charIndex":575},{"text":"When to use act","id":"when-to-use-act","depth":3,"charIndex":1827},{"text":"Implementation","id":"implementation","depth":3,"charIndex":2914},{"text":"Asynchronous `act`","id":"asynchronous-act","depth":2,"charIndex":-1},{"text":"Asynchronous code","id":"asynchronous-code","depth":3,"charIndex":3976},{"text":"Solution with fake timers","id":"solution-with-fake-timers","depth":3,"charIndex":4682},{"text":"Solution with real timers","id":"solution-with-real-timers","depth":3,"charIndex":5088},{"text":"Async act warning","id":"async-act-warning","depth":3,"charIndex":5910},{"text":"References","id":"references","depth":2,"charIndex":6345}],"domain":"","frontmatter":{},"version":"14.x"},{"id":75,"title":"API Overview","content":"#\n\nReact Native Testing Library consists of following APIs:\n\n * render function - render your UI components for testing purposes\n * screen object - access rendered UI:\n   * Queries - find relevant components by various predicates: role, text, test\n     ids, etc\n   * Lifecycle methods: rerender, unmount\n   * Helpers: debug, toJSON, root\n * Jest matchers - validate assumptions about your UI\n * User Event - simulate common user interactions like press or type in a\n   realistic way\n * Fire Event - simulate any component event in a simplified way purposes\n * Misc APIs:\n   * renderHook function - render hooks for testing\n   * Async utils: findBy* queries, wait, waitForElementToBeRemoved\n   * Configuration: configure, resetToDefaults\n   * Accessibility: isHiddenFromAccessibility\n   * Other: within, act, cleanup","routePath":"/react-native-testing-library/14.x/docs/api","lang":"","toc":[],"domain":"","frontmatter":{"uri":"/api"},"version":"14.x"},{"id":76,"title":"Fire Event API","content":"#\n\n\nfireEvent #\n\nNOTE\n\nFor common events like press or type it's recommended to use User Event API as\nit offers more realistic event simulation by emitting a sequence of events with\nproper event objects that mimic React Native runtime behavior.\n\nUse Fire Event for cases not supported by User Event and for triggering event\nhandlers on composite components.\n\n\n\nThe fireEvent API allows you to trigger all kinds of event handlers on both host\nand composite components. It will try to invoke a single event handler\ntraversing the component tree bottom-up from passed element and trying to find\nenabled event handler named onXxx when xxx is the name of the event passed.\n\nUnlike User Event, this API does not automatically pass event object to event\nhandler, this is responsibility of the user to construct such object.\n\nThis function uses async act function internally to ensure all pending React\nupdates are executed during event handling.\n\n\n\nNOTE\n\nfireEvent performs checks that should prevent events firing on disabled\nelements.\n\nAn example using fireEvent with native events that aren't already aliased by the\nfireEvent api.\n\n\n\nFireEvent exposes convenience methods for common events like: press, changeText,\nscroll.\n\n\nfireEvent.press #\n\nNOTE\n\nIt is recommended to use the User Event press() helper instead as it offers more\nrealistic simulation of press interaction, including pressable support.\n\n\n\nInvokes press event handler on the element or parent element in the tree.\n\n\n\n\nfireEvent.changeText #\n\nNOTE\n\nIt is recommended to use the User Event type() helper instead as it offers more\nrealistic simulation of text change interaction, including key-by-key typing,\nelement focus, and other editing events.\n\n\n\nInvokes changeText event handler on the element or parent element in the tree.\n\n\n\n\nfireEvent.scroll #\n\nNOTE\n\nPrefer using user.scrollTo over fireEvent.scroll for ScrollView, FlatList, and\nSectionList components. User Event provides a more realistic event simulation\nbased on React Native runtime behavior.\n\n\n\nInvokes scroll event handler on the element or parent element in the tree.\n\nOn a ScrollView#\n\n\n\n\nunsafe_fireEventSync #\n\n\n\nSynchronous version of fireEvent. Deprecated and will be removed in future\nversions. Use only if you cannot use await fireEvent for some reason.","routePath":"/react-native-testing-library/14.x/docs/api/events/fire-event","lang":"","toc":[{"text":"`fireEvent`","id":"fireevent","depth":2,"charIndex":-1},{"text":"`fireEvent.press`","id":"fireeventpress","depth":3,"charIndex":-1},{"text":"`fireEvent.changeText`","id":"fireeventchangetext","depth":3,"charIndex":-1},{"text":"`fireEvent.scroll`","id":"fireeventscroll","depth":3,"charIndex":-1},{"text":"On a `ScrollView`","id":"on-a-scrollview","depth":4,"charIndex":-1},{"text":"`unsafe_fireEventSync`","id":"unsafe_fireeventsync","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":77,"title":"User Event interactions","content":"#\n\n\nComparison with Fire Event API#\n\nFire Event is our original event simulation API. It can invoke any event handler\ndeclared on either host or composite elements. Suppose the element does not have\nonEventName event handler for the passed eventName event, or the element is\ndisabled. In that case, Fire Event will traverse up the component tree, looking\nfor an event handler on both host and composite elements along the way. By\ndefault, it will not pass any event data, but the user might provide it in the\nlast argument.\n\nIn contrast, User Event provides realistic event simulation for user\ninteractions like press or type. Each interaction will trigger a sequence of\nevents corresponding to React Native runtime behavior. These events will be\ninvoked only on host elements, and will automatically receive event data\ncorresponding to each event.\n\nIf User Event supports a given interaction, you should always prefer it over the\nFire Event counterpart, as it will make your tests much more realistic and,\nhence, reliable. In other cases, e.g., when User Event does not support the\ngiven event or when invoking event handlers on composite elements, you have to\nuse Fire Event as the only available option.\n\n\nsetup()#\n\n\n\nExample\n\n\n\nCreates a User Event object instance, which can be used to trigger events.\n\n\nOptions #\n\n * delay controls the default delay between subsequent events, e.g., keystrokes.\n * advanceTimers is a time advancement utility function that should be used for\n   fake timers. The default setup handles both real timers and Jest fake timers.\n\n\npress()#\n\n\n\nExample\n\n\n\nThis helper simulates a press on any pressable element, e.g. Pressable,\nTouchableOpacity, Text, TextInput, etc. Unlike fireEvent.press(), a more\nstraightforward API that will only call the onPress prop, this function\nsimulates the entire press interaction in a more realistic way by reproducing\nthe event sequence emitted by React Native runtime. This helper will trigger\nadditional events like pressIn and pressOut.\n\nThis event will take a minimum of 130 ms to run due to the internal React Native\nlogic. Consider using fake timers to speed up test execution for tests involving\npress and longPress interactions.\n\n\nlongPress()#\n\n\n\nExample\n\n\n\nSimulates a long press user interaction. In React Native, the longPress event is\nemitted when the press duration exceeds the long press threshold (by default,\n500 ms). In other aspects, this action behaves similarly to regular press\naction, e.g., by emitting pressIn and pressOut events. The press duration is\ncustomizable through the options. This should be useful if you use the\ndelayLongPress prop.\n\nThis event will, by default, take 500 ms to run. Due to internal React Native\nlogic, it will take at least 130 ms regardless of the duration option passed.\nConsider using fake timers to speed up test execution for tests involving press\nand longPress interactions.\n\n\nOptions #\n\n * duration - duration of the press in milliseconds. The default value is 500\n   ms.\n\n\ntype()#\n\n\n\nExample\n\n\n\nThis helper simulates the user focusing on a TextInput element, typing text one\ncharacter at a time, and leaving the element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\nNOTE\n\nThis function will add text to the text already present in the text input (as\nspecified by value or defaultValue props). To replace existing text, use clear()\nhelper first.\n\n\nOptions #\n\n * skipPress - if true, pressIn and pressOut events will not be triggered.\n * skipBlur - if true, endEditing and blur events will not be triggered when\n   typing is complete.\n * submitEditing - if true, submitEditing event will be triggered after typing\n   the text.\n\n\nSequence of events #\n\nThe sequence of events depends on the multiline prop and the passed options.\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * pressIn (optional)\n * focus\n * pressOut (optional)\n\nThe pressIn and pressOut events are sent by default but can be skipped by\npassing the skipPress: true option.\n\nTyping (for each character):\n\n * keyPress\n * change\n * changeText\n * selectionChange\n * contentSizeChange (only multiline)\n\nLeaving the element:\n\n * submitEditing (optional)\n * endEditing\n * blur\n\nThe submitEditing event is skipped by default. It can sent by setting the\nsubmitEditing: true option. The endEditing and blur events can be skipped by\npassing the skipBlur: true option.\n\n\nclear()#\n\n\n\nExample\n\n\n\nThis helper simulates the user clearing the content of a TextInput element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\n\nSequence of events #\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * focus\n\nSelecting all content:\n\n * selectionChange\n\nPressing backspace:\n\n * keyPress\n * change\n * changeText\n * selectionChange\n\nLeaving the element:\n\n * endEditing\n * blur\n\n\npaste()#\n\n\n\nExample\n\n\n\nThis helper simulates the user pasting given text to a TextInput element.\n\nThis function supports only host TextInput elements. Passing other element types\nwill result in throwing an error.\n\n\nSequence of events #\n\nEvents will not be emitted if the editable prop is set to false.\n\nEntering the element:\n\n * focus\n\nSelecting all content:\n\n * selectionChange\n\nPasting the text:\n\n * change\n * changeText\n * selectionChange\n\nLeaving the element:\n\n * endEditing\n * blur\n\n\nscrollTo()#\n\n\n\nExample\n\n\n\nThis helper simulates the user scrolling a host ScrollView element.\n\nThis function supports only host ScrollView elements, passing other element\ntypes will result in an error. Note that FlatList is accepted as it renders to a\nhost ScrollView element.\n\nScroll interaction should match the ScrollView element direction:\n\n * for a vertical scroll view (default or horizontal={false}), you should pass\n   only the y option (and optionally also momentumY).\n * for a horizontal scroll view (horizontal={true}), you should pass only the x\n   option (and optionally momentumX).\n\nEach scroll interaction consists of a mandatory drag scroll part, which\nsimulates the user dragging the scroll view with his finger (the y or x option).\nThis may optionally be followed by a momentum scroll movement, which simulates\nthe inertial movement of scroll view content after the user lifts his finger\n(momentumY or momentumX options).\n\n\nOptions #\n\n * y - target vertical drag scroll offset\n * x - target horizontal drag scroll offset\n * momentumY - target vertical momentum scroll offset\n * momentumX - target horizontal momentum scroll offset\n * contentSize - passed to ScrollView events and enabling FlatList updates\n * layoutMeasurement - passed to ScrollView events and enabling FlatList updates\n\nUser Event will generate several intermediate scroll steps to simulate user\nscroll interaction. You should not rely on exact number or values of these\nscrolls steps as they might be change in the future version.\n\nThis function will remember where the last scroll ended, so subsequent scroll\ninteraction will starts from that position. The initial scroll position will be\nassumed to be { y: 0, x: 0 }.\n\nTo simulate a FlatList (and other controls based on VirtualizedList) scrolling,\nyou should pass the contentSize and layoutMeasurement options, which enable the\nunderlying logic to update the currently visible window.\n\n\nSequence of events #\n\nThe sequence of events depends on whether the scroll includes an optional\nmomentum scroll component.\n\nDrag scroll:\n\n * contentSizeChange\n * scrollBeginDrag\n * scroll (multiple events)\n * scrollEndDrag\n\nMomentum scroll (optional):\n\n * momentumScrollBegin\n * scroll (multiple events)\n * momentumScrollEnd","routePath":"/react-native-testing-library/14.x/docs/api/events/user-event","lang":"","toc":[{"text":"Comparison with Fire Event API","id":"comparison-with-fire-event-api","depth":2,"charIndex":3},{"text":"`setup()`","id":"setup","depth":2,"charIndex":-1},{"text":"Options","id":"options","depth":3,"charIndex":-1},{"text":"`press()`","id":"press","depth":2,"charIndex":-1},{"text":"`longPress()`","id":"longpress","depth":2,"charIndex":-1},{"text":"Options","id":"options-1","depth":3,"charIndex":-1},{"text":"`type()`","id":"type","depth":2,"charIndex":-1},{"text":"Options","id":"options-2","depth":3,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events","depth":3,"charIndex":-1},{"text":"`clear()`","id":"clear","depth":2,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-1","depth":3,"charIndex":-1},{"text":"`paste()`","id":"paste","depth":2,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-2","depth":3,"charIndex":-1},{"text":"`scrollTo()`","id":"scroll-to","depth":2,"charIndex":-1},{"text":"Options","id":"options-3","depth":3,"charIndex":-1},{"text":"Sequence of events","id":"sequence-of-events-3","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":78,"title":"Jest matchers","content":"#\n\nThis guide describes built-in Jest matchers, we recommend using these matchers\nas they provide readable tests, accessibility support, and a better developer\nexperience.\n\n\nSetup#\n\nThere is no need to set up the built-in matchers; they are automatically\navailable in your tests when you import anything from\n@testing-library/react-native, e.g., render.\n\n\nMigration from legacy Jest Native matchers.#\n\nIf you are already using legacy Jest Native matchers we have a migration guide\nfor moving to the built-in matchers.\n\n\nChecking element existence#\n\n\ntoBeOnTheScreen()#\n\n\n\nThis allows you to assert whether an element is attached to the element tree or\nnot. If you hold a reference to an element and it gets unmounted during the test\nit will no longer pass this assertion.\n\n\nElement Content#\n\n\ntoHaveTextContent()#\n\n\n\nThis allows you to assert whether the given element has the given text content\nor not. It accepts either string or RegExp matchers, as well as text match\noptions of exact and normalizer.\n\n\ntoContainElement()#\n\n\n\nThis allows you to assert whether the given container element does contain\nanother host element.\n\n\ntoBeEmptyElement()#\n\n\n\nThis allows you to assert whether the given element does not have any host child\nelements or text content.\n\n\nChecking element state#\n\n\ntoHaveDisplayValue()#\n\n\n\nThis allows you to assert whether the given TextInput element has a specified\ndisplay value. It accepts either string or RegExp matchers, as well as text\nmatch options of exact and normalizer.\n\n\ntoHaveAccessibilityValue()#\n\n\n\nThis allows you to assert whether the given element has a specified accessible\nvalue.\n\nThis matcher will assert accessibility value based on aria-valuemin,\naria-valuemax, aria-valuenow, aria-valuetext and accessibilityValue props. Only\ndefined value entries will be used in the assertion, the element might have\nadditional accessibility value entries and still be matched.\n\nWhen querying by text entry a string or RegExp might be used.\n\n\ntoBeEnabled() / toBeDisabled #\n\n\n\nThese allow you to assert whether the given element is enabled or disabled from\nthe user's perspective. It relies on the accessibility disabled state as set by\naria-disabled or accessibilityState.disabled props. It will consider a given\nelement disabled when it or any of its ancestors is disabled.\n\nNOTE\n\nThese matchers are the negation of each other, and both are provided to avoid\ndouble negations in your assertions.\n\n\ntoBeSelected()#\n\n\n\nThis allows you to assert whether the given element is selected from the user's\nperspective. It relies on the accessibility selected state as set by\naria-selected or accessibilityState.selected props.\n\n\ntoBeChecked() / toBePartiallyChecked() #\n\n\n\nThese allow you to assert whether the given element is checked or partially\nchecked from the user's perspective. It relies on the accessibility checked\nstate as set by aria-checked or accessibilityState.checked props.\n\nNOTE\n * toBeChecked() matcher works only on Switch host elements and accessibility\n   elements with checkbox, radio or switch role.\n * toBePartiallyChecked() matcher works only on elements with checkbox role.\n\n\ntoBeExpanded() / toBeCollapsed() #\n\n\n\nThese allows you to assert whether the given element is expanded or collapsed\nfrom the user's perspective. It relies on the accessibility disabled state as\nset by aria-expanded or accessibilityState.expanded props.\n\nNOTE\n\nThese matchers are the negation of each other for expandable elements (elements\nwith explicit aria-expanded or accessibilityState.expanded props). However, both\nwon't pass for non-expandable elements (ones without explicit aria-expanded or\naccessibilityState.expanded props).\n\n\ntoBeBusy()#\n\n\n\nThis allows you to assert whether the given element is busy from the user's\nperspective. It relies on the accessibility selected state as set by aria-busy\nor accessibilityState.busy props.\n\n\nChecking element style#\n\n\ntoBeVisible()#\n\n\n\nThis allows you to assert whether the given element is visible from the user's\nperspective.\n\nThe element is considered invisible when itself or any of its ancestors has\ndisplay: none or opacity: 0 styles, as well as when it's hidden from\naccessibility.\n\n\ntoHaveStyle()#\n\n\n\nThis allows you to assert whether the given element has given styles.\n\n\nOther matchers#\n\n\ntoHaveAccessibleName()#\n\n\n\nThis allows you to assert whether the given element has a specified accessible\nname. It accepts either string or RegExp matchers, as well as text match options\nof exact and normalizer.\n\nThe accessible name will be computed based on aria-labelledby,\naccessibilityLabelledBy, aria-label, and accessibilityLabel props, in the\nabsence of these props, the element text content will be used.\n\nWhen the name parameter is undefined it will only check if the element has any\naccessible name.\n\n\ntoHaveProp()#\n\n\n\nThis allows you to assert whether the given element has a given prop. When the\nvalue parameter is undefined it will only check for existence of the prop, and\nwhen value is defined it will check if the actual value matches passed value.\n\nNOTE\n\nThis matcher should be treated as an escape hatch to be used when all other\nmatchers are not suitable.","routePath":"/react-native-testing-library/14.x/docs/api/jest-matchers","lang":"","toc":[{"text":"Setup","id":"setup","depth":2,"charIndex":173},{"text":"Migration from legacy Jest Native matchers.","id":"migration-from-legacy-jest-native-matchers","depth":2,"charIndex":355},{"text":"Checking element existence","id":"checking-element-existence","depth":2,"charIndex":519},{"text":"`toBeOnTheScreen()`","id":"tobeonthescreen","depth":3,"charIndex":-1},{"text":"Element Content","id":"element-content","depth":2,"charIndex":773},{"text":"`toHaveTextContent()`","id":"tohavetextcontent","depth":3,"charIndex":-1},{"text":"`toContainElement()`","id":"tocontainelement","depth":3,"charIndex":-1},{"text":"`toBeEmptyElement()`","id":"tobeemptyelement","depth":3,"charIndex":-1},{"text":"Checking element state","id":"checking-element-state","depth":2,"charIndex":1259},{"text":"`toHaveDisplayValue()`","id":"tohavedisplayvalue","depth":3,"charIndex":-1},{"text":"`toHaveAccessibilityValue()`","id":"tohaveaccessibilityvalue","depth":3,"charIndex":-1},{"text":"`toBeEnabled()` / `toBeDisabled`","id":"tobeenabled--tobedisabled","depth":3,"charIndex":-1},{"text":"`toBeSelected()`","id":"tobeselected","depth":3,"charIndex":-1},{"text":"`toBeChecked()` / `toBePartiallyChecked()`","id":"tobechecked--tobepartiallychecked","depth":3,"charIndex":-1},{"text":"`toBeExpanded()` / `toBeCollapsed()`","id":"tobeexpanded--tobecollapsed","depth":3,"charIndex":-1},{"text":"`toBeBusy()`","id":"tobebusy","depth":3,"charIndex":-1},{"text":"Checking element style","id":"checking-element-style","depth":2,"charIndex":3871},{"text":"`toBeVisible()`","id":"tobevisible","depth":3,"charIndex":-1},{"text":"`toHaveStyle()`","id":"tohavestyle","depth":3,"charIndex":-1},{"text":"Other matchers","id":"other-matchers","depth":2,"charIndex":4260},{"text":"`toHaveAccessibleName()`","id":"tohaveaccessiblename","depth":3,"charIndex":-1},{"text":"`toHaveProp()`","id":"tohaveprop","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":79,"title":"Accessibility","content":"#\n\n\nisHiddenFromAccessibility#\n\n\n\nAlso available as isInaccessible() alias for React Testing Library\ncompatibility.\n\nChecks if given element is hidden from assistive technology, e.g. screen\nreaders.\n\nNOTE\n\nLike isInaccessible function from DOM Testing Library this function considers\nboth accessibility elements and presentational elements (regular Views) to be\naccessible, unless they are hidden in terms of host platform.\n\nThis covers only part of ARIA notion of Accessiblity Tree, as ARIA excludes both\nhidden and presentational elements from the Accessibility Tree.\n\nFor the scope of this function, element is inaccessible when it, or any of its\nancestors, meets any of the following conditions:\n\n * it has display: none style\n * it has aria-hidden prop set to true\n * it has accessibilityElementsHidden prop set to true\n * it has importantForAccessibility prop set to no-hide-descendants\n * it has sibling host element with either aria-modal or\n   accessibilityViewIsModal prop set to true\n\nSpecifying accessible={false}, accessiblityRole=\"none\", or\nimportantForAccessibility=\"no\" props does not cause the element to become\ninaccessible.","routePath":"/react-native-testing-library/14.x/docs/api/misc/accessibility","lang":"","toc":[{"text":"`isHiddenFromAccessibility`","id":"ishiddenfromaccessibility","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":80,"title":"Async utilities","content":"#\n\n\nfindBy* queries#\n\nThe findBy* queries are used to find elements that are not instantly available\nbut will be added as a result of some asynchronous action. Learn more details\nhere.\n\n\nwaitFor#\n\n\n\nWaits for a period of time for the expectation callback to pass. waitFor may run\nthe callback a number of times until timeout is reached, as specified by the\ntimeout and interval options. The callback must throw an error when the\nexpectation is not met. Returning any value, including a falsy one, will be\ntreated as meeting the expectation, and the callback result will be returned to\nthe caller of waitFor function.\n\n\n\nwaitFor function will be executing expectation callback every interval (default:\nevery 50 ms) until timeout (default: 1000 ms) is reached. The repeated execution\nof callback is stopped as soon as it does not throw an error, in such case the\nvalue returned by the callback is returned to waitFor caller. Otherwise, when it\nreaches the timeout, the final error thrown by expectation will be re-thrown by\nwaitFor to the calling code.\n\n\n\nwaitFor is an async function so you need to await the result to pause test\nexecution.\n\n\n\nNOTE\n\nYou can enforce awaiting waitFor by using the await-async-utils rule from\neslint-plugin-testing-library.\n\nSince waitFor is likely to run expectation callback multiple times, it is highly\nrecommended for it not to perform any side effects in waitFor.\n\n\n\nNOTE\n\nAvoiding side effects in expectation callback can be partially enforced with the\nno-wait-for-side-effects rule.\n\nIt is also recommended to have a single assertion per each waitFor for more\nconsistency and faster failing tests. If you want to make several assertions,\nthen they should be in seperate waitFor calls. In many cases you won't actually\nneed to wrap the second assertion in waitFor since the first one will do the\nwaiting required for asynchronous change to happen.\n\nwaitFor checks whether Jest fake timers are enabled and adapts its behavior in\nsuch case. The following snippet is a simplified version of how it behaves when\nfake timers are enabled:\n\n\n\nIn the following example we test that a function is called after 10 seconds\nusing fake timers. Since we're using fake timers, the test won't depend on real\ntime passing and thus be much faster and more reliable. Also we don't have to\nadvance fake timers through Jest fake timers API because waitFor already does\nthis for us.\n\n\n\nNOTE\n\nIf you receive warnings related to act() function consult our Understanding Act\nfunction document.\n\n\nwaitForElementToBeRemoved#\n\n\n\nWaits for non-deterministic periods of time until queried element is removed or\ntimes out. waitForElementToBeRemoved periodically calls expectation every\ninterval milliseconds to determine whether the element has been removed or not.\n\n\n\nThis method expects that the element is initially present in the render tree and\nthen is removed from it. If the element is not present when you call this method\nit throws an error.\n\nYou can use any of getBy, getAllBy, queryBy and queryAllBy queries for\nexpectation parameter.\n\nNOTE\n\nIf you receive warnings related to act() function consult our Understanding Act\nfunction document.","routePath":"/react-native-testing-library/14.x/docs/api/misc/async","lang":"","toc":[{"text":"`findBy*` queries","id":"findby-queries","depth":2,"charIndex":-1},{"text":"`waitFor`","id":"waitfor","depth":2,"charIndex":-1},{"text":"`waitForElementToBeRemoved`","id":"waitforelementtoberemoved","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":81,"title":"Configuration","content":"#\n\n\nconfigure#\n\n\n\n\nasyncUtilTimeout option#\n\nDefault timeout, in ms, for async helper functions (waitFor,\nwaitForElementToBeRemoved) and findBy* queries. Defaults to 1000 ms.\n\n\ndefaultIncludeHiddenElements option#\n\nDefault value for includeHiddenElements query option for all queries. The\ndefault value is set to false, so all queries will not match elements hidden\nfrom accessibility. This is because the users of the app would not be able to\nsee such elements.\n\nThis option is also available as defaultHidden alias for compatibility with\nReact Testing Library.\n\n\ndefaultDebugOptions option#\n\nDefault debug options to be used when calling debug(). These default options\nwill be overridden by the ones you specify directly when calling debug().\n\n\nconcurrentRoot option #\n\nSet to false to disable concurrent rendering. Otherwise, render will default to\nusing concurrent rendering used in the React Native New Architecture.\n\n\nresetToDefaults()#\n\n\n\n\nEnvironment variables#\n\n\nRNTL_SKIP_AUTO_CLEANUP#\n\nSet to true to disable automatic cleanup() after each test. It works the same as\nimporting react-native-testing-library/dont-cleanup-after-each or using\nreact-native-testing-library/pure.\n\n\n\n\nRNTL_SKIP_AUTO_DETECT_FAKE_TIMERS#\n\nSet to true to disable auto-detection of fake timers. This might be useful in\nrare cases when you want to use non-Jest fake timers. See issue #886 for more\ndetails.\n\n","routePath":"/react-native-testing-library/14.x/docs/api/misc/config","lang":"","toc":[{"text":"`configure`","id":"configure","depth":2,"charIndex":-1},{"text":"`asyncUtilTimeout` option","id":"asyncutiltimeout-option","depth":3,"charIndex":-1},{"text":"`defaultIncludeHiddenElements` option","id":"defaultincludehiddenelements-option","depth":3,"charIndex":-1},{"text":"`defaultDebugOptions` option","id":"defaultdebugoptions-option","depth":3,"charIndex":-1},{"text":"`concurrentRoot` option","id":"concurrentroot-option","depth":3,"charIndex":-1},{"text":"`resetToDefaults()`","id":"resettodefaults","depth":2,"charIndex":-1},{"text":"Environment variables","id":"environment-variables","depth":2,"charIndex":946},{"text":"`RNTL_SKIP_AUTO_CLEANUP`","id":"rntl_skip_auto_cleanup","depth":3,"charIndex":-1},{"text":"`RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`","id":"rntl_skip_auto_detect_fake_timers","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":82,"title":"Other helpers","content":"#\n\n\nwithin, getQueriesForElement #\n\n\n\nwithin (also available as getQueriesForElement alias) performs queries scoped to\ngiven element.\n\nNOTE\n\nPlease note that additional render specific operations like update, unmount,\ndebug, toJSON are not included.\n\n\n\nUse cases for scoped queries include:\n\n * queries scoped to a single item inside a FlatList containing many items\n * queries scoped to a single screen in tests involving screen transitions (e.g.\n   with react-navigation)\n\n\nact#\n\n\n\nUseful function to help testing components that use hooks API. By default any\nrender, update, fireEvent, and waitFor calls are wrapped by this function, so\nthere is no need to wrap it manually.\n\nIn v14, act is now async by default and always returns a Promise, making it\ncompatible with React 19, React Suspense, and React.use(). This ensures all\npending React updates are executed before the Promise resolves.\n\n\n\nNote: Even if your callback is synchronous, you should still use await act(async\n() => ...) as act now always returns a Promise.\n\nConsult our Understanding Act function document for more understanding of its\nintricacies.\n\n\nunsafe_act#\n\n\n\n⚠️ Deprecated: This function is provided for migration purposes only. Use async\nact instead.\n\nThe synchronous version of act that maintains the same behavior as v13. It\nreturns immediately for sync callbacks or a thenable for async callbacks. This\nis not recommended for new code as it doesn't work well with React 19's async\nfeatures.\n\n\n\n\ncleanup#\n\n\n\nUnmounts React trees that were mounted with render and clears screen variable\nthat holds latest render output.\n\nINFO\n\nPlease note that this is done automatically if the testing framework you're\nusing supports the afterEach global (like mocha, Jest, and Jasmine). If not, you\nwill need to do manual cleanups after each test.\n\nFor example, if you're using the jest testing framework, then you would need to\nuse the afterEach hook like so:\n\n\n\nThe afterEach(cleanup) call also works in describe blocks:\n\n\n\nFailing to call cleanup when you've called render could result in a memory leak\nand tests which are not \"idempotent\" (which can lead to difficult to debug\nerrors in your tests).","routePath":"/react-native-testing-library/14.x/docs/api/misc/other","lang":"","toc":[{"text":"`within`, `getQueriesForElement`","id":"within-getqueriesforelement","depth":2,"charIndex":-1},{"text":"`act`","id":"act","depth":2,"charIndex":-1},{"text":"`unsafe_act`","id":"unsafe_act","depth":2,"charIndex":-1},{"text":"`cleanup`","id":"cleanup","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":83,"title":"`renderHook` function","content":"renderHook function#\n\n\nrenderHook#\n\n\n\nRenders a test component that will call the provided callback, including any\nhooks it calls, every time it renders. Returns a Promise that resolves to a\nRenderHookResult object, which you can interact with.\n\nThis is the recommended default API for testing hooks. It uses async act\ninternally to ensure all pending React updates are executed during rendering,\nmaking it compatible with React 19, React Suspense, and React.use().\n\n * Returns a Promise: Should be awaited\n * Async methods: Both rerender and unmount return Promises and should be\n   awaited\n * Suspense support: Compatible with React Suspense boundaries and React.use()\n\n\n\n\n\nThe renderHook function accepts the following arguments:\n\nCallback is a function that is called each render of the test component. This\nfunction should call one or more hooks for testing.\n\nThe props passed into the callback will be the initialProps provided in the\noptions to renderHook, unless new props are provided by a subsequent rerender\ncall.\n\n\noptions#\n\nA RenderHookOptions<Props> object to modify the execution of the callback\nfunction, containing the following properties:\n\ninitialProps #\n\nThe initial values to pass as props to the callback function of renderHook. The\nProps type is determined by the type passed to or inferred by the renderHook\ncall.\n\nwrapper#\n\nA React component to wrap the test component in when rendering. This is usually\nused to add context providers from React.createContext for the hook to access\nwith useContext.\n\n\nResult#\n\n\n\nThe renderHook function returns a Promise that resolves to an object with the\nfollowing properties:\n\nresult#\n\nThe current value of the result will reflect the latest of whatever is returned\nfrom the callback passed to renderHook. The Result type is determined by the\ntype passed to or inferred by the renderHook call.\n\nrerender#\n\nAn async function to rerender the test component, causing any hooks to be\nrecalculated. If newProps are passed, they will replace the callback function's\ninitialProps for subsequent rerenders. The Props type is determined by the type\npassed to or inferred by the renderHook call.\n\nNote: This method returns a Promise and should be awaited.\n\nunmount#\n\nAn async function to unmount the test component. This is commonly used to\ntrigger cleanup effects for useEffect hooks.\n\nNote: This method returns a Promise and should be awaited.\n\n\nExamples#\n\nHere we present some extra examples of using renderHook API.\n\nWith initialProps#\n\n\n\nWith wrapper#\n\n\n\nWith React Suspense#\n\n\n\n\nMigration from v13#\n\nIf you're migrating from React Native Testing Library v13, you may have existing\ntests using the synchronous renderHook API. To ease migration, we provide\nunsafe_renderHookSync which maintains the same synchronous behavior.\n\n⚠️ Deprecated: unsafe_renderHookSync is provided for migration purposes only.\nUse async renderHook instead.\n\nFor detailed migration instructions, see the v14 migration guide.","routePath":"/react-native-testing-library/14.x/docs/api/misc/render-hook","lang":"","toc":[{"text":"`renderHook`","id":"renderhook","depth":2,"charIndex":-1},{"text":"`options`","id":"options","depth":3,"charIndex":-1},{"text":"`initialProps`","id":"initialprops","depth":4,"charIndex":-1},{"text":"`wrapper`","id":"wrapper","depth":4,"charIndex":-1},{"text":"Result","id":"result","depth":3,"charIndex":1525},{"text":"`result`","id":"result-1","depth":4,"charIndex":-1},{"text":"`rerender`","id":"rerender","depth":4,"charIndex":-1},{"text":"`unmount`","id":"unmount","depth":4,"charIndex":-1},{"text":"Examples","id":"examples","depth":3,"charIndex":2398},{"text":"With `initialProps`","id":"with-initialprops","depth":4,"charIndex":-1},{"text":"With `wrapper`","id":"with-wrapper","depth":4,"charIndex":-1},{"text":"With React Suspense","id":"with-react-suspense","depth":4,"charIndex":2510},{"text":"Migration from v13","id":"migration-from-v13","depth":2,"charIndex":2535}],"domain":"","frontmatter":{},"version":"14.x"},{"id":84,"title":"Queries","content":"#\n\nQueries are one of the main building blocks for the React Native Testing\nLibrary. They enable you to find relevant elements in the element tree, which\nrepresents your application's user interface when running under tests.\n\n\nAccessing queries#\n\nAll queries described below are accessible in two main ways: through the screen\nobject or by capturing the render function call result.\n\n\nUsing screen object#\n\n\n\nThe modern and recommended way of accessing queries is to use the screen object\nexported by the @testing-library/react-native package. This object will contain\nmethods of all available queries bound to the most recently rendered UI.\n\n\nUsing render result#\n\n\n\nThe classic way is to capture query functions, as they are returned from the\nrender function call. This provides access to the same functions as in the case\nof the screen object.\n\n\nQuery parts#\n\nEach query is composed of two parts: variant and predicate, which are separated\nby the by word in the middle of the name.\n\nConsider the following query:\n\n\n\nFor this query, getBy* is the query variant, and *ByRole is the predicate.\n\n\nQuery variant#\n\nThe query variants describe the expected number (and timing) of matching\nelements, so they differ in their return type.\n\nVARIANT       ASSERTION                       RETURN TYPE                   IS ASYNC?\ngetBy*        Exactly one matching element    HostElement                   No\ngetAllBy*     At least one matching element   Array<HostElement>            No\nqueryBy*      Zero or one matching element                                  No\nqueryAllBy*   No assertion                    Array<HostElement>            No\nfindBy*       Exactly one matching element    Promise<HostElement>          Yes\nfindAllBy*    At least one matching element   Promise<Array<HostElement>>   Yes\n\nQueries work as implicit assertions on the number of matching elements and will\nthrow an error when the assertion fails.\n\n\ngetBy* queries #\n\n\n\ngetBy* queries return the single matching element for a query, and throw an\nerror if no elements match or if more than one match is found. If you need to\nfind more than one element, then use getAllBy.\n\n\ngetAllBy* queries #\n\n\n\ngetAllBy* queries return an array of all matching elements for a query and throw\nan error if no elements match.\n\n\nqueryBy* queries #\n\n\n\nqueryBy* queries return the first matching node for a query, and return null if\nno elements match. This is useful for asserting an element that is not present.\nThis throws if more than one match is found (use queryAllBy instead).\n\n\nqueryAllBy* queries #\n\n\n\nqueryAllBy* queries return an array of all matching nodes for a query and return\nan empty array ([]) when no elements match.\n\n\nfindBy* queries #\n\n\n\nfindBy* queries return a promise which resolves when a matching element is\nfound. The promise is rejected if no elements match or if more than one match is\nfound after a default timeout of 1000 ms. If you need to find more than one\nelement use findAllBy* queries.\n\n\nfindAllBy* queries #\n\n\n\nfindAllBy* queries return a promise which resolves to an array of matching\nelements. The promise is rejected if no elements match after a default timeout\nof 1000 ms.\n\nINFO\n\nfindBy* and findAllBy* queries accept optional waitForOptions object arguments,\nwhich can contain timeout, interval and onTimeout properties which have the same\nmeaning as respective options for waitFor function.\n\nINFO\n\nIn cases when your findBy* and findAllBy* queries throw when unable to find\nmatching elements, it is helpful to pass onTimeout: () => { screen.debug(); }\ncallback using the waitForOptions parameter.\n\n\nQuery predicates#\n\nNote: most methods like this one return a HostElement with following properties\nthat you may be interested in:\n\n\n\n\n*ByRole #\n\n> getByRole, getAllByRole, queryByRole, queryAllByRole, findByRole,\n> findAllByRole\n\n\n\nReturns a HostElement with matching role or accessibilityRole prop.\n\nINFO\n\nIn order for *ByRole queries to match an element it needs to be considered an\naccessibility element:\n\n 1. Text, TextInput and Switch host elements are these by default.\n 2. View host elements need an explicit accessible prop set to true\n 3. Some React Native composite components like Pressable & TouchableOpacity\n    render host View element with accessible prop already set.\n\n\n\nOptions #\n\n * name: Finds an element with given role/accessibilityRole and an accessible\n   name (= accessability label or text content).\n\n * disabled: You can filter elements by their disabled state (coming either from\n   aria-disabled prop or accessbilityState.disabled prop). The possible values\n   are true or false. Querying disabled: false will also match elements with\n   disabled: undefined (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the disabled\n     state.\n   * This option can alternatively be expressed using the toBeEnabled() /\n     toBeDisabled() Jest matchers.\n\n * selected: You can filter elements by their selected state (coming either from\n   aria-selected prop or accessbilityState.selected prop). The possible values\n   are true or false. Querying selected: false will also match elements with\n   selected: undefined (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the selected\n     state.\n   * This option can alternatively be expressed using the toBeSelected() Jest\n     matcher.\n\n * checked: You can filter elements by their checked state (coming either from\n   aria-checked prop or accessbilityState.checked prop). The possible values are\n   true, false, or \"mixed\".\n   \n   * See React Native's accessibilityState docs to learn more about the checked\n     state.\n   * This option can alternatively be expressed using the toBeChecked() /\n     toBePartiallyChecked() Jest matchers.\n\n * busy: You can filter elements by their busy state (coming either from\n   aria-busy prop or accessbilityState.busy prop). The possible values are true\n   or false. Querying busy: false will also match elements with busy: undefined\n   (see the wiki for more details).\n   \n   * See React Native's accessibilityState docs to learn more about the busy\n     state.\n   * This option can alternatively be expressed using the toBeBusy() Jest\n     matcher.\n\n * expanded: You can filter elements by their expanded state (coming either from\n   aria-expanded prop or accessbilityState.expanded prop). The possible values\n   are true or false.\n   \n   * See React Native's accessibilityState docs to learn more about the expanded\n     state.\n   * This option can alternatively be expressed using the toBeExpanded() /\n     toBeCollapsed() Jest matchers.\n\n * value: Filter elements by their accessibility value, based on either\n   aria-valuemin, aria-valuemax, aria-valuenow, aria-valuetext or\n   accessibilityValue props. Accessiblity value conceptually consists of numeric\n   min, max and now entries, as well as string text entry.\n   \n   * See React Native accessibilityValue docs to learn more about the\n     accessibility value concept.\n   * This option can alternatively be expressed using the\n     toHaveAccessibilityValue() Jest matcher.\n\n\n*ByLabelText #\n\n> getByLabelText, getAllByLabelText, queryByLabelText, queryAllByLabelText,\n> findByLabelText, findAllByLabelText\n\n\n\nReturns a HostElement with matching label:\n\n * either by matching aria-label/accessibilityLabel prop\n * or by matching text content of view referenced by\n   aria-labelledby/accessibilityLabelledBy prop\n\n\n\n\n*ByPlaceholderText #\n\n> getByPlaceholderText, getAllByPlaceholderText, queryByPlaceholderText,\n> queryAllByPlaceholderText, findByPlaceholderText, findAllByPlaceholderText\n\n\n\nReturns a HostElement for a TextInput with a matching placeholder – may be a\nstring or regular expression.\n\n\n\n\n*ByDisplayValue #\n\n> getByDisplayValue, getAllByDisplayValue, queryByDisplayValue,\n> queryAllByDisplayValue, findByDisplayValue, findAllByDisplayValue\n\n\n\nReturns a HostElement for a TextInput with a matching display value – may be a\nstring or regular expression.\n\n\n\n\n*ByText #\n\n> getByText, getAllByText, queryByText, queryAllByText, findByText,\n> findAllByText\n\n\n\nReturns a HostElement with matching text – may be a string or regular\nexpression.\n\nThis method will join <Text> siblings to find matches, similarly to how React\nNative handles these components. This will allow for querying for strings that\nwill be visually rendered together, but may be semantically separate React\ncomponents.\n\n\n\n\n*ByHintText #\n\n> getByA11yHint, getAllByA11yHint, queryByA11yHint, queryAllByA11yHint,\n> findByA11yHint, findAllByA11yHint getByAccessibilityHint,\n> getAllByAccessibilityHint, queryByAccessibilityHint,\n> queryAllByAccessibilityHint, findByAccessibilityHint,\n> findAllByAccessibilityHint getByHintText, getAllByHintText, queryByHintText,\n> queryAllByHintText, findByHintText, findAllByHintText\n\n\n\nReturns a HostElement with matching accessibilityHint prop.\n\n\n\nINFO\n\nPlease consult Apple guidelines on how accessibilityHint should be used.\n\n\n*ByTestId #\n\n> getByTestId, getAllByTestId, queryByTestId, queryAllByTestId, findByTestId,\n> findAllByTestId\n\n\n\nReturns a HostElement with matching testID prop. testID – may be a string or a\nregular expression.\n\n\n\nINFO\n\nIn the spirit of the guiding principles, it is recommended to use this only\nafter the other queries don't work for your use case. Using testID attributes do\nnot resemble how your software is used and should be avoided if possible.\nHowever, they are particularly useful for end-to-end testing on real devices,\ne.g. using Detox and it's an encouraged technique to use there. Learn more from\nthe blog post \"Making your UI tests resilient to change\".\n\n\nCommon options#\n\nUsually query first argument can be a string or a regex. All queries take at\nleast the hidden option as an optionnal second argument and some queries accept\nmore options which change string matching behaviour. See TextMatch for more\ninfo.\n\nincludeHiddenElements option#\n\nAll queries have the includeHiddenElements option which affects whether elements\nhidden from accessibility are matched by the query. By default queries will not\nmatch hidden elements, because the users of the app would not be able to see\nsuch elements.\n\nYou can configure the default value with the configure function.\n\nThis option is also available as hidden alias for compatibility with React\nTesting Library.\n\nExamples\n\n\n\n\nTextMatch type#\n\n\n\nMost of the query APIs take a TextMatch as an argument, which means the argument\ncan be either a string or regex.\n\n\nExamples#\n\nGiven the following render:\n\n\n\nWill find a match:\n\n\n\nWill NOT find a match\n\n\n\n\nOptions #\n\nPrecision#\n\n\n\nQueries that take a TextMatch also accept an object as the second argument that\ncan contain options that affect the precision of string matching:\n\n * exact: Defaults to true; matches full strings, case-sensitive. When false,\n   matches substrings and is not case-sensitive.\n   * exact has no effect on regex argument.\n   * In most cases using a regex instead of a string gives you more control over\n     fuzzy matching and should be preferred over { exact: false }.\n * normalizer: An optional function which overrides normalization behavior. See\n   Normalization.\n\nexact option defaults to true but if you want to search for a text slice or make\ntext matching case-insensitive you can override it. That being said we advise\nyou to use regex in more complex scenarios.\n\nNormalization#\n\nBefore running any matching logic against text, it is automatically normalized.\nBy default, normalization consists of trimming whitespace from the start and end\nof text, and collapsing multiple adjacent whitespace characters into a single\nspace.\n\nIf you want to prevent that normalization, or provide alternative normalization\n(e.g. to remove Unicode control characters), you can provide a normalizer\nfunction in the options object. This function will be given a string and is\nexpected to return a normalized version of that string.\n\nINFO\n\nSpecifying a value for normalizer replaces the built-in normalization, but you\ncan call getDefaultNormalizer to obtain a built-in normalizer, either to adjust\nthat normalization or to call it from your own normalizer.\n\ngetDefaultNormalizer take options object which allows the selection of\nbehaviour:\n\n * trim: Defaults to true. Trims leading and trailing whitespace.\n * collapseWhitespace: Defaults to true. Collapses inner whitespace (newlines,\n   tabs repeated spaces) into a single space.\n\nNormalization Examples#\n\nTo perform a match against text without trimming:\n\n\n\nTo override normalization to remove some Unicode characters whilst keeping some\n(but not all) of the built-in normalization behavior:\n\n\n\n\nLegacy unit testing helpers#\n\nrender from @testing-library/react-native exposes additional queries that should\nnot be used in integration or component testing, but some users (like component\nlibrary creators) interested in unit testing some components may find helpful.\n\nThe interface is the same as for other queries, but we won't provide full names\nso that they're harder to find by search engines.\n\n\nUNSAFE_ByType#\n\n> UNSAFE_getByType, UNSAFE_getAllByType, UNSAFE_queryByType,\n> UNSAFE_queryAllByType\n\nReturns a HostElement with matching a React component type.\n\nCAUTION\n\nThis query has been marked unsafe, since it requires knowledge about\nimplementation details of the component. Use responsibly.\n\n\nUNSAFE_ByProps#\n\n> UNSAFE_getByProps, UNSAFE_getAllByProps, UNSAFE_queryByProps,\n> UNSAFE_queryAllByProps\n\nReturns a HostElement with matching props object.\n\nCAUTION\n\nThis query has been marked unsafe, since it requires knowledge about\nimplementation details of the component. Use responsibly.","routePath":"/react-native-testing-library/14.x/docs/api/queries","lang":"","toc":[{"text":"Accessing queries","id":"accessing-queries","depth":2,"charIndex":226},{"text":"Using `screen` object","id":"using-screen-object","depth":3,"charIndex":-1},{"text":"Using `render` result","id":"using-render-result","depth":3,"charIndex":-1},{"text":"Query parts","id":"query-parts","depth":2,"charIndex":848},{"text":"Query variant","id":"query-variant","depth":2,"charIndex":1095},{"text":"`getBy*` queries","id":"getby-queries","depth":3,"charIndex":-1},{"text":"`getAllBy*` queries","id":"getallby-queries","depth":3,"charIndex":-1},{"text":"`queryBy*` queries","id":"queryby-queries","depth":3,"charIndex":-1},{"text":"`queryAllBy*` queries","id":"queryallby-queries","depth":3,"charIndex":-1},{"text":"`findBy*` queries","id":"findby-queries","depth":3,"charIndex":-1},{"text":"`findAllBy*` queries","id":"findallby-queries","depth":3,"charIndex":-1},{"text":"Query predicates","id":"query-predicates","depth":2,"charIndex":3589},{"text":"`*ByRole`","id":"byrole","depth":3,"charIndex":-1},{"text":"Options","id":"options","depth":4,"charIndex":-1},{"text":"`*ByLabelText`","id":"bylabeltext","depth":3,"charIndex":-1},{"text":"`*ByPlaceholderText`","id":"byplaceholdertext","depth":3,"charIndex":-1},{"text":"`*ByDisplayValue`","id":"bydisplayvalue","depth":3,"charIndex":-1},{"text":"`*ByText`","id":"bytext","depth":3,"charIndex":-1},{"text":"`*ByHintText`","id":"byhinttext","depth":3,"charIndex":-1},{"text":"`*ByTestId`","id":"bytestid","depth":3,"charIndex":-1},{"text":"Common options","id":"common-options","depth":3,"charIndex":9664},{"text":"`includeHiddenElements` option","id":"includehiddenelements-option","depth":4,"charIndex":-1},{"text":"TextMatch type","id":"textmatch-type","depth":2,"charIndex":10378},{"text":"Examples","id":"examples","depth":3,"charIndex":10513},{"text":"Options","id":"options-1","depth":3,"charIndex":-1},{"text":"Precision","id":"precision","depth":4,"charIndex":10614},{"text":"Normalization","id":"normalization","depth":4,"charIndex":11397},{"text":"Legacy unit testing helpers","id":"legacy-unit-testing-helpers","depth":2,"charIndex":12663},{"text":"`UNSAFE_ByType`","id":"unsafe_bytype","depth":3,"charIndex":-1},{"text":"`UNSAFE_ByProps`","id":"unsafe_byprops","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":85,"title":"`render` API","content":"render API#\n\n\nrender function #\n\n\n\nThe render function is the entry point for writing React Native Testing Library\ntests. It deeply renders the given React element and returns helpers to query\nthe output components' structure. This function is async by default and uses\nasync act internally to ensure all pending React updates are executed during\nrendering, making it compatible with React 19, React Suspense, and React.use().\n\n\n\n> When using React context providers, like Redux Provider, you'll likely want to\n> wrap rendered component with them. In such cases, it's convenient to create\n> your own custom render method. Follow this great guide on how to set this up.\n\n\nOptions#\n\nThe behavior of the render method can be customized by passing various options\nas a second argument of the RenderOptions type:\n\nwrapper#\n\n\n\nThis option allows you to wrap the tested component, passed as the first option\nto the render() function, in an additional wrapper component. This is useful for\ncreating reusable custom render functions for common React Context providers.\n\nconcurrentRoot #\n\nSet to false to disable concurrent rendering. Otherwise, render will default to\nusing concurrent rendering used in the React Native New Architecture.\n\ncreateNodeMock #\n\n\n\nThis option allows you to pass createNodeMock option to the renderer's create()\nmethod in order to allow for custom mock refs. This option is passed through to\nTest Renderer.\n\nText string validation\n\nTest Renderer automatically enforces React Native's requirement that text\nstrings must be rendered within a <Text> component. If you try to render a\nstring value under components other than <Text> (e.g., under <View>), it will\nthrow an Invariant Violation: Text strings must be rendered within a <Text>\ncomponent error, matching React Native's runtime behavior.\n\nThis validation is always enabled and cannot be disabled, ensuring your tests\naccurately reflect how your code will behave in production.\n\n\nResult#\n\nThe render function returns a promise that resolves to the same queries and\nutilities as the screen object. We recommend using the screen object for queries\nand the lifecycle methods from the render result when needed.\n\nSee this article from Kent C. Dodds for more details.\n\nAsync lifecycle methods\n\nWhen using render, the lifecycle methods rerender, update, and unmount are async\nand must be awaited.\n\n\nunsafe_renderSync function #\n\nDeprecated\n\nThis function is deprecated and provided for migration purposes only. Use async\nrender instead.\n\n\n\nThe unsafe_renderSync function is the synchronous version of render. It was the\ndefault render function in previous versions but is now deprecated in favor of\nthe async render function.\n\n\n\n\nOptions#\n\nunsafe_renderSync accepts the same options as render.\n\n\nResult#\n\nThe unsafe_renderSync function returns the same queries and utilities as the\nscreen object. We recommended using the screen object as more developer-friendly\nway.\n\nMigration\n\nTo migrate from unsafe_renderSync to render, see the migration guide.","routePath":"/react-native-testing-library/14.x/docs/api/render","lang":"","toc":[{"text":"`render` function","id":"render-function","depth":2,"charIndex":-1},{"text":"Options","id":"options","depth":3,"charIndex":670},{"text":"`wrapper`","id":"wrapper","depth":4,"charIndex":-1},{"text":"`concurrentRoot`","id":"concurrentroot","depth":4,"charIndex":-1},{"text":"`createNodeMock`","id":"createnodemock","depth":4,"charIndex":-1},{"text":"Result","id":"result","depth":3,"charIndex":1952},{"text":"`unsafe_renderSync` function","id":"unsafe_rendersync-function","depth":2,"charIndex":-1},{"text":"Options","id":"options-1","depth":3,"charIndex":2696},{"text":"Result","id":"result-1","depth":3,"charIndex":2762}],"domain":"","frontmatter":{},"version":"14.x"},{"id":86,"title":"`screen` object","content":"screen object#\n\n\n\nThe screen object offers a recommended way to access queries and utilities for\nthe currently rendered UI.\n\nThis object is assigned after the render call and cleared after each test by\ncalling cleanup. If no render call has been made in a given test, then it holds\na special object and throws a helpful error on each property and method access.\n\n\n...queries#\n\nThe most important feature of screen is providing a set of helpful queries that\nallow you to find certain elements in the view hierarchy.\n\nSee Queries for a complete list.\n\nExample#\n\n\n\n\nrerender#\n\nAlso available under update alias\n\n\n\nRe-render the in-memory tree with a new root element. This simulates a React\nupdate render at the root. If the new element has the same type (and key) as the\nprevious element, the tree will be updated; otherwise, it will re-mount a new\ntree, in both cases triggering the appropriate lifecycle events.\n\nThis method is async and uses async act function internally to ensure all\npending React updates are executed during updating, making it compatible with\nReact 19, React Suspense, and React.use().\n\n\n\n\nunmount#\n\n\n\nUnmount the in-memory tree, triggering the appropriate lifecycle events.\n\nThis method is async and uses async act function internally to ensure all\npending React updates are executed during unmounting, making it compatible with\nReact 19, React Suspense, and React.use().\n\nNOTE\n\nUsually you should not need to call unmount as it is done automatically if your\ntest runner supports afterEach hook (like Jest, mocha, Jasmine).\n\n\ndebug#\n\n\n\nPretty prints deeply rendered component passed to render.\n\nmessage option #\n\nYou can provide a message that will be printed on top.\n\n\n\nlogs optional message and colored JSX:\n\n\n\nmapProps option #\n\n\n\nYou can use the mapProps option to transform the props that will be printed :\n\n\n\nThis will log the rendered JSX without the style props.\n\nThe children prop cannot be filtered out so the following will print all\nrendered components with all props but children filtered out.\n\nThis option can be used to target specific props when debugging a query (for\ninstance, keeping only the children prop when debugging a getByText query).\n\nYou can also transform prop values so that they are more readable (e.g., flatten\nstyles).\n\n\n\nOr remove props that have little value when debugging tests, e.g. path prop for\nsvgs\n\n\n\n\ntoJSON#\n\n\n\nGet the rendered component JSON representation, e.g. for snapshot testing.\n\n\ncontainer#\n\n\n\nReturns a pseudo-element container whose children are the elements you asked to\nrender. This is the root container element from Test Renderer.\n\nThe container is safe to use and provides access to the entire rendered tree.\nIt's useful when you need to query or manipulate the entire rendered output,\nsimilar to how container works in React Testing Library.\n\n\n\n\nroot#\n\n\n\nReturns the rendered root host element. This is the first child of the\ncontainer, which represents the actual root element you rendered.\n\nThis API is primarily useful for component tests, as it allows you to access\nroot host view without using *ByTestId queries or similar methods.\n\n","routePath":"/react-native-testing-library/14.x/docs/api/screen","lang":"","toc":[{"text":"`...queries`","id":"queries","depth":3,"charIndex":-1},{"text":"Example","id":"example","depth":4,"charIndex":549},{"text":"`rerender`","id":"rerender","depth":3,"charIndex":-1},{"text":"`unmount`","id":"unmount","depth":3,"charIndex":-1},{"text":"`debug`","id":"debug","depth":3,"charIndex":-1},{"text":"`message` option","id":"message-option","depth":4,"charIndex":-1},{"text":"`mapProps` option","id":"mapprops-option","depth":4,"charIndex":-1},{"text":"`toJSON`","id":"tojson","depth":3,"charIndex":-1},{"text":"`container`","id":"container","depth":3,"charIndex":-1},{"text":"`root`","id":"root","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":87,"title":"Community resources","content":"#\n\n\nRecommended content#\n\n * The Testing Trophy and Testing Classifications by Kent C. Dodds (2021) -\n   classic article explaining testing philosophy behind all Testing Library\n   implementations.\n * Common mistakes with React Testing Library by Kent C. Dodds (2020) - classic\n   article explaining React Testing Library best practices, highly applicable to\n   RNTL as well.\n * React Native — UI Testing (Ultimate Guide) by Anisur Rahman - comprehensive\n   guide to RNTL testing\n * React Native Testing examples repo by Steve Galili - extensive repo with RN\n   testing examples for RNTL and Maestro\n\n\nOlder, potentially outdated content#\n\n * Where and how to start testing 🧪 your react-native app ⚛️ and how to keep on\n   testin’ by Steve Galili (2020) - article referencing Steve's examples repo.\n * Intro to React Native Testing Library & Jest Native by Alireza Ghamkhar\n   (2020) - video tutorial on RNTL setup and testing.","routePath":"/react-native-testing-library/14.x/docs/guides/community-resources","lang":"","toc":[{"text":"Recommended content","id":"recommended-content","depth":2,"charIndex":3},{"text":"Older, potentially outdated content","id":"older-potentially-outdated-content","depth":2,"charIndex":601}],"domain":"","frontmatter":{},"version":"14.x"},{"id":88,"title":"FAQ","content":"#\n\n\nCan I test the native features of React Native apps?#\n\nShort answer: no.\n\nReact Native Testing Library does not provide an entire React Native runtime\nsince that would require running on a physical device or iOS simulator/Android\nemulator to provision the underlying OS and platform APIs.\n\nInstead of using React Native renderer, it simulates only the JavaScript part of\nits runtime using Test Renderer while providing queries and event APIs (User\nEvent, Fire Event) that mimicking certain behaviors from the actual runtime.\n\nYou can learn more about our testing environment here.\n\nThis approach has specific benefits and shortfalls. On the positive side:\n\n * it allows testing most of the logic of regular React Native apps\n * it allows running tests on any OS supported by Jest or other test runners,\n   e.g., on CI\n * it uses much less resources than full runtime simulation\n * you can use Jest fake timers\n\nOn the negative side:\n\n * you cannot test native features\n * it might not perfectly simulate certain JavaScript features, but we are\n   working on it\n\nThe User Event interactions solve some of the simulation issues, as they offer\nmore realistic event handling than the basic Fire Event API.\n\n\nShould I use/migrate to screen queries?#\n\nThere is no need to migrate existing test code to use screen-bases queries. You\ncan still use queries and other functions returned by render. The screen object\ncaptures the latest render result.\n\nFor new code, you are encouraged to use screen as there are some good reasons\nfor that, which are described in this article by Kent C. Dodds.\n\n\nShould I use/migrate to User Event interactions?#\n\nWe encourage you to migrate existing tests to use the User Event interactions,\nwhich offer more realistic event handling than the basic Fire Event API. Hence,\nit will provide more confidence in the quality of your code.","routePath":"/react-native-testing-library/14.x/docs/guides/faq","lang":"","toc":[{"text":"Can I test the native features of React Native apps?","id":"can-i-test-the-native-features-of-react-native-apps","depth":2,"charIndex":3},{"text":"Should I use/migrate to `screen` queries?","id":"should-i-usemigrate-to-screen-queries","depth":2,"charIndex":-1},{"text":"Should I use/migrate to User Event interactions?","id":"should-i-usemigrate-to-user-event-interactions","depth":2,"charIndex":1589}],"domain":"","frontmatter":{},"version":"14.x"},{"id":89,"title":"How should I query?","content":"#\n\nReact Native Testing Library provides various query types, allowing great\nflexibility in finding views appropriate for your tests. At the same time, the\nnumber of queries might be confusing. This guide aims to help you pick the\ncorrect queries for your test scenarios.\n\n\nQuery parts#\n\nEach query is composed of two parts: variant and predicate, which are separated\nby the by word in the middle of the query.\n\nConsider the following query:\n\n\n\nFor this query, getBy* is the query variant, and *ByRole is the predicate.\n\n\nQuery variant#\n\nThe query variants describe the expected number (and timing) of matching\nelements, so they differ in their return type.\n\nVARIANT       ASSERTION                       RETURN TYPE                   IS ASYNC?\ngetBy*        Exactly one matching element    HostElement                   No\ngetAllBy*     At least one matching element   Array<HostElement>            No\nqueryBy*      Zero or one matching element                                  No\nqueryAllBy*   No assertion                    Array<HostElement>            No\nfindBy*       Exactly one matching element    Promise<HostElement>          Yes\nfindAllBy*    At least one matching element   Promise<Array<HostElement>>   Yes\n\nQueries work as implicit assertions on the number of matching elements and will\nthrow an error when the assertion fails.\n\n\nIdiomatic query variants#\n\nIdiomatic query variants clarify test intent and the expected number of matching\nelements. They will also throw helpful errors if assertions fail to help\ndiagnose the issues.\n\nHere are general guidelines for picking idiomatic query variants:\n\n 1. Use getBy* in the most common case when you expect a single matching\n    element. Use other queries only in more specific cases.\n 2. Use findBy* when an element is not yet in the element tree, but you expect\n    it to be there as a result of some asynchronous action.\n 3. Use getAllBy* (and findAllBy* for async) if you expect more than one\n    matching element, e.g. in a list.\n 4. Use queryBy* only when element should not exist to use it together with e.g.\n    not.toBeOnTheScreen() matcher.\n\nAvoid using queryAllBy* in regular tests, as it provides no assertions on the\nnumber of matching elements. You may still find it useful when building reusable\ncustom testing tools.\n\n\nQuery predicate#\n\nThe query predicate describes how you decide whether to match the given element.\n\nPREDICATE            SUPPORTED ELEMENTS   INSPECTED PROPS\n*ByRole              all host elements    role, accessibilityRole, optional: accessible name,\n                                          accessibility state and value\n*ByLabelText         all host elements    aria-label, aria-labelledby, accessibilityLabel,\n                                          accessibilityLabelledBy\n*ByDisplayValue      TextInput            value, defaultValue\n*ByPlaceholderText   TextInput            placeholder\n*ByText              Text                 children (text content)\n*ByHintText          all host elements    accessibilityHint\n*ByTestId            all host elements    testID\n\n\nIdiomatic query predicates#\n\nChoosing the proper query predicate helps better express the test's intent and\nmake the tests resemble how users interact with your code (components, screens,\netc.) as much as possible following our Guiding Principles. Additionally, most\npredicates promote the usage of proper accessibility props, which add a semantic\nlayer on top of an element tree composed primarily of View elements.\n\nIt is recommended to use query predicates in the following order of priority:\n\n\n1. By Role query #\n\nThe first and most versatile predicate is *ByRole, which starts with the\nsemantic role of the element and can be further narrowed down with additional\noptions. React Native has two role systems, the web/ARIA-compatible one based on\nrole prop and the traditional one based on accessibilityRole prop, you can use\neither of these.\n\nIn most cases, you need to set accessibility roles explicitly (or your component\nlibrary can set some of them for you). These roles allow assistive technologies\n(like screen readers) and testing code to understand your view hierarchy better.\n\nSome frequently used roles include:\n\n * alert - important text to be presented to the user, e.g., error message\n * button\n * checkbox & switch - on/off controls\n * heading (header) - header for content section, e.g., the title of navigation\n   bar\n * img (image)\n * link\n * menu & menuitem\n * progressbar\n * radiogroup & radio\n * searchbox (search)\n * slider (adjustable)\n * summary\n * tablist & tab\n * text - static text that cannot change\n * toolbar - container for action buttons\n\nName option #\n\nFrequently, you will want to add the name option, which will match both the\nelement's role and its accessible name (= element's accessibility label or text\ncontent).\n\nHere are a couple of examples:\n\n * start button: getByRole(\"button\", { name: \"Start\" })\n * silent mode switch: getByRole(\"switch\", { name: \"Silent Mode\" })\n * screen header: getByRole(\"header\", { name: \"Settings\" })\n * undo menu item: getByRole(\"menuitem\", { name: \"Undo\" })\n * error messages: getByRole(\"alert\", { name: /Not logged in/ })\n\n\n2. Text input queries #\n\nQuerying TextInput elements presents a unique challenge as there is no separate\nrole for TextInput elements. There is a searchbox/search role, which can be\nassigned to TextInput, but it should be only used in the context of search\ninputs, leaving other text inputs without a role to query with.\n\nTherefore, you can use the following queries to find relevant text inputs:\n\n 1. *ByLabelText - will match the accessibility label of the element. This query\n    will match any host elements, including TextInput elements.\n 2. *ByPlaceholderText - will match the placeholder of TextInput element. This\n    query will match only TextInput elements.\n 3. *ByDisplayValue - will the current (or default) value of TextInput element.\n    This query will match only TextInput elements.\n\n\n3. Other accessible queries #\n\nThese queries reflect the apps' user experience, both visual and through\nassistive technologies (e.g. screen reader).\n\nThese queries include:\n\n * *ByText - will match the text content of the element. This query will match\n   only Text elements.\n * *ByLabelText - will match the accessibility label of the element.\n * *ByHintText - will match the accessibility hint of the element.\n\n\n4. Test ID query #\n\nAs a final predicate, you can use the testID prop to find relevant views. Using\nthe *ByTestId predicate offers the most flexibility, but at the same time, it\ndoes not represent the user experience, as users are not aware of test IDs.\n\nNote that using test IDs is a widespread technique in end-to-end testing due to\nvarious issues with querying views through other means in its specific context.\nNevertheless, we still encourage you to use recommended RNTL queries as it will\nmake your integration and component test more reliable and resilient.","routePath":"/react-native-testing-library/14.x/docs/guides/how-to-query","lang":"","toc":[{"text":"Query parts","id":"query-parts","depth":2,"charIndex":273},{"text":"Query variant","id":"query-variant","depth":2,"charIndex":521},{"text":"Idiomatic query variants","id":"idiomatic-query-variants","depth":3,"charIndex":1344},{"text":"Query predicate","id":"query-predicate","depth":2,"charIndex":2297},{"text":"Idiomatic query predicates","id":"idiomatic-query-predicates","depth":3,"charIndex":3071},{"text":"1. By Role query","id":"1-by-role-query","depth":3,"charIndex":-1},{"text":"Name option","id":"name-option","depth":4,"charIndex":-1},{"text":"2. Text input queries","id":"2-text-input-queries","depth":3,"charIndex":-1},{"text":"3. Other accessible queries","id":"3-other-accessible-queries","depth":3,"charIndex":-1},{"text":"4. Test ID query","id":"4-test-id-query","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":90,"title":"React 19 & Suspense Support","content":"#\n\nReact 19 introduced full support for React Suspense, React.use(), and other\nasync rendering features to React Native 0.78.0.\n\nWhen testing components that use these features, React requires the async act\nhelper to handle async state updates. This means React Native Testing Library\nneeds new async versions of its core APIs. These async APIs work with both React\n18 and React 19.\n\n\nNew async APIs#\n\nRNTL 14 introduces async versions of the core testing APIs to handle React 19's\nasync rendering:\n\nRendering APIs:\n\n * render - now async by default (was renderAsync in v13)\n * screen.rerender - now async (returns Promise<void>)\n * screen.unmount - now async (returns Promise<void>)\n\nEvent APIs:\n\n * fireEvent - updated to be async by default.\n\n\nAPIs that remain unchanged#\n\nMany existing APIs continue to work without modification:\n\n * Query methods: screen.getBy*, screen.queryBy*, screen.findBy* - all work the\n   same\n * User Event API - already async, so no API changes needed\n * Jest matchers - work with already-rendered output, so no changes required\n\n\nWhat changes in your tests#\n\n\nMaking tests async#\n\nThe main change is using render which is now async by default, which requires:\n\n 1. Making your test function async\n 2. Adding await before render\n\n\n\n\nWhen to use async APIs#\n\nUse the async APIs when your components:\n\n * Use React Suspense for data fetching or code splitting\n * Call React.use() for reading promises or context\n * Have async state updates that need proper act() handling\n\n\nMigration strategy#\n\n\nNew projects#\n\nUse the async-ready APIs (render, User Event, Jest Matchers, etc.) from the\nstart. They work with both React 18 and React 19.\n\n\nExisting projects#\n\nYou can migrate gradually:\n\n * Existing tests can use unsafe_renderSync for backward compatibility\n * New tests should use async render (default in v14)\n * Tests with Suspense/React.use() must use async render\n\n\nMigration#\n\nSee the v14 migration guide for detailed migration steps from unsafe_renderSync\nto render.","routePath":"/react-native-testing-library/14.x/docs/guides/react-19","lang":"","toc":[{"text":"New async APIs","id":"new-async-apis","depth":2,"charIndex":384},{"text":"APIs that remain unchanged","id":"apis-that-remain-unchanged","depth":2,"charIndex":746},{"text":"What changes in your tests","id":"what-changes-in-your-tests","depth":2,"charIndex":1061},{"text":"Making tests async","id":"making-tests-async","depth":3,"charIndex":1091},{"text":"When to use async APIs","id":"when-to-use-async-apis","depth":3,"charIndex":1263},{"text":"Migration strategy","id":"migration-strategy","depth":2,"charIndex":1502},{"text":"New projects","id":"new-projects","depth":3,"charIndex":1524},{"text":"Existing projects","id":"existing-projects","depth":3,"charIndex":1667},{"text":"Migration","id":"migration","depth":3,"charIndex":1899}],"domain":"","frontmatter":{},"version":"14.x"},{"id":91,"title":"Troubleshooting","content":"#\n\nThis guide describes common issues found by users when integrating React Native\nTest Library to their projects:\n\n\nMatching React Native, React & Test Renderer versions#\n\nCheck that you have matching versions of core dependencies:\n\n * React Native\n * React\n * Test Renderer (automatically installed with RNTL)\n\nReact Native uses different versioning scheme from React, you can use React\nNative Upgrade Helper to find the correct matching between React Native & React\nversions. In case you use Expo, run npx expo install --fix in your project to\nvalidate and install compatible versions of these dependencies.\n\nTest Renderer is automatically managed as a dependency of React Native Testing\nLibrary and is compatible with React 18 and React 19.\n\nRelated issues: #1061, #938, #920\n\nErrors that might indicate that you are facing this issue:\n\n * TypeError: Cannot read property 'current' of undefined when calling render()\n * TypeError: Cannot read property 'isBatchingLegacy' of undefined when calling\n   render()\n\n\nExample repository#\n\nWe maintain an example repository that showcases a modern React Native Testing\nLibrary setup with TypeScript, etc.\n\nIn case something does not work in your setup you can refer to this repository\nfor recommended configuration.\n\n\nUndefined component error#\n\n> Warning: React.jsx: type is invalid -- expected a string (for built-in\n> components) or a class/function (for composite components) but got: undefined.\n\nThis frequently happens when you mock a complex module incorrectly, e.g.:\n\n\n\nThe above mock will mock useNavigation hook as intended, but at the same time\nall other exports from @react-navigation/native package are now undefined. If\nyou want to use NavigationContainer component from the same package it will be\nundefined and result in the error above.\n\nIn order to mock only a part of given package you should re-export all other\nexports using jest.requireActual helper:\n\n\n\nThat way the mock will re-export all of the @react-navigation/native members and\noverwrite only the useNavigation hook.\n\nAlternatively, you can use jest.spyOn to mock package exports selectively.\n\n\nMocking React Native#\n\nIn case of mocking react-native package you should not mock the whole package at\nonce, as this approach has issues with jest.requireActual call. In this case it\nis recommended to mock particular library paths inside the package, e.g.:\n\n\n\n\nAct warnings#\n\nWhen writing tests you may encounter warnings connected with act() function.\nThere are two kinds of these warnings:\n\n * sync act() warning - Warning: An update to Component inside a test was not\n   wrapped in act(...)\n * async act() warning - Warning: You called act(async () => ...) without await\n\nYou can read more about act() function in our understanding act function guide.\n\nNormally, you should not encounter sync act() warnings, but if that happens this\nprobably indicate an issue with your test and should be investigated.\n\nIn case of async act() function this might happen more or less randomly,\nespecially if your components contain async logic. So far this warning does not\nseem to affect test correctness.","routePath":"/react-native-testing-library/14.x/docs/guides/troubleshooting","lang":"","toc":[{"text":"Matching React Native, React & Test Renderer versions","id":"matching-react-native-react--test-renderer-versions","depth":2,"charIndex":116},{"text":"Example repository","id":"example-repository","depth":2,"charIndex":1014},{"text":"Undefined component error","id":"undefined-component-error","depth":2,"charIndex":1263},{"text":"Mocking React Native","id":"mocking-react-native","depth":3,"charIndex":2119},{"text":"Act warnings","id":"act-warnings","depth":2,"charIndex":2381}],"domain":"","frontmatter":{},"version":"14.x"},{"id":92,"title":"Migration to built-in Jest matchers","content":"#\n\nThis guide describes the steps necessary to migrate from legacy Jest Native\nmatchers v5 to built-in Jest matchers.\n\n\nGeneral notes#\n\nAll of the built-in Jest matchers provided by the React Native Testing Library\nsupport only host elements. This should not be an issue, as all RNTL v12 queries\nalready return only host elements. When this guide states that a given matcher\nshould work the same it assumes behavior only host elements. If you need to\nassert the status of composite elements use Jest Native matchers in legacy mode.\n\n\nUsage#\n\nThere is no need to set up the built-in matchers; they are automatically\navailable in your tests when you import anything from\n@testing-library/react-native, e.g., render.\n\n\nGradual migration#\n\nYou can use the built-in matchers alongside legacy Jest Native matchers by\nchanging their import in your jest-setup.ts file:\n\n\n\nIn this case legacy matchers will be available using the legacy_ prefix, e.g.:\n\n\n\n\nMigration details#\n\n\nMatchers not requiring changes#\n\nThe following matchers should work the same:\n\n * toBeEmptyElement()\n * toBeEnabled() / toBeDisabled()\n * toBeOnTheScreen()\n * toBeVisible()\n * toContainElement()\n * toHaveAccessibilityValue()\n * toHaveDisplayValue()\n * toHaveProp()\n * toHaveStyle()\n * toHaveTextContent()\n\n\nReplaced matchers#\n\nThe toHaveAccessibilityState() matcher has been replaced by the following\nmatchers:\n\n * enabled state: toBeEnabled() / toBeDisabled()\n * checked state: toBeChecked() / toBePartiallyChecked()\n * selected state: toBeSelected()\n * expanded state: toBeExpanded() / toBeCollapsed()\n * busy state: toBeBusy()\n\nThe new matchers support both accessibilityState and aria-* props.\n\n\nAdded matchers#\n\nNew toHaveAccessibleName() has been added.\n\n\nNoteworthy details#\n\nYou should be aware of the following details:\n\n * toBeEnabled() / toBeDisabled() matchers also check the disabled state for the\n   element's ancestors and not only the element itself. This is the same as in\n   legacy Jest Native matchers of the same name but differs from the removed\n   toHaveAccessibilityState() matcher.\n * toBeChecked() matcher supports only elements with a checkbox, radio and\n   'switch' role\n * toBePartiallyChecked() matcher supports only elements with checkbox role","routePath":"/react-native-testing-library/14.x/docs/migration/jest-matchers","lang":"","toc":[{"text":"General notes","id":"general-notes","depth":2,"charIndex":119},{"text":"Usage","id":"usage","depth":2,"charIndex":533},{"text":"Gradual migration","id":"gradual-migration","depth":3,"charIndex":715},{"text":"Migration details","id":"migration-details","depth":2,"charIndex":946},{"text":"Matchers not requiring changes","id":"matchers-not-requiring-changes","depth":3,"charIndex":967},{"text":"Replaced matchers","id":"replaced-matchers","depth":3,"charIndex":1274},{"text":"Added matchers","id":"added-matchers","depth":3,"charIndex":1667},{"text":"Noteworthy details","id":"noteworthy-details","depth":3,"charIndex":1729}],"domain":"","frontmatter":{},"version":"14.x"},{"id":93,"title":"Migration to 11.x","content":"#\n\nMigration to React Native Testing Library version 11 from version 9.x or 10.x\nshould be a relatively easy task due small amount of breaking changes.\n\n\nBreaking changes#\n\n\nUpdate to Jest 28 if you use fake timers#\n\nIf you use fake timers in any of your tests you should update your Jest\ndependencies to version 28. This is due to the fact that jest.useFakeTimers()\nconfig structure has changed.\n\n\nRefactor legacy waitForOptions position#\n\nIn version 9 we introducted query options parameters for each query type. This\naffected all findBy and findAllBy queries because their signatures changed e.g.\nfrom:\n\n\n\nto\n\n\n\nIn order to facilitate transition, in version 9 and 10, we provided a temporary\npossibility to pass WaitForOptions like timeout, interval, etc inside options\nargument. From this release we require passing these as the proper third\nparameter.\n\nThis change is easy to implement:\n\n\n\nshould become\n\n\n\n\nTriggering non-touch events on targets with pointerEvents=\"box-none\" prop#\n\nUp to version 10, RNTL disables all events for a target with\npointerEvents=\"box-none\". This behavior is counter to how React Native itself\nfunctions.\n\nFrom version 11, RNTL continues to disable press event for these targets but\nallows triggering other events, e.g. layout.\n\n\nFull Changelog#\n\nhttps://github.com/callstack/react-native-testing-library/compare/v10.1.1...v11.\n0.0","routePath":"/react-native-testing-library/14.x/docs/migration/previous/v11","lang":"","toc":[{"text":"Breaking changes","id":"breaking-changes","depth":2,"charIndex":153},{"text":"Update to Jest 28 if you use fake timers","id":"update-to-jest-28-if-you-use-fake-timers","depth":3,"charIndex":173},{"text":"Refactor legacy `waitForOptions` position","id":"refactor-legacy-waitforoptions-position","depth":3,"charIndex":-1},{"text":"Triggering non-touch events on targets with `pointerEvents=\"box-none\"` prop","id":"triggering-non-touch-events-on-targets-with-pointereventsbox-none-prop","depth":3,"charIndex":-1},{"text":"Full Changelog","id":"full-changelog","depth":2,"charIndex":1263}],"domain":"","frontmatter":{},"version":"14.x"},{"id":94,"title":"Migration to 12.x","content":"#\n\nINFO\n\nIf you are already using legacy @testing-library/jest-native Jest Matchers, we\nhave a migration guide for moving to the built-in matchers.\n\nReact Native Testing Library 12 introduces a handful of breaking changes\ncompared to 11.x versions. We believe they were necessary to improve the\nexperience using the library and help the users fall into the pit of success\nwhen writing meaningful tests. You will find migration instructions for each and\nevery change described below.\n\n\nBreaking changes#\n\n\n1. All queries exclude elements hidden from accessibility by default#\n\nElements that are hidden from accessiblity, e.g. elements on non-active screen\nwhen using React Navigation, now will not be matched by default by all queries.\nThis is the effect of switching the default value for global config option\ndefaultIncludeHiddenElements(api#defaultincludehiddenelements-option) to false.\n\nPrevious behaviour of matching hidden elements can be enabled on query level\nusing includeHiddenElements query options or globally using\ndefaultIncludeHiddenElements(api#defaultincludehiddenelements-option)\nconfiguration option.\n\n\n2. *ByRole queries now return only accessibility elements#\n\n*ByRole queries now return only accessibility elements, either explicitly marked\nwith accessible prop or implicit ones where this status is derived from\ncomponent type itself (e.g Text, TextInput, Switch, but not View).\n\nYou may need to adjust relevant components under test to make sure they pass\nisAccessibilityElement check.\n\nExamples#\n\nLet's assume we are using getByRole(\"button\") query.\n\nFollowing elements will match:\n\n\n\nWhile following elements will not match:\n\n\n\n\n3. *ByText, *ByDisplayValue, *ByPlaceholderText queries now return host\nelements#\n\n*ByText, *ByDisplayValue, *ByPlaceholderText queries now return host elements,\nwhich is consistent with other queries.\n\nWhile potentially breaking, this should not cause issues in tests if you are\nusing recommended queries and Jest Matchers from Jest Native package.\n\nProblematic cases may include: directly checking some prop values (without using\nJest Native matchers), referencing other nodes using parent or children props,\nexamining type property of HostElement, etc.\n\n\n4. container API has been renamed to UNSAFE_root.#\n\nHistorically container was supposed to mimic the RTL's container. However it\nturned out not so relevant in RNTL's environment, where we actually used it to\nreturn React Test Renderer's root instance.\n\nRNTL v12 introduces root API as an alternative that returns a root host element.\nThe difference between root and UNSAFE_root properties is that that root will\nalways represents a host element, while UNSAFE_root will typically represent a\ncomposite element.\n\nIf you use toBeOnTheScreen matcher from @testing-library/jest-native your tests\nwill fail because it uses the container api. To fix this, update\n@testing-library/jest-native to version 5.4.2.\n\n\nFull Changelog#\n\nhttps://github.com/callstack/react-native-testing-library/compare/v11.5.2...v12.\n0.0","routePath":"/react-native-testing-library/14.x/docs/migration/previous/v12","lang":"","toc":[{"text":"Breaking changes","id":"breaking-changes","depth":2,"charIndex":484},{"text":"1. All queries exclude elements hidden from accessibility by default","id":"1-all-queries-exclude-elements-hidden-from-accessibility-by-default","depth":3,"charIndex":504},{"text":"2. `*ByRole` queries now return only accessibility elements","id":"2-byrole-queries-now-return-only-accessibility-elements","depth":3,"charIndex":-1},{"text":"Examples","id":"examples","depth":4,"charIndex":1510},{"text":"3. `*ByText`, `*ByDisplayValue`, `*ByPlaceholderText` queries now return host elements","id":"3-bytext-bydisplayvalue-byplaceholdertext-queries-now-return-host-elements","depth":3,"charIndex":-1},{"text":"4. `container` API has been renamed to `UNSAFE_root`.","id":"4-container-api-has-been-renamed-to-unsafe_root","depth":3,"charIndex":-1},{"text":"Full Changelog","id":"full-changelog","depth":2,"charIndex":2917}],"domain":"","frontmatter":{},"version":"14.x"},{"id":95,"title":"Migration to 2.x","content":"#\n\nThis guide describes steps necessary to migrate from React Native Testing\nLibrary v1.x to v2.x.\n\n\nDropping Node 8#\n\nNode 8 reached its EOL more than 5 months ago, so it's about time to target the\nlibrary to Node 10. If you used lower version, you'll have to upgrade to v10,\nbut we recommend using the latest LTS version.\n\n\nAuto Cleanup#\n\ncleanup() function is now called automatically after every test if your testing\nframework supports afterEach hook (like Jest, Mocha, and Jasmine).\n\nYou should be able to remove all afterEach(cleanup) calls in your code.\n\nThis change might break your code, if you tests are not isolated, i.e. you call\nrender outside test block. Generally, you should keep your tests isolated. But\nif you can't or don't want to do this right away you can prevent this behavior\nusing any of the following ways:\n\n * by importing 'react-native-testing-library/pure' instead of\n   'react-native-testing-library'\n\n * by importing 'react-native-testing-library/dont-cleanup-after-each' before\n   importing 'react-native-testing-library'. You can do it in a global way by\n   using Jest's setupFiles like this:\n   \n   \n\n * by setting RNTL_SKIP_AUTO_CLEANUP env variable to true. You can do this with\n   cross-evn like this:\n   \n   \n\n\nWaitFor API changes#\n\nWe renamed waitForElement function to waitFor for consistency with React Testing\nLibrary. Additionally, the signature has slightly changed from:\n\n\n\nto:\n\n\n\nBoth changes should improve code readibility.\n\nwaitFor calls (and hence also findBy queries) are now wrapped in act by default,\nso that you should no longer need to use act directly in your tests.\n\nTIP\n\nYou can usually avoid waitFor by a proper use of findBy asynchronous queries. It\nwill result in more streamlined testing experience.\n\n\nRemoved global debug function#\n\nThe debug() method returned from render() function is all you need. We removed\nthe global export to avoid confusion.\n\n\nRemoved global shallow function#\n\nShallow rendering React component is usually not a good idea, so we decided to\nremove the API. But, if you find it useful or need to support legacy tests, feel\nfree to use this implementation:\n\n\n\n\nRemoved functions#\n\nFollowing query functions have been removed after being deprecated for more than\na year now:\n\n * getByName\n * getAllByName\n * queryByName\n * queryAllByName\n\nThe *ByType and *ByProps queries has been prefixed with UNSAFE_. These UNSAFE_\nfunctions are not planned for removal in future versions but their usage is\ndiscouraged. You can rename them using global search/replace in your project:\n\n * getByType -> UNSAFE_getByType\n * getAllByType -> UNSAFE_getAllByType\n * queryByType -> UNSAFE_queryByType\n * queryAllByType -> UNSAFE_queryAllByType\n * getByProps -> UNSAFE_getByProps\n * getAllByProps -> UNSAFE_getAllByProps\n * queryByProps -> UNSAFE_queryByProps\n * queryAllByProps -> UNSAFE_queryAllByProps\n\n\nSome ByTestId queries behavior changes#\n\nIn version 1.x the getByTestId and queryByTestId queries could return non-native\ninstances. This was a serious bug. Other query functions like getAllByTestId,\nqueryAllByTestId, findByTestId and findAllByTestId didn't have this issue. These\ncorrectly returned only native components instances (e.g. View, Text, etc) that\ngot the testID.\n\nIn v2 we fixed this inconsistency, which may result in failing tests, if you\nrelied on this behavior. There are few ways to handle these failures:\n\n * pass the testID prop down so it can reach a native component, like View or\n   Text\n * replace testID with proper accessibilityHint or accessibilityLabel if it\n   benefits the user\n * use safe queries like *ByText or *ByA11yHint\n\n\nDeprecated flushMicrotasksQueue#\n\nWe have deprecated flushMicrotasksQueue and plan to remove it in the next major.\nWe have better alternatives available for helping you write async tests – findBy\nasync queries and waitFor helper.\n\nIf you can't or don't want to migrate your tests, don't worry. You can use the\nsame implementation we have today:\n\n","routePath":"/react-native-testing-library/14.x/docs/migration/previous/v2","lang":"","toc":[{"text":"Dropping Node 8","id":"dropping-node-8","depth":2,"charIndex":100},{"text":"Auto Cleanup","id":"auto-cleanup","depth":2,"charIndex":325},{"text":"WaitFor API changes","id":"waitfor-api-changes","depth":2,"charIndex":1248},{"text":"Removed global `debug` function","id":"removed-global-debug-function","depth":2,"charIndex":-1},{"text":"Removed global `shallow` function","id":"removed-global-shallow-function","depth":2,"charIndex":-1},{"text":"Removed functions","id":"removed-functions","depth":2,"charIndex":2145},{"text":"Some `ByTestId` queries behavior changes","id":"some-bytestid-queries-behavior-changes","depth":2,"charIndex":-1},{"text":"Deprecated `flushMicrotasksQueue`","id":"deprecated-flushmicrotasksqueue","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":96,"title":"Migration to 7.x","content":"#\n\nINFO\n\nWe renamed the react-native-testing-library npm package to\n@testing-library/react-native, officially joining the \"Testing Library\" family\n🎉.\n\nAs the version 7.0 involves merging two libraries together, there are two\nvariants for migration guide, dependent on library you used previously:\n\n\nGuide for react-native-testing-library users#\n\nThis guide describes steps necessary to migrate from React Native Testing\nLibrary v2.x or v6.0 to v7.0.\n\n\nRenaming the library#\n\n 1. Install @testing-library/react-native.\n 2. Uninstall react-native-testing-library.\n 3. Rename all references of react-native-testing-library to\n    @testing-library/react-native.\n\nYou may have noticed a strange v2 to v7 upgrade, skipping versions 3, 4, 5 and\n6. This is because we renamed the react-native-testing-library npm package to\n@testing-library/react-native, officially joining the \"Testing Library\" family\n🎉. We're merging existing two libraries into a single one. The\nnative-testing-library repository, which had v6, will soon be archived and using\n@testing-library/react-native below v7, sourced from mentioned repository, is\ndeprecated.\n\nFor branding purposes we keep the \"React Native Testing Library\" name, similar\nto \"React Testing Library\". Only the npm published package is changing. The code\nrepository also stays the same under Callstack governance.\n\n\nNew aliases#\n\nTo improve compatibility with React Testing Library, and ease the migration for\n@testing-library/react-native users using version below v7, we've introduced new\naliases to our accessibility queries:\n\n * ByLabelText aliasing ByA11yLabel queries\n * ByHintText aliasing ByA11yHint queries\n * ByRole aliasing ByA11yRole queries\n\nWe like the new names and consider removing the aliases in future releases.\n\n\nRenaming ByPlaceholder queries#\n\nTo improve compatibility with React Testing Library, and to ease the migration\nfor @testing-library/react-native users using version below v7, we've renamed\nfollowing queries:\n\n * ByPlaceholder -> ByPlaceholderText\n\nPlease replace all occurrences of these queries in your codebase.\n\n\nfireEvent support for disabled components#\n\nTo improve compatibility with the real React Native environment fireEvent now\nperforms checks whether the component is \"disabled\" before firing an event on\nit. It uses the Responder system to establish should the event fire, which\nresembles the actual React Native runtime closer than we used to.\n\nIf your code contained any workarounds for preventing events firing on disabled\nevents, you should now be able to remove them.\n\n\nGuide for @testing-library/react-native users#\n\nThis guide describes steps necessary to migrate from\n@testing-library/react-native from v6.0 to v7.0. Although the name stays the\nsame, this is a different library, sourced at Callstack GitHub repository. We\nmade sure the upgrade path is as easy for you as possible.\n\n\nRenaming \"wait\" helpers#\n\nThe wait and waitForElement helpers are replaced by waitFor. Please rename all\noccurrences of these in your codebase.\n\n\nChanges to ByTestId queries#\n\nThe ByTestId queries don't accept RegExps. Please use strings instead. We're\nhappy to accept PRs adding this functionality :).\n\n\nNo ByTitle queries#\n\nOur library doesn't implement ByTitle queries, which are targetting components\nwith title prop, specifically Button and RefreshControl. If your tests only use\nByTitle to target Button components, you can replace them with ByText queries,\nsince React Native renders Text under the hood.\n\nIf you need to query RefreshControl component and can't figure out other way\naround it, you can use e.g. UNSAFE_getByProps({title}) query.\n\n\nNo custom Jest configuration#\n\nUse the official React Native preset for Jest:\n\n\n\nWe're told this also speeds up your tests startup on cold cache. Using official\npreset has another benefit – the library is compatible with any version of React\nNative without introducing breaking changes.\n\n\nCleanup is included by default#\n\nCleaning up (unmounting) components after each test is included by default in\nthe same manner as in React Testing Library. Please remove this setup file from\nJest config:\n\n\n\nYou can opt-out of this behavior by running tests with\nRNTL_SKIP_AUTO_CLEANUP=true flag or importing from\n@testing-library/react-native/pure. We encourage you to keep the default though.\n\n\nNo NativeTestInstance abstraction#\n\nWe don't provide any abstraction over HostElement returned by queries, but allow\nto use it directly to access queried component's props or type for that example.\n\n\nNo container nor baseElement returned from render#\n\nThere's no container returned from the render function. If you must, use\nreact-test-renderer directly, although we advise against doing so. We also don't\nimplement baseElement because of that, since there's no document.documentElement\nnor container.\n\n\nFiring events changes#\n\nThere are slight differences in how fireEvent works in both libraries:\n\n 1. Our library doesn't perform validation checks for events fired upon tested\n    components.\n 2. Signature is different:\n    \n    \n\n 3. There is no NativeTestEvent - second and rest arguments are used instead.\n 4. There are only 3 short-hand events: fireEvent.press, fireEvent.changeText\n    and fireEvent.scroll. For all other or custom events you can use the base\n    signature.","routePath":"/react-native-testing-library/14.x/docs/migration/previous/v7","lang":"","toc":[{"text":"Guide for `react-native-testing-library` users","id":"guide-for-react-native-testing-library-users","depth":2,"charIndex":-1},{"text":"Renaming the library","id":"renaming-the-library","depth":3,"charIndex":452},{"text":"New aliases","id":"new-aliases","depth":3,"charIndex":1352},{"text":"Renaming `ByPlaceholder` queries","id":"renaming-byplaceholder-queries","depth":3,"charIndex":-1},{"text":"`fireEvent` support for disabled components","id":"fireevent-support-for-disabled-components","depth":3,"charIndex":-1},{"text":"Guide for `@testing-library/react-native` users","id":"guide-for-testing-libraryreact-native-users","depth":2,"charIndex":-1},{"text":"Renaming \"wait\" helpers","id":"renaming-wait-helpers","depth":3,"charIndex":2874},{"text":"Changes to `ByTestId` queries","id":"changes-to-bytestid-queries","depth":3,"charIndex":-1},{"text":"No `ByTitle` queries","id":"no-bytitle-queries","depth":3,"charIndex":-1},{"text":"No custom Jest configuration","id":"no-custom-jest-configuration","depth":3,"charIndex":3628},{"text":"Cleanup is included by default","id":"cleanup-is-included-by-default","depth":3,"charIndex":3917},{"text":"No NativeTestInstance abstraction","id":"no-nativetestinstance-abstraction","depth":3,"charIndex":4313},{"text":"No `container` nor `baseElement` returned from `render`","id":"no-container-nor-baseelement-returned-from-render","depth":3,"charIndex":-1},{"text":"Firing events changes","id":"firing-events-changes","depth":3,"charIndex":4817}],"domain":"","frontmatter":{},"version":"14.x"},{"id":97,"title":"Migration to 9.x","content":"#\n\nVersion 7.0 brought React Native Testing Library into the @testing-library\nfamily. Since it has been implemented independently from its web counterpart –\nthe React Testing Library – there are some differences in the API and behavior.\nVersion 9.0 solves several of these problems.\n\n\nSupport for text match options a.k.a string precision API#\n\nThis is a backward compatible change.\n\nWhen querying text, it is now possible to pass a TextMatch to most text based\nqueries, which lets you configure how @testing-library/react-native should match\nyour text. For instance, passing exact: false will allow matching substrings and\nwill ignore case:\n\n\n\nPlease note that the findBy* queries used to take a waitForOptions parameter as\na second argument, which has now been moved to the third argument:\n\n\n\nFor backward compatibility RNTL v9 can still read waitForOptions from the second\nargument but will print a deprecation warning.\n\n\nReverted matching text across several nodes#\n\nCAUTION\n\nThis is a breaking change.\n\nIn v1.14 we've introduced a feature allowing to match text when it's spread\nacross several nodes:\n\n\n\nHowever this behavior was different than the web one, and wouldn't always be\nstraightforward to reason about. For instance it could match text nodes far from\neach other on the screen. It also prevented us from implementing the string\nprecision API. From v9, this type of match will not work.\n\nA work around is to use within:\n\n\n\n\nFuture plans#\n\nThis release changes a lot of internal logic in the library, paving the way for\nmore improvements to bring us closer to our web counterpart, with a possibly\nbetter story for accessibility queries.\n\nWe're also migrating the codebase to TypeScript. Please let us know if you're\ninterested in helping us with this effort.\n\nStay safe!","routePath":"/react-native-testing-library/14.x/docs/migration/previous/v9","lang":"","toc":[{"text":"Support for text match options a.k.a string precision API","id":"support-for-text-match-options-aka-string-precision-api","depth":2,"charIndex":284},{"text":"Reverted matching text across several nodes","id":"reverted-matching-text-across-several-nodes","depth":2,"charIndex":924},{"text":"Future plans","id":"future-plans","depth":2,"charIndex":1437}],"domain":"","frontmatter":{},"version":"14.x"},{"id":98,"title":"Migration to 13.x","content":"#\n\nThis guide describes the migration to React Native Testing Library version 13\nfrom version 12.x.\n\nOverall, the v13 release is relatively small, focusing on removing deprecated\nqueries and improving the developer experience.\n\n\nBreaking changes#\n\n\nSupported React and React Native versions#\n\nThis version supports only React 18+ and corresponding React Native versions\n(0.71+). If you use React 16 or 17, please use the latest of v12 versions.\n\nNote: currently, stable React Native is unavailable for React 19, which is still\nin the RC phase, so we test against React Native nightly builds.\n\n\nConcurrent rendering by default#\n\nThis version introduces concurrent rendering by default. This change should not\naffect regular tests, but it might affect your tests if you use React Suspense\nor similar.\n\nYou can revert to legacy rendering by passing concurrentRoot: false to render or\nconfigure methods.\n\nNote: in React 19, concurrent rendering is the only supported rendering mode.\n\n\nExtend Jest matchers by default#\n\nYou can remove import '@testing-library/react-native/extend-expect' imports, as\nnow Jest matchers are extended by default when you import anything from\n@testing-library/react-native.\n\nYou can avoid the automatic extending of Jest matchers by importing\n@testing-library/react-native/pure instead.\n\n\n\n\nRemoved deprecated *ByAccessibilityState queries#\n\nWe have removed this deprecated query as it is typically too general to give\nmeaningful results. Use one of the following options:\n\n * *ByRole query with relevant state options: disabled, selected, checked,\n   expanded and busy\n * use built-in Jest matchers to check the state of element found using some\n   other query:\n   * enabled state: toBeEnabled() / toBeDisabled()\n   * checked state: toBeChecked() / toBePartiallyChecked()\n   * selected state: toBeSelected()\n   * expanded state: toBeExpanded() / toBeCollapsed()\n   * busy state: toBeBusy()\n\n\n\n\nRemoved deprecated *ByAccessibilityValue queries#\n\nWe have removed this deprecated query as it is typically too general to give\nmeaningful results. Use one of the following options:\n\n * toHaveAccessibilityValue() Jest matcher to check the state of element found\n   using some other query\n * *ByRole query with value option\n\n\n\n\nRemoved Jest preset#\n\nWe have removed RNTL Jest preset, so you should change you jest.config.js\naccordingly.\n\nReplace:\n\n\n\n\nRemoved debug.shallow#\n\nWe didn't support shallow rendering for the time being. Now, we are removing the\nlast remains of it: debug.shallow(). If you are interested in shallow rendering\nsee here.\n\n\nChanges to accessibility label calculation#\n\nExplicit labels:\n\n * accessiblityLabelledBy\n * accessiblityLabel\n * aria-labelledby\n * aria-label\n\nnow take strict priority over implicit labels derived from the element's text\ncontent.\n\n\nOther changes#\n\n\nRemoved host component names autodetection#\n\nThis change should not break any tests, it should also make RNTL tests run\n10-20% faster.\n\n\nUse React implementation of act instead of React Test Renderer one#\n\nThis change should not break any tests.\n\n\nUpdated flushMicroTasks internal method#\n\nThis change should not break any tests.\n\n\nFull Changelog#\n\nhttps://github.com/callstack/react-native-testing-library/compare/v12.8.1...v13.\n0.0","routePath":"/react-native-testing-library/14.x/docs/migration/v13","lang":"","toc":[{"text":"Breaking changes","id":"breaking-changes","depth":2,"charIndex":228},{"text":"Supported React and React Native versions","id":"supported-react-and-react-native-versions","depth":3,"charIndex":248},{"text":"Concurrent rendering by default","id":"concurrent-rendering-by-default","depth":3,"charIndex":593},{"text":"Extend Jest matchers by default","id":"extend-jest-matchers-by-default","depth":3,"charIndex":980},{"text":"Removed deprecated `*ByAccessibilityState` queries","id":"removed-deprecated-byaccessibilitystate-queries","depth":3,"charIndex":-1},{"text":"Removed deprecated `*ByAccessibilityValue` queries","id":"removed-deprecated-byaccessibilityvalue-queries","depth":3,"charIndex":-1},{"text":"Removed Jest preset","id":"removed-jest-preset","depth":3,"charIndex":2245},{"text":"Removed `debug.shallow`","id":"removed-debugshallow","depth":3,"charIndex":-1},{"text":"Changes to accessibility label calculation","id":"changes-to-accessibility-label-calculation","depth":3,"charIndex":2565},{"text":"Other changes","id":"other-changes","depth":2,"charIndex":2798},{"text":"Removed host component names autodetection","id":"removed-host-component-names-autodetection","depth":3,"charIndex":2815},{"text":"Use React implementation of `act` instead of React Test Renderer one","id":"use-react-implementation-of-act-instead-of-react-test-renderer-one","depth":3,"charIndex":-1},{"text":"Updated `flushMicroTasks` internal method","id":"updated-flushmicrotasks-internal-method","depth":3,"charIndex":-1},{"text":"Full Changelog","id":"full-changelog","depth":2,"charIndex":3147}],"domain":"","frontmatter":{},"version":"14.x"},{"id":99,"title":"Migration to 14.x","content":"#\n\nThis guide describes the migration to React Native Testing Library version 14\nfrom version 13.x.\n\n\nBreaking changes#\n\n\nTest Renderer replaces React Test Renderer#\n\nIn v14, React Native Testing Library now uses Test Renderer instead of the\ndeprecated react-test-renderer package. Test Renderer is a modern, actively\nmaintained alternative that provides better compatibility with React 19 and\nimproved type safety.\n\nWhat changed:\n\n * The underlying rendering engine has been switched from react-test-renderer to\n   test-renderer\n * This change is mostly internal and should not require code changes in most\n   cases\n * Type definitions have been updated to use HostElement from Test Renderer\n   instead of ReactTestInstance\n\nMigration:\n\n1. Update dependencies#\n\nRemove react-test-renderer and its type definitions from your dev dependencies,\nand add test-renderer:\n\n\n\n2. Update type imports (if needed)#\n\nIf you were directly importing types from react-test-renderer, you may need to\nupdate your imports:\n\n\n\nNote: Most users won't need to update type imports, as React Native Testing\nLibrary now exports the necessary types directly.\n\nFor more details, see the Test Renderer documentation.\n\n\ncontainer API reintroduced#\n\nIn v14, the container API has been reintroduced and is now safe to use.\nPreviously, container was renamed to UNSAFE_root in v12 due to behavioral\ndifferences from React Testing Library's container. In v14, container now\nreturns a pseudo-element container whose children are the elements you asked to\nrender, making it safe and consistent with React Testing Library's behavior.\n\nWhat changed:\n\n * screen.container is now available and safe to use\n * container returns a pseudo-element container from Test Renderer\n * The container's children are the elements you rendered\n * UNSAFE_root has been removed\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nMigration:\n\nIf you were using UNSAFE_root, replace it with container:\n\n\n\nFor more details, see the screen API documentation.\n\n\nrender is now async by default #\n\nIn v14, render is now async by default and returns a Promise. The previous\nsynchronous render function has been renamed to unsafe_renderSync. This change\nmakes it compatible with React 19, React Suspense, and React.use().\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nMigration path#\n\nTo ease migration, we provide unsafe_renderSync which maintains the same\nsynchronous behavior as v13. This allows you to migrate gradually.\n\nunsafe_renderSync #\n\n\n\n⚠️ Deprecated: This function is provided for migration purposes only. Use async\nrender instead.\n\nThe synchronous version of render that returns immediately without awaiting\nReact updates. This maintains backward compatibility with v13 tests but is not\nrecommended for new code.\n\n\n\nStep-by-step migration guide#\n\nTo migrate from unsafe_renderSync to render:\n\n1. Add async to your test function#\n\n\n\n2. Await render#\n\n\n\n3. Update rerender calls to await#\n\n\n\n4. Update unmount calls to await#\n\n\n\nComplete example#\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nBenefits of async render#\n\n * React 19 compatibility: Works seamlessly with React 19's async features\n * Suspense support: Properly handles React Suspense boundaries and React.use()\n * Better timing: Ensures all pending React updates are executed before\n   assertions\n * Future-proof: Aligns with React's direction toward async rendering\n\nFor more details, see the render API documentation.\n\n\nrenderHook is now async by default#\n\nIn v14, renderHook is now async by default and returns a Promise. This change\nmakes it compatible with React 19, React Suspense, and React.use().\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nMigration path#\n\nTo ease migration, we provide unsafe_renderHookSync which maintains the same\nsynchronous behavior as v13. This allows you to migrate gradually.\n\nunsafe_renderHookSync #\n\n\n\n⚠️ Deprecated: This function is provided for migration purposes only. Use async\nrenderHook instead.\n\nThe synchronous version of renderHook that returns immediately without awaiting\nReact updates. This maintains backward compatibility with v13 tests but is not\nrecommended for new code.\n\n\n\nResult types#\n\nv13 (deprecated):\n\n\n\nv14 (default):\n\n\n\nNote: Both RenderHookSyncResult and RenderHookResult use rerender and unmount\nmethods. The difference is that RenderHookSyncResult methods are synchronous\n(return void), while RenderHookResult methods are async (return Promise<void>).\n\nStep-by-step migration guide#\n\nTo migrate from unsafe_renderHookSync to renderHook:\n\n1. Add async to your test function#\n\n\n\n2. Await renderHook#\n\n\n\n3. Update rerender calls to await#\n\n\n\n4. Update unmount calls to await#\n\n\n\n5. Update act calls to use async act#\n\n\n\nComplete example#\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nBenefits of async renderHook#\n\n * React 19 compatibility: Works seamlessly with React 19's async features\n * Suspense support: Properly handles React Suspense boundaries and React.use()\n * Better timing: Ensures all pending React updates are executed before\n   assertions\n * Future-proof: Aligns with React's direction toward async rendering\n\nFor more details, see the renderHook API documentation.\n\n\nfireEvent is now async by default#\n\nIn v14, fireEvent and its helpers (press, changeText, scroll) are now async by\ndefault and return a Promise. This change makes it compatible with React 19,\nReact Suspense, and React.use().\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nMigration path#\n\nTo ease migration, we provide unsafe_fireEventSync which maintains the same\nsynchronous behavior as v13. This allows you to migrate gradually.\n\nunsafe_fireEventSync #\n\n\n\n⚠️ Deprecated: This function is provided for migration purposes only. Use async\nfireEvent instead.\n\nThe synchronous version of fireEvent that returns immediately without awaiting\nReact updates. This maintains backward compatibility with v13 tests but is not\nrecommended for new code.\n\n\n\n\nText string validation now enforced by default#\n\nIn v14, Test Renderer automatically enforces React Native's requirement that\ntext strings must be rendered within a <Text> component. This means the\nunstable_validateStringsRenderedWithinText option has been removed from\nRenderOptions, as this validation is now always enabled.\n\nWhat changed:\n\n * Text string validation is now always enabled and cannot be disabled\n * The unstable_validateStringsRenderedWithinText option has been removed\n * Tests will now throw Invariant Violation: Text strings must be rendered\n   within a <Text> component errors when attempting to render strings outside of\n   <Text> components, matching React Native's runtime behavior\n\nMigration:\n\nIf you were using unstable_validateStringsRenderedWithinText: true in your\nrender options, you can simply remove this option as the validation is now\nalways enabled:\n\n\n\nIf you were relying on the previous behavior where strings could be rendered\noutside of <Text> components, you'll need to fix your components to wrap strings\nin <Text> components, as this matches React Native's actual runtime behavior.\n\n\nact is now async by default#\n\nIn v14, act is now async by default and always returns a Promise. The previous\nsynchronous act function has been renamed to unsafe_act. This change makes it\ncompatible with React 19, React Suspense, and React.use().\n\nWhat changed:\n\n * act now always returns a Promise<T> instead of T | Thenable<T>\n * unsafe_act is available for the old behavior (direct React.act wrapper)\n * Both act and unsafe_act are now named exports (no default export)\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nMigration path#\n\nTo ease migration, we provide unsafe_act which maintains the same behavior as\nv13. This allows you to migrate gradually.\n\nunsafe_act #\n\n\n\n⚠️ Deprecated: This function is provided for migration purposes only. Use async\nact instead.\n\nThe synchronous version of act that returns immediately for sync callbacks or a\nthenable for async callbacks. This maintains backward compatibility with v13\ntests but is not recommended for new code.\n\n\n\nStep-by-step migration guide#\n\nTo migrate from unsafe_act to act:\n\n1. Update import statement#\n\n\n\n2. Add async to your test function#\n\n\n\n3. Await act calls#\n\n\n\nNote: Even if your callback is synchronous, you should still use await act(async\n() => ...) as act now always returns a Promise.\n\nComplete example#\n\nBefore (v13):\n\n\n\nAfter (v14):\n\n\n\nBenefits of async act#\n\n * React 19 compatibility: Works seamlessly with React 19's async features\n * Suspense support: Properly handles React Suspense boundaries and React.use()\n * Consistent API: Always returns a Promise, making the API more predictable\n * Future-proof: Aligns with React's direction toward async rendering\n\nFor more details, see the act API documentation.","routePath":"/react-native-testing-library/14.x/docs/migration/v14","lang":"","toc":[{"text":"Breaking changes","id":"breaking-changes","depth":2,"charIndex":101},{"text":"Test Renderer replaces React Test Renderer","id":"test-renderer-replaces-react-test-renderer","depth":3,"charIndex":121},{"text":"1. Update dependencies","id":"1-update-dependencies","depth":4,"charIndex":737},{"text":"2. Update type imports (if needed)","id":"2-update-type-imports-if-needed","depth":4,"charIndex":868},{"text":"`container` API reintroduced","id":"container-api-reintroduced","depth":3,"charIndex":-1},{"text":"`render` is now async by default","id":"render-is-now-async-by-default","depth":3,"charIndex":-1},{"text":"Migration path","id":"migration-path","depth":4,"charIndex":2275},{"text":"Step-by-step migration guide","id":"step-by-step-migration-guide","depth":4,"charIndex":2737},{"text":"Complete example","id":"complete-example","depth":4,"charIndex":2948},{"text":"Benefits of async `render`","id":"benefits-of-async-render","depth":4,"charIndex":-1},{"text":"`renderHook` is now async by default","id":"renderhook-is-now-async-by-default","depth":3,"charIndex":-1},{"text":"Migration path","id":"migration-path-1","depth":4,"charIndex":3610},{"text":"Step-by-step migration guide","id":"step-by-step-migration-guide-1","depth":4,"charIndex":4378},{"text":"Complete example","id":"complete-example-1","depth":4,"charIndex":4642},{"text":"Benefits of async `renderHook`","id":"benefits-of-async-renderhook","depth":4,"charIndex":-1},{"text":"`fireEvent` is now async by default","id":"fireevent-is-now-async-by-default","depth":3,"charIndex":-1},{"text":"Migration path","id":"migration-path-2","depth":4,"charIndex":5354},{"text":"Text string validation now enforced by default","id":"text-string-validation-now-enforced-by-default","depth":3,"charIndex":5829},{"text":"`act` is now async by default","id":"act-is-now-async-by-default","depth":3,"charIndex":-1},{"text":"Migration path","id":"migration-path-3","depth":4,"charIndex":7462},{"text":"Step-by-step migration guide","id":"step-by-step-migration-guide-2","depth":4,"charIndex":7914},{"text":"Complete example","id":"complete-example-2","depth":4,"charIndex":8204},{"text":"Benefits of async `act`","id":"benefits-of-async-act","depth":4,"charIndex":-1}],"domain":"","frontmatter":{},"version":"14.x"},{"id":100,"title":"Introduction","content":"#\n\n\nThe problem#\n\nYou want to write maintainable tests for your React Native components. As a part\nof this goal, you want your tests to avoid including implementation details of\nyour components and focus on making your tests give you the confidence they are\nintended. As part of this, you want your tests to be maintainable in the long\nrun so refactors of your components (changes to implementation but not\nfunctionality) don't break your tests and slow you and your team down.\n\n\nThis solution#\n\nThe React Native Testing Library (RNTL) is a lightweight solution for testing\nReact Native components. It provides light utility functions on top of Test\nRenderer, in a way that encourages better testing practices. Its primary guiding\nprinciple is:\n\n> The more your tests resemble how your software is used, the more confidence\n> they can give you.\n\nThis project is inspired by React Testing Library. It is tested to work with\nJest, but it should work with other test runners as well.\n\n\nExample#\n\n\n\nYou can find the source of the QuestionsBoard component and this example here.","routePath":"/react-native-testing-library/14.x/docs/start/intro","lang":"","toc":[{"text":"The problem","id":"the-problem","depth":2,"charIndex":3},{"text":"This solution","id":"this-solution","depth":2,"charIndex":479},{"text":"Example","id":"example","depth":2,"charIndex":982}],"domain":"","frontmatter":{},"version":"14.x"},{"id":101,"title":"Quick Start","content":"#\n\n\nInstallation#\n\nOpen a Terminal in your project's folder and run:\n\nThis library uses Test Renderer as its underlying rendering engine. Test\nRenderer is automatically installed as a dependency and provides better\ncompatibility with React 19 and improved type safety compared to the deprecated\nreact-test-renderer package.\n\n\nJest matchers#\n\nRNTL v13 automatically extends Jest with React Native-specific matchers. The\nonly thing you need to do is to import anything from\n@testing-library/react-native which you already need to do to access the render\nfunction.\n\n\nESLint plugin#\n\nWe recommend setting up eslint-plugin-testing-library package to help you avoid\ncommon Testing Library mistakes and bad practices.\n\nInstall the plugin (assuming you already have eslint installed & configured):\n\nThen, add relevant entry to your ESLint config (e.g., .eslintrc.js). We\nrecommend extending the react plugin:\n\n","routePath":"/react-native-testing-library/14.x/docs/start/quick-start","lang":"","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":3},{"text":"Jest matchers","id":"jest-matchers","depth":3,"charIndex":325},{"text":"ESLint plugin","id":"eslint-plugin","depth":3,"charIndex":563}],"domain":"","frontmatter":{},"version":"14.x"}]