"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["435"],{6942:function(e,n,t){t.r(n),t.d(n,{default:()=>c});var s=t(5893),r=t(65);function a(e){let n=Object.assign({h1:"h1",code:"code",a:"a",p:"p",h2:"h2",pre:"pre",h3:"h3",strong:"strong",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"understanding-act-function",children:["Understanding ",(0,s.jsx)(n.code,{children:"act"})," function",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#understanding-act-function",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["When writing RNTL tests one of the things that confuses developers the most are cryptic ",(0,s.jsx)(n.a,{href:"https://react.dev/link/wrap-tests-with-act",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"act()"})})," function errors logged into console. In this article I will try to build an understanding of the purpose and behaviour of ",(0,s.jsx)(n.code,{children:"act()"})," so you can build your tests with more confidence."]}),"\n",(0,s.jsxs)(n.h2,{id:"act-warning",children:[(0,s.jsx)(n.code,{children:"act"})," warning",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#act-warning",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Let's start with a typical ",(0,s.jsx)(n.code,{children:"act()"})," warning logged to console:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"An update to Root inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser.\nLearn more at https://react.dev/link/wrap-tests-with-act\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"understanding-act",children:["Understanding ",(0,s.jsx)(n.code,{children:"act"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#understanding-act",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"responsibility",children:["Responsibility",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#responsibility",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"This function is intended only for using in automated tests and works only in development mode. Attempting to use it in production build will throw an error."}),"\n",(0,s.jsxs)(n.p,{children:["The responsibility for ",(0,s.jsx)(n.code,{children:"act"})," function is to make React renders and updates work in tests in a similar way they work in real application by grouping and executing related units of interaction (e.g. renders, effects, etc) together."]}),"\n",(0,s.jsxs)(n.p,{children:["To showcase that behaviour let make a small experiment. First we define a function component that uses ",(0,s.jsx)(n.code,{children:"useEffect"})," hook in a trivial way."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function TestComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the following tests we will directly use ",(0,s.jsx)(n.a,{href:"https://github.com/mdjastrzebski/test-renderer",target:"_blank",rel:"noopener noreferrer",children:"Test Renderer"})," instead of RNTL ",(0,s.jsx)(n.code,{children:"render"})," function to render our component for tests. In order to expose familiar queries like ",(0,s.jsx)(n.code,{children:"getByText"})," we will use ",(0,s.jsx)(n.code,{children:"within"})," function from RNTL."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { createRoot } from 'test-renderer';\nimport { within } from '@testing-library/react-native';\n\ntest('render without act', () => {\n  const renderer = createRoot();\n  renderer.render(<TestComponent />);\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 0')).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When testing without ",(0,s.jsx)(n.code,{children:"act"})," call wrapping rendering call, we see that the assertion runs just after the rendering but before ",(0,s.jsx)(n.code,{children:"useEffect"})," hooks effects are applied. Which is not what we expected in our tests."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { createRoot } from 'test-renderer';\nimport { act, within } from '@testing-library/react-native';\n\ntest('render with act', async () => {\n  const renderer = createRoot();\n  await act(() => {\n    renderer.render(<TestComponent />);\n  });\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 1')).toBeTruthy();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": In v14, ",(0,s.jsx)(n.code,{children:"act"})," is now async by default and always returns a Promise. You should always use ",(0,s.jsx)(n.code,{children:"await act(...)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When wrapping rendering call with ",(0,s.jsx)(n.code,{children:"act"})," we see that the changes caused by ",(0,s.jsx)(n.code,{children:"useEffect"})," hook have been applied as we would expect."]}),"\n",(0,s.jsxs)(n.h3,{id:"when-to-use-act",children:["When to use act",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#when-to-use-act",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The name ",(0,s.jsx)(n.code,{children:"act"})," comes from ",(0,s.jsx)(n.a,{href:"http://wiki.c2.com/?ArrangeActAssert",target:"_blank",rel:"noopener noreferrer",children:"Arrange-Act-Assert"})," unit testing pattern. Which means it's related to part of the test when we execute some actions on the component tree."]}),"\n",(0,s.jsxs)(n.p,{children:["So far we learned that ",(0,s.jsx)(n.code,{children:"act"})," function allows tests to wait for all pending React interactions to be applied before we make our assertions. When using ",(0,s.jsx)(n.code,{children:"act"})," we get guarantee that any state updates will be executed as well as any enqueued effects will be executed."]}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, we should use ",(0,s.jsx)(n.code,{children:"act"})," whenever there is some action that causes element tree to render, particularly:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["initial render call - ",(0,s.jsx)(n.code,{children:"renderer.render"})," call"]}),"\n",(0,s.jsxs)(n.li,{children:["re-rendering of component - ",(0,s.jsx)(n.code,{children:"renderer.render"})," call with updated element"]}),"\n",(0,s.jsx)(n.li,{children:"triggering any event handlers that cause component tree render"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Thankfully, for these basic cases RNTL has got you covered as our ",(0,s.jsx)(n.code,{children:"render"}),", ",(0,s.jsx)(n.code,{children:"rerender"})," and ",(0,s.jsx)(n.code,{children:"fireEvent"})," methods already wrap their calls in ",(0,s.jsx)(n.code,{children:"act"})," so that you do not have to do it explicitly. In v14, these functions are all async and should be awaited."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that ",(0,s.jsx)(n.code,{children:"act"})," calls can be safely nested and internally form a stack of calls."]}),"\n",(0,s.jsxs)(n.h3,{id:"implementation",children:["Implementation",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#implementation",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"act"})," implementation is defined in the ",(0,s.jsx)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react/src/ReactAct.js",target:"_blank",rel:"noopener noreferrer",children:"ReactAct.js source file"})," inside React repository. RNTL v14 requires React 19+, which provides the ",(0,s.jsx)(n.code,{children:"act"})," function directly via ",(0,s.jsx)(n.code,{children:"React.act"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["RNTL exports ",(0,s.jsx)(n.code,{children:"act"})," for convenience of the users as defined in the ",(0,s.jsx)(n.a,{href:"https://github.com/callstack/react-native-testing-library/blob/main/src/act.ts",target:"_blank",rel:"noopener noreferrer",children:"act.ts source file"}),". In v14, ",(0,s.jsx)(n.code,{children:"act"})," is now async by default and always returns a Promise, making it compatible with async React features like ",(0,s.jsx)(n.code,{children:"Suspense"})," boundary or ",(0,s.jsx)(n.code,{children:"use()"})," hook. The underlying implementation wraps React's ",(0,s.jsx)(n.code,{children:"act"})," function to ensure consistent async behavior."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": You should always use ",(0,s.jsx)(n.code,{children:"act"})," exported from ",(0,s.jsx)(n.code,{children:"@testing-library/react-native"})," rather than the one from ",(0,s.jsx)(n.code,{children:"react"}),". The RNTL version automatically ensures async behavior, whereas using ",(0,s.jsx)(n.code,{children:"React.act"})," directly could still trigger synchronous act behavior if used improperly, leading to subtle test issues."]}),"\n",(0,s.jsxs)(n.h2,{id:"asynchronous-code",children:["Asynchronous code",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#asynchronous-code",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["In v14, ",(0,s.jsx)(n.code,{children:"act"})," is always async and returns a Promise. While the callback you pass to ",(0,s.jsx)(n.code,{children:"act"})," can be synchronous (dealing with things like synchronous effects or mocks using already resolved promises), the ",(0,s.jsx)(n.code,{children:"act"})," function itself should always be awaited. However, not all component code is synchronous. Frequently our components or mocks contain some asynchronous behaviours like ",(0,s.jsx)(n.code,{children:"setTimeout"})," calls or network calls."]}),"\n",(0,s.jsxs)(n.h3,{id:"handling-asynchronous-operations",children:["Handling asynchronous operations",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#handling-asynchronous-operations",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["When the callback passed to ",(0,s.jsx)(n.code,{children:"act"})," contains asynchronous operations, the Promise returned by ",(0,s.jsx)(n.code,{children:"act"})," will resolve only after those operations complete."]}),"\n",(0,s.jsxs)(n.p,{children:["Lets look at a simple example with component using ",(0,s.jsx)(n.code,{children:"setTimeout"})," call to simulate asynchronous behaviour:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function TestAsyncComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setTimeout(() => {\n      setCount((c) => c + 1);\n    }, 50);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { render, screen } from '@testing-library/react-native';\n\ntest('render async natively', async () => {\n  await render(<TestAsyncComponent />);\n  expect(screen.getByText('Count 0')).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we test our component in a native way without handling its asynchronous behaviour we will end up with an act warning. This is because the ",(0,s.jsx)(n.code,{children:"setTimeout"})," callback will trigger a state update after the test has finished."]}),"\n",(0,s.jsxs)(n.h3,{id:"solution-with-fake-timers",children:["Solution with fake timers",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#solution-with-fake-timers",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"First solution is to use Jest's fake timers inside out tests:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"test('render with fake timers', async () => {\n  jest.useFakeTimers();\n  await render(<TestAsyncComponent />);\n\n  await act(() => {\n    jest.runAllTimers();\n  });\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": In v14, both ",(0,s.jsx)(n.code,{children:"render"})," and ",(0,s.jsx)(n.code,{children:"act"})," are async by default, so you should await them."]}),"\n",(0,s.jsxs)(n.p,{children:["That way we can wrap ",(0,s.jsx)(n.code,{children:"jest.runAllTimers()"})," call which triggers the ",(0,s.jsx)(n.code,{children:"setTimeout"})," updates inside an ",(0,s.jsx)(n.code,{children:"act"})," call, hence resolving the act warning."]}),"\n",(0,s.jsxs)(n.h3,{id:"solution-with-real-timers",children:["Solution with real timers",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#solution-with-real-timers",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["If we wanted to stick with real timers then things get a bit more complex. Let's start by applying a crude solution of opening async ",(0,s.jsx)(n.code,{children:"act()"})," call for the expected duration of components updates:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"test('render with real timers - sleep', async () => {\n  await render(<TestAsyncComponent />);\n  await act(() => {\n    await sleep(100); // Wait a bit longer than setTimeout in `TestAsyncComponent`\n  });\n\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This works correctly as we use an explicit async ",(0,s.jsx)(n.code,{children:"act()"})," call that resolves the console error. However, it relies on our knowledge of exact implementation details which is a bad practice."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's try more elegant solution using ",(0,s.jsx)(n.code,{children:"waitFor"})," that will wait for our desired state:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"test('render with real timers - waitFor', async () => {\n  await render(<TestAsyncComponent />);\n\n  await waitFor(() => screen.getByText('Count 1'));\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This also works correctly, because ",(0,s.jsx)(n.code,{children:"waitFor"})," call executes async ",(0,s.jsx)(n.code,{children:"act()"})," call internally."]}),"\n",(0,s.jsxs)(n.p,{children:["The above code can be simplified using ",(0,s.jsx)(n.code,{children:"findBy"})," query:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"test('render with real timers - findBy', async () => {\n  await render(<TestAsyncComponent />);\n\n  expect(await screen.findByText('Count 1')).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This also works since ",(0,s.jsx)(n.code,{children:"findByText"})," internally calls ",(0,s.jsx)(n.code,{children:"waitFor"})," which uses async ",(0,s.jsx)(n.code,{children:"act()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that all of the above examples are async tests using & awaiting async ",(0,s.jsx)(n.code,{children:"act()"})," function call."]}),"\n",(0,s.jsxs)(n.h2,{id:"references",children:["References",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#references",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://github.com/facebook/react/blob/main/packages/react/src/ReactAct.js",target:"_blank",rel:"noopener noreferrer",children:["React ",(0,s.jsx)(n.code,{children:"act"})," implementation source"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://react.dev/link/wrap-tests-with-act",target:"_blank",rel:"noopener noreferrer",children:"React testing documentation"})}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["14.x%2Fdocs%2Fadvanced%2Funderstanding-act.mdx"]={toc:[{text:"`act` warning",id:"act-warning",depth:2},{text:"Understanding `act`",id:"understanding-act",depth:2},{text:"Responsibility",id:"responsibility",depth:3},{text:"When to use act",id:"when-to-use-act",depth:3},{text:"Implementation",id:"implementation",depth:3},{text:"Asynchronous code",id:"asynchronous-code",depth:2},{text:"Handling asynchronous operations",id:"handling-asynchronous-operations",depth:3},{text:"Solution with fake timers",id:"solution-with-fake-timers",depth:3},{text:"Solution with real timers",id:"solution-with-real-timers",depth:3},{text:"References",id:"references",depth:2}],title:"Understanding `act` function",headingTitle:"Understanding `act` function",frontmatter:{}}}}]);