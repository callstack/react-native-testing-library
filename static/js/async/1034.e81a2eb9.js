"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["1034"],{8365:function(t,e,n){n.r(e),n.d(e,{default:()=>r});var s=n(5893),a=n(65);function i(t){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",div:"div"},(0,a.ah)(),t.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"jotai",children:["Jotai",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#jotai",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"introduction",children:["Introduction",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#introduction",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Jotai is a global state management library for React that uses an atomic approach to optimize\nrenders and solve issues like extra re-renders and the need for memoization. It scales from simple\nstate management to complex enterprise applications, offering utilities and extensions to enhance\nthe developer experience."}),"\n",(0,s.jsxs)(e.h2,{id:"task-list-example",children:["Task List Example",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#task-list-example",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Let's assume we have a simple task list component that uses Jotai for state management. The\ncomponent has a list of tasks, a text input for typing new task name and a button to add a new task to the list."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=state-management/jotai/TaskList.tsx",children:"import * as React from 'react';\nimport { Pressable, Text, TextInput, View } from 'react-native';\nimport { useAtom } from 'jotai';\nimport { nanoid } from 'nanoid';\nimport { newTaskTitleAtom, tasksAtom } from './state';\n\nexport function TaskList() {\n  const [tasks, setTasks] = useAtom(tasksAtom);\n  const [newTaskTitle, setNewTaskTitle] = useAtom(newTaskTitleAtom);\n\n  const handleAddTask = () => {\n    setTasks((tasks) => [\n      ...tasks,\n      {\n        id: nanoid(),\n        title: newTaskTitle,\n      },\n    ]);\n    setNewTaskTitle('');\n  };\n\n  return (\n    <View>\n      {tasks.map((task) => (\n        <Text key={task.id} testID=\"task-item\">\n          {task.title}\n        </Text>\n      ))}\n\n      {!tasks.length ? <Text>No tasks, start by adding one...</Text> : null}\n\n      <TextInput\n        accessibilityLabel=\"New Task\"\n        placeholder=\"New Task...\"\n        value={newTaskTitle}\n        onChangeText={(text) => setNewTaskTitle(text)}\n      />\n\n      <Pressable accessibilityRole=\"button\" onPress={handleAddTask}>\n        <Text>Add Task</Text>\n      </Pressable>\n    </View>\n  );\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"starting-with-a-simple-test",children:["Starting with a Simple Test",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#starting-with-a-simple-test",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["We can test our ",(0,s.jsx)(e.code,{children:"TaskList"})," component using React Native Testing Library's (RNTL) regular ",(0,s.jsx)(e.code,{children:"render"}),"\nfunction. Although it is sufficient to test the empty state of the ",(0,s.jsx)(e.code,{children:"TaskList"})," component, it is not\nenough to test the component with initial tasks present in the list."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=status-management/jotai/__tests__/TaskList.test.tsx",children:"import * as React from 'react';\nimport { render, screen, userEvent } from '@testing-library/react-native';\nimport { renderWithAtoms } from './test-utils';\nimport { TaskList } from './TaskList';\nimport { newTaskTitleAtom, tasksAtom } from './state';\nimport { Task } from './types';\n\njest.useFakeTimers();\n\ntest('renders an empty task list', () => {\n  render(<TaskList />);\n  expect(screen.getByText(/no tasks, start by adding one/i)).toBeOnTheScreen();\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"custom-render-function-to-populate-jotai-atoms-with-initial-values",children:["Custom Render Function to populate Jotai Atoms with Initial Values",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#custom-render-function-to-populate-jotai-atoms-with-initial-values",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["To test the ",(0,s.jsx)(e.code,{children:"TaskList"})," component with initial tasks, we need to be able to populate the ",(0,s.jsx)(e.code,{children:"tasksAtom"})," with\ninitial values. We can create a custom render function that uses Jotai's ",(0,s.jsx)(e.code,{children:"useHydrateAtoms"})," hook to\nhydrate the atoms with initial values. This function will accept the initial atoms and their\ncorresponding values as an argument."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=status-management/jotai/test-utils.tsx",children:"import * as React from 'react';\nimport { render } from '@testing-library/react-native';\nimport { useHydrateAtoms } from 'jotai/utils';\nimport { PrimitiveAtom } from 'jotai/vanilla/atom';\n\n// Jotai types are not well exported, so we will make our life easier by using `any`.\nexport type AtomInitialValueTuple<T> = [PrimitiveAtom<T>, T];\n\nexport interface RenderWithAtomsOptions {\n  initialValues: AtomInitialValueTuple<any>[];\n}\n\n/**\n * Renders a React component with Jotai atoms for testing purposes.\n *\n * @param component - The React component to render.\n * @param options - The render options including the initial atom values.\n * @returns The render result from `@testing-library/react-native`.\n */\nexport const renderWithAtoms = <T,>(\n  component: React.ReactElement,\n  options: RenderWithAtomsOptions\n) => {\n  return render(\n    <HydrateAtomsWrapper initialValues={options.initialValues}>{component}</HydrateAtomsWrapper>\n  );\n};\n\nexport type HydrateAtomsWrapperProps = React.PropsWithChildren<{\n  initialValues: AtomInitialValueTuple<unknown>[];\n}>;\n\n/**\n * A wrapper component that hydrates Jotai atoms with initial values.\n *\n * @param initialValues - The initial values for the Jotai atoms.\n * @param children - The child components to render.\n * @returns The rendered children.\n\n */\nfunction HydrateAtomsWrapper({ initialValues, children }: HydrateAtomsWrapperProps) {\n  useHydrateAtoms(initialValues);\n  return children;\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"testing-the-tasklist-component-with-initial-tasks",children:["Testing the ",(0,s.jsx)(e.code,{children:"TaskList"})," Component with initial tasks",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#testing-the-tasklist-component-with-initial-tasks",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["We can now use the ",(0,s.jsx)(e.code,{children:"renderWithAtoms"})," function to render the ",(0,s.jsx)(e.code,{children:"TaskList"})," component with initial tasks. The\n",(0,s.jsx)(e.code,{children:"initialValues"})," property will contain the ",(0,s.jsx)(e.code,{children:"tasksAtom"}),", ",(0,s.jsx)(e.code,{children:"newTaskTitleAtom"})," and their initial values. We can then test the component to ensure that the initial tasks are rendered correctly."]}),"\n",(0,s.jsxs)(e.div,{className:"rspress-directive info",children:[(0,s.jsx)(e.div,{className:"rspress-directive-title",children:"INFO"}),(0,s.jsx)(e.div,{className:"rspress-directive-content",children:(0,s.jsx)(e.p,{children:"In our test, we populated only one atom and its initial value, but you can add other Jotai atoms and their corresponding values to the initialValues array as needed."})})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=status-management/jotai/__tests__/TaskList.test.tsx",children:"=======\nconst INITIAL_TASKS: Task[] = [{ id: '1', title: 'Buy bread' }];\n\ntest('renders a to do list with 1 items initially, and adds a new item', async () => {\n  renderWithAtoms(<TaskList />, {\n    initialValues: [\n      [tasksAtom, INITIAL_TASKS],\n      [newTaskTitleAtom, ''],\n    ],\n  });\n\n  expect(screen.getByText(/buy bread/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(1);\n\n  const user = userEvent.setup();\n  await user.type(screen.getByPlaceholderText(/new task/i), 'Buy almond milk');\n  await user.press(screen.getByRole('button', { name: /add task/i }));\n\n  expect(screen.getByText(/buy almond milk/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(2);\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"modifying-atom-outside-of-react-components",children:["Modifying atom outside of React components",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#modifying-atom-outside-of-react-components",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"In several cases, you might need to change an atom's state outside a React component. In our case,\nwe have a set of functions to get tasks and set tasks, which change the state of the task list atom."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=state-management/jotai/state.ts",children:"import { atom, createStore } from 'jotai';\nimport { Task } from './types';\n\nexport const tasksAtom = atom<Task[]>([]);\nexport const newTaskTitleAtom = atom('');\n\n// Available for use outside React components\nexport const store = createStore();\n\n// Selectors\nexport function getAllTasks(): Task[] {\n  return store.get(tasksAtom);\n}\n\n// Actions\nexport function addTask(task: Task) {\n  store.set(tasksAtom, [...getAllTasks(), task]);\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"testing-atom-outside-of-react-components",children:["Testing atom outside of React components",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#testing-atom-outside-of-react-components",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["You can test the ",(0,s.jsx)(e.code,{children:"getAllTasks"})," and ",(0,s.jsx)(e.code,{children:"addTask"})," functions outside the React component's scope by setting\nthe initial to-do items in the store and then checking if the functions work as expected.\nNo special setup is required to test these functions, as ",(0,s.jsx)(e.code,{children:"store.set"})," is available by default by\nJotai."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",meta:"title=state-management/jotai/__tests__/TaskList.test.tsx",children:"import { addTask, getAllTasks, store, tasksAtom } from './state';\n\n//...\n\ntest('modify store outside of React component', () => {\n  // Set the initial to do items in the store\n  store.set(tasksAtom, INITIAL_TASKS);\n  expect(getAllTasks()).toEqual(INITIAL_TASKS);\n\n  const NEW_TASK = { id: '2', title: 'Buy almond milk' };\n  addTask(NEW_TASK);\n  expect(getAllTasks()).toEqual([...INITIAL_TASKS, NEW_TASK]);\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"conclusion",children:["Conclusion",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#conclusion",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Testing a component or a function that depends on Jotai atoms is straightforward with the help of\nthe ",(0,s.jsx)(e.code,{children:"useHydrateAtoms"})," hook. We've seen how to create a custom render function ",(0,s.jsx)(e.code,{children:"renderWithAtoms"})," that\nsets up atoms and their initial values for testing purposes. We've also seen how to test functions\nthat change the state of atoms outside React components. This approach allows us to test components\nin different states and scenarios, ensuring they behave as expected."]})]})}function o(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),t.components);return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(i,{...t})}):i(t)}let r=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["13.x%2Fcookbook%2Fstate-management%2Fjotai.md"]={toc:[{text:"Introduction",id:"introduction",depth:2},{text:"Task List Example",id:"task-list-example",depth:2},{text:"Starting with a Simple Test",id:"starting-with-a-simple-test",depth:2},{text:"Custom Render Function to populate Jotai Atoms with Initial Values",id:"custom-render-function-to-populate-jotai-atoms-with-initial-values",depth:2},{text:"Testing the `TaskList` Component with initial tasks",id:"testing-the-tasklist-component-with-initial-tasks",depth:2},{text:"Modifying atom outside of React components",id:"modifying-atom-outside-of-react-components",depth:2},{text:"Testing atom outside of React components",id:"testing-atom-outside-of-react-components",depth:2},{text:"Conclusion",id:"conclusion",depth:2}],title:"Jotai",headingTitle:"Jotai",frontmatter:{}}}}]);