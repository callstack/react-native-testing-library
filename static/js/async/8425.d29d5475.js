"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["8425"],{6620:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var t=r(5893),s=r(65);function o(e){let n=Object.assign({h1:"h1",code:"code",a:"a",h2:"h2",pre:"pre",p:"p",strong:"strong",ul:"ul",li:"li",h3:"h3",h4:"h4"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"renderhook-function",children:[(0,t.jsx)(n.code,{children:"renderHook"})," function",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#renderhook-function",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"renderhook",children:[(0,t.jsx)(n.code,{children:"renderHook"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#renderhook",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"async function renderHook<Result, Props>(\n  hookFn: (props: Props) => Result,\n  options?: RenderHookOptions<Props>\n): Promise<RenderHookResult<Result, Props>>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Renders a test component that will call the provided ",(0,t.jsx)(n.code,{children:"callback"}),", including any hooks it calls, every time it renders. Returns a Promise that resolves to a ",(0,t.jsx)(n.a,{href:"#renderhookresult",children:(0,t.jsx)(n.code,{children:"RenderHookResult"})})," object, which you can interact with."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"This is the recommended default API"})," for testing hooks. It uses async ",(0,t.jsx)(n.code,{children:"act"})," internally to ensure all pending React updates are executed during rendering, making it compatible with async React features like ",(0,t.jsx)(n.code,{children:"Suspense"})," boundary or ",(0,t.jsx)(n.code,{children:"use()"})," hook."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Returns a Promise"}),": Should be awaited"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Async methods"}),": Both ",(0,t.jsx)(n.code,{children:"rerender"})," and ",(0,t.jsx)(n.code,{children:"unmount"})," return Promises and should be awaited"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Suspense support"}),": Compatible with ",(0,t.jsx)(n.code,{children:"Suspense"})," boundaries and ",(0,t.jsx)(n.code,{children:"use()"})," hook"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { renderHook, act } from '@testing-library/react-native';\nimport { useCount } from '../useCount';\n\nit('should increment count', async () => {\n  const { result } = await renderHook(() => useCount());\n\n  expect(result.current.count).toBe(0);\n  await act(() => {\n    // Note that you should wrap the calls to functions your hook returns with `act` if they trigger an update of your hook's state to ensure pending useEffects are run before your next assertion.\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// useCount.js\nimport { useState } from 'react';\n\nexport const useCount = () => {\n  const [count, setCount] = useState(0);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  return { count, increment };\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"renderHook"})," function accepts the following arguments:"]}),"\n",(0,t.jsxs)(n.p,{children:["Callback is a function that is called each ",(0,t.jsx)(n.code,{children:"render"})," of the test component. This function should call one or more hooks for testing."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"props"})," passed into the callback will be the ",(0,t.jsx)(n.code,{children:"initialProps"})," provided in the ",(0,t.jsx)(n.code,{children:"options"})," to ",(0,t.jsx)(n.code,{children:"renderHook"}),", unless new props are provided by a subsequent ",(0,t.jsx)(n.code,{children:"rerender"})," call."]}),"\n",(0,t.jsxs)(n.h3,{id:"options",children:[(0,t.jsx)(n.code,{children:"options"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#options",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"RenderHookOptions<Props>"})," object to modify the execution of the ",(0,t.jsx)(n.code,{children:"callback"})," function, containing the following properties:"]}),"\n",(0,t.jsxs)(n.h4,{id:"initial-props",children:[(0,t.jsx)(n.code,{children:"initialProps"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#initial-props",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The initial values to pass as ",(0,t.jsx)(n.code,{children:"props"})," to the ",(0,t.jsx)(n.code,{children:"callback"})," function of ",(0,t.jsx)(n.code,{children:"renderHook"}),". The ",(0,t.jsx)(n.code,{children:"Props"})," type is determined by the type passed to or inferred by the ",(0,t.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,t.jsxs)(n.h4,{id:"wrapper",children:[(0,t.jsx)(n.code,{children:"wrapper"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#wrapper",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["A React component to wrap the test component in when rendering. This is usually used to add context providers from ",(0,t.jsx)(n.code,{children:"React.createContext"})," for the hook to access with ",(0,t.jsx)(n.code,{children:"useContext"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"result",children:["Result",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#result",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface RenderHookResult<Result, Props> {\n  result: { current: Result };\n  rerender: (props: Props) => Promise<void>;\n  unmount: () => Promise<void>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"renderHook"})," function returns a Promise that resolves to an object with the following properties:"]}),"\n",(0,t.jsxs)(n.h4,{id:"result-1",children:[(0,t.jsx)(n.code,{children:"result"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#result-1",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"current"})," value of the ",(0,t.jsx)(n.code,{children:"result"})," will reflect the latest of whatever is returned from the ",(0,t.jsx)(n.code,{children:"callback"})," passed to ",(0,t.jsx)(n.code,{children:"renderHook"}),". The ",(0,t.jsx)(n.code,{children:"Result"})," type is determined by the type passed to or inferred by the ",(0,t.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," When using React Suspense, ",(0,t.jsx)(n.code,{children:"result.current"})," will be ",(0,t.jsx)(n.code,{children:"null"})," while the hook is suspended."]}),"\n",(0,t.jsxs)(n.h4,{id:"rerender",children:[(0,t.jsx)(n.code,{children:"rerender"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rerender",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["An async function to rerender the test component, causing any hooks to be recalculated. If ",(0,t.jsx)(n.code,{children:"newProps"})," are passed, they will replace the ",(0,t.jsx)(n.code,{children:"callback"})," function's ",(0,t.jsx)(n.code,{children:"initialProps"})," for subsequent rerenders. The ",(0,t.jsx)(n.code,{children:"Props"})," type is determined by the type passed to or inferred by the ",(0,t.jsx)(n.code,{children:"renderHook"})," call."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": This method returns a Promise and should be awaited."]}),"\n",(0,t.jsxs)(n.h4,{id:"unmount",children:[(0,t.jsx)(n.code,{children:"unmount"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#unmount",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["An async function to unmount the test component. This is commonly used to trigger cleanup effects for ",(0,t.jsx)(n.code,{children:"useEffect"})," hooks."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": This method returns a Promise and should be awaited."]}),"\n",(0,t.jsxs)(n.h3,{id:"examples",children:["Examples",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#examples",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Here we present some extra examples of using ",(0,t.jsx)(n.code,{children:"renderHook"})," API."]}),"\n",(0,t.jsxs)(n.h4,{id:"with-initialprops",children:["With ",(0,t.jsx)(n.code,{children:"initialProps"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#with-initialprops",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { useState, useEffect } from 'react';\nimport { renderHook, act } from '@testing-library/react-native';\n\nconst useCount = (initialCount: number) => {\n  const [count, setCount] = useState(initialCount);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  useEffect(() => {\n    setCount(initialCount);\n  }, [initialCount]);\n\n  return { count, increment };\n};\n\nit('should increment count', async () => {\n  const { result, rerender } = await renderHook((initialCount: number) => useCount(initialCount), {\n    initialProps: 1,\n  });\n\n  expect(result.current.count).toBe(1);\n\n  await act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(2);\n  await rerender(5);\n  expect(result.current.count).toBe(5);\n});\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"with-wrapper",children:["With ",(0,t.jsx)(n.code,{children:"wrapper"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#with-wrapper",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"it('should use context value', async () => {\n  function Wrapper({ children }: { children: ReactNode }) {\n    return <Context.Provider value=\"provided\">{children}</Context.Provider>;\n  }\n\n  const { result } = await renderHook(() => useHook(), { wrapper: Wrapper });\n  // ...\n});\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"with-react-suspense",children:["With React Suspense",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#with-react-suspense",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { renderHook, act } from '@testing-library/react-native';\nimport { Text } from 'react-native';\n\nfunction useSuspendingHook(promise: Promise<string>) {\n  return React.use(promise);\n}\n\nit('handles hook with suspense', async () => {\n  let resolvePromise: (value: string) => void;\n  const promise = new Promise<string>((resolve) => {\n    resolvePromise = resolve;\n  });\n\n  const { result } = await renderHook(useSuspendingHook, {\n    initialProps: promise,\n    wrapper: ({ children }) => (\n      <React.Suspense fallback={<Text>Loading...</Text>}>{children}</React.Suspense>\n    ),\n  });\n\n  // Initially suspended, result should not be available\n  expect(result.current).toBeNull();\n\n  await act(() => resolvePromise('resolved'));\n  expect(result.current).toBe('resolved');\n});\n"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["14.x%2Fdocs%2Fapi%2Fmisc%2Frender-hook.mdx"]={toc:[{text:"`renderHook`",id:"renderhook",depth:2},{text:"`options`",id:"options",depth:3},{text:"`initialProps`",id:"initial-props",depth:4},{text:"`wrapper`",id:"wrapper",depth:4},{text:"Result",id:"result",depth:3},{text:"`result`",id:"result-1",depth:4},{text:"`rerender`",id:"rerender",depth:4},{text:"`unmount`",id:"unmount",depth:4},{text:"Examples",id:"examples",depth:3},{text:"With `initialProps`",id:"with-initialprops",depth:4},{text:"With `wrapper`",id:"with-wrapper",depth:4},{text:"With React Suspense",id:"with-react-suspense",depth:4}],title:"`renderHook` function",headingTitle:"`renderHook` function",frontmatter:{}}}}]);