[{"title":"Network Requests","content":"## Introduction\n\nMocking network requests is an essential part of testing React Native applications. By mocking\nnetwork\nrequests, you can control the data that is returned from the server and test how your application\nbehaves in different scenarios, such as when the request is successful or when it fails.\n\nIn this guide, we will show you how to mock network requests and guard your test suits from unwanted\nand unmocked/unhandled network requests\n\n:::info\nTo simulate a real-world scenario, we will use the [Random User Generator API]() that provides random user data.\n:::\n\n## Phonebook Example\n\nLet's assume we have a simple phonebook application that\nuses [`fetch`]() for fetching Data from a server.\nIn our case, we have a list of contacts and favorites that we want to display in our application.\n\nThis is how the root of the application looks like:\n\n```tsx title=network-requests/Phonebook.tsx\n\n\n\n\n\n\n\n\nexport default () => {\n  const [usersData, setUsersData] = useState<User[]>([]);\n  const [favoritesData, setFavoritesData] = useState<User[]>([]);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const _getAllContacts = async () => {\n      const _data = await getAllContacts();\n      setUsersData(_data);\n    };\n    const _getAllFavorites = async () => {\n      const _data = await getAllFavorites();\n      setFavoritesData(_data);\n    };\n\n    const run = async () => {\n      try {\n        await Promise.all([_getAllContacts(), _getAllFavorites()]);\n      } catch (e) {\n        const message = isErrorWithMessage(e) ? e.message : 'Something went wrong';\n        setError(message);\n      }\n    };\n\n    void run();\n  }, []);\n\n  if (error) {\n    return <Text>An error occurred: {error}</Text>;\n  }\n\n  return (\n    <>\n      <FavoritesList users={favoritesData} />\n      <ContactsList users={usersData} />\n    </>\n  );\n};\n```\n\nWe fetch the contacts from the server using the `getAllFavorites` function that utilizes `fetch`.\n\n```tsx title=network-requests/api/getAllContacts.ts\n\n\nexport default async (): Promise<User[]> => {\n  const res = await fetch('https://randomuser.me/api/?results=25');\n  if (!res.ok) {\n    throw new Error(`Error fetching contacts`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n```\n\nWe have similar function for fetching the favorites, but this time limiting the results to 10.\n\n```tsx title=network-requests/api/getAllFavorites.ts\n\n\nexport default async (): Promise<User[]> => {\n  const res = await fetch('https://randomuser.me/api/?results=10');\n  if (!res.ok) {\n    throw new Error(`Error fetching favorites`);\n  }\n  const json = await res.json();\n  return json.results;\n};\n```\n\nOur `FavoritesList` component is a simple component that displays the list of favorite contacts and\ntheir avatars horizontally.\n\n```tsx title=network-requests/components/FavoritesList.tsx\n\n\n\n\n\nexport default ({users}: { users: User[] }) => {\n  const renderItem: ListRenderItem<User> = useCallback(({item: {picture}}) => {\n    return (\n      <View style={styles.userContainer}>\n        <Image\n          source={{uri: picture.thumbnail}}\n          style={styles.userImage}\n          accessibilityLabel={'favorite-contact-avatar'}\n        />\n      </View>\n    );\n  }, []);\n\n  if (users.length === 0) return (\n    <View style={styles.loaderContainer}>\n      <Text>Figuring out your favorites...</Text>\n    </View>\n  );\n\n  return (\n    <View style={styles.outerContainer}>\n      <Text>⭐My Favorites</Text>\n      <FlatList<User>\n        horizontal\n        showsHorizontalScrollIndicator={false}\n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    </View>\n  );\n};\n\n// Looking for styles?\n// Check examples/cookbook/app/advanced/components/FavoritesList.tsx\nconst styles =\n...\n```\n\nOur `ContactsList` component is similar to the `FavoritesList` component, but it displays the list\nof\nall contacts vertically.\n\n```tsx title=network-requests/components/ContactsList.tsx\n\n\n\n\n\nexport default ({ users }: { users: User[] }) => {\n  const renderItem: ListRenderItem<User> = useCallback(\n    ({ item: { name, email, picture, cell }, index }) => {\n      const { title, first, last } = name;\n      const backgroundColor = index % 2 === 0 ? '#f9f9f9' : '#fff';\n      return (\n        <View style={[{ backgroundColor }, styles.userContainer]}>\n          <Image source={{ uri: picture.thumbnail }} style={styles.userImage} />\n          <View>\n            <Text>\n              Name: {title} {first} {last}\n            </Text>\n            <Text>Email: {email}</Text>\n            <Text>Mobile: {cell}</Text>\n          </View>\n        </View>\n      );\n    },\n    [],\n  );\n\n  if (users.length === 0) return <FullScreenLoader />;\n\n  return (\n    <View>\n      <FlatList<User>\n        data={users}\n        renderItem={renderItem}\n        keyExtractor={(item, index) => `${index}-${item.id.value}`}\n      />\n    </View>\n  );\n};\n\n// Looking for styles or FullScreenLoader component?\n// Check examples/cookbook/app/advanced/components/ContactsList.tsx\nconst FullScreenLoader = () => ...\nconst styles = ...\n```\n\n## Start testing with a simple test\n\nIn our initial test we would like to test if the `PhoneBook` component renders the `FavoritesList`\nand `ContactsList` components correctly.\nWe will need to mock the network requests and their corresponding responses to ensure that the component behaves as\nexpected. To mock the network requests we will use [MSW (Mock Service Worker)]().\n\n:::note\nWe recommend using the Mock Service Worker (MSW) library to declaratively mock API communication in your tests instead of stubbing `fetch`, or relying on third-party adapters.\n:::\n\n:::info\nYou can install MSW by running `npm install msw --save-dev` or `yarn add msw --dev`.\nMore info regarding installation can be found in [MSW's getting started guide]().\n\nPlease make sure you're also aware of [MSW's setup guide]().\nPlease be minded that the MSW's setup guide is potentially incomplete and might contain discrepancies/missing pieces.\n:::\n\n```tsx title=network-requests/Phonebook.test.tsx\n\n\n\n\n\n\n\n// Define request handlers and response resolvers for random user API.\n// By default, we always return the happy path response.\nconst handlers = [\n  http.get('https://randomuser.me/api/*', () => {\n    return HttpResponse.json(DATA);\n  }),\n];\n\n// Setup a request interception server with the given request handlers.\nconst server = setupServer(...handlers);\n\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\ndescribe('PhoneBook', () => {\n  it('fetches all contacts and favorites successfully and renders lists in sections correctly', async () => {\n    await render(<PhoneBook />);\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(await screen.findByText('Name: Mrs Ida Kristensen')).toBeOnTheScreen();\n    expect(await screen.findByText('Email: ida.kristensen@example.com')).toBeOnTheScreen();\n    expect(await screen.findAllByText(/name/i)).toHaveLength(3);\n    expect(await screen.findByText(/my favorites/i)).toBeOnTheScreen();\n    expect(await screen.findAllByLabelText('favorite-contact-avatar')).toHaveLength(3);\n  });\n});\n\nconst DATA: { results: User[] } = {\n  results: [\n    {\n      name: {\n        title: 'Mrs',\n        first: 'Ida',\n        last: 'Kristensen',\n      },\n      email: 'ida.kristensen@example.com',\n      id: {\n        name: 'CPR',\n        value: '250562-5730',\n      },\n      picture: {\n        large: 'https://randomuser.me/api/portraits/women/26.jpg',\n        medium: 'https://randomuser.me/api/portraits/med/women/26.jpg',\n        thumbnail: 'https://randomuser.me/api/portraits/thumb/women/26.jpg',\n      },\n      cell: '123-4567-890',\n    },\n    // For brevity, we have omitted the rest of the users, you can still find them in\n    // examples/cookbook/app/network-requests/__tests__/test-utils.ts\n    ...\n  ],\n};\n```\n\n:::info\nMore info regarding how to describe the network using request handlers, intercepting a request and handling its response can be found in the [MSW's documentation]().\n:::\n\n## Testing error handling\n\nAs we are dealing with network requests, and things can go wrong, we should also cover the case when\nthe API request fails. In this case, we would like to test how our application behaves when the API request fails.\n\n:::info\nThe nature of the network can be highly dynamic, which makes it challenging to describe it completely in a fixed list of request handlers.\nMSW provides us the means to override any particular network behavior using the designated `.use()` API.\nMore info can be found in [MSW's Network behavior overrides documentation]()\n:::\n\n```tsx title=network-requests/Phonebook.test.tsx\n...\n\nconst mockServerFailureForGetAllContacts = () => {\n  server.use(\n    http.get('https://randomuser.me/api/', ({ request }) => {\n      // Construct a URL instance out of the intercepted request.\n      const url = new URL(request.url);\n      // Read the \"results\" URL query parameter using the \"URLSearchParams\" API.\n      const resultsLength = url.searchParams.get('results');\n      // Simulate a server error for the get all contacts request.\n      // We check if the \"results\" query parameter is set to \"25\"\n      // to know it's the correct request to mock, in our case get all contacts.\n      if (resultsLength === '25') {\n        return new HttpResponse(null, { status: 500 });\n      }\n      // Return the default response for all other requests that match URL and verb. (in our case get favorites)\n      return HttpResponse.json(DATA);\n    }),\n  );\n};\n\ndescribe('PhoneBook', () => {\n...\n  it('fails to fetch all contacts and renders error message', async () => {\n    mockServerFailureForGetAllContacts();\n    await render(<PhoneBook />);\n\n    await waitForElementToBeRemoved(() => screen.getByText(/users data not quite there yet/i));\n    expect(\n      await screen.findByText(/an error occurred: error fetching contacts/i),\n    ).toBeOnTheScreen();\n  });\n});\n\n```\n\n## Global guarding against unwanted API requests\n\nAs mistakes may happen, we might forget to mock a network request in one of our tests in the future.\nTo prevent us from happening, and alert when a certain network request is left unhandled, you may choose to\nmove MSW's server management from `PhoneBook.test.tsx` to Jest's setup file via [`setupFilesAfterEnv`]().\n\n```tsx title=examples/cookbook/jest-setup.ts\n// Enable API mocking via Mock Service Worker (MSW)\nbeforeAll(() => server.listen());\n// Reset any runtime request handlers we may add during the tests\nafterEach(() => server.resetHandlers());\n// Disable API mocking after the tests are done\nafterAll(() => server.close());\n\n// ... rest of your setup file\n```\n\nThis setup will ensure you have the MSW server running before any test suite starts and stops it after all tests are done.\nWhich will result in a warning in the console if you forget to mock an API request in your test suite.\n\n```bash\n[MSW] Warning: intercepted a request without a matching request handler:\n • GET https://randomuser.me/api/?results=25?results=25\n```\n\n## Conclusion\n\nTesting a component that makes network requests in combination with MSW takes some initial preparation to configure and describe the overridden networks.\nWe can achieve that by using MSW's request handlers and intercepting APIs.\n\nOnce up and running we gain full grip over the network requests, their responses, statuses.\nDoing so is crucial to be able to test how our application behaves in different\nscenarios, such as when the request is successful or when it fails.\n\nWhen global configuration is in place, MSW's will also warn us when an unhandled network requests has occurred throughout a test suite.\n\n## Further Reading and Alternatives\n\nExplore more advanced scenarios for mocking network requests with MSW:\n\n- MSW's Basics - [Intercepting requests]() and/or [Mocking responses]()\n- MSW's Network behavior - how to describe [REST]() and/or [GraphQL]() APIs\n","routePath":"/14.x/cookbook/advanced/network-requests","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2,"charIndex":0},{"id":"phonebook-example","text":"Phonebook Example","depth":2,"charIndex":576},{"id":"start-testing-with-a-simple-test","text":"Start testing with a simple test","depth":2,"charIndex":5125},{"id":"testing-error-handling","text":"Testing error handling","depth":2,"charIndex":8316},{"id":"global-guarding-against-unwanted-api-requests","text":"Global guarding against unwanted API requests","depth":2,"charIndex":10218},{"id":"conclusion","text":"Conclusion","depth":2,"charIndex":11308},{"id":"further-reading-and-alternatives","text":"Further Reading and Alternatives","depth":2,"charIndex":11931}],"frontmatter":{},"version":"14.x"},{"title":"Async Events","content":"## Summary\n\nIn RNTL v14, all tests are async since `render()`, `fireEvent()`, and other core APIs return Promises. Beyond the basic async APIs, there are additional async utilities for handling events that complete over time:\n\n1. **Waiting for elements to appear**: Use `findBy*` queries when elements appear after some delay (e.g., after data fetching).\n2. **Waiting for conditions**: Use `waitFor()` to wait for arbitrary conditions to be met.\n3. **Waiting for elements to disappear**: Use `waitForElementToBeRemoved()` when elements should be removed after some action.\n\nThese utilities help you write reliable tests that properly handle timing in your application.\n\n### Example\n\nConsider a test for a user signing in with correct credentials:\n\n```javascript\ntest('User can sign in with correct credentials', async () => {\n  // Typical test setup\n  const user = userEvent.setup();\n  await render(<App />);\n\n  // No need to use async here, components are already rendered\n  expect(screen.getByRole('header', { name: 'Sign in to Hello World App!' })).toBeOnTheScreen();\n\n  // Using await as User Event requires it\n  await user.type(screen.getByLabelText('Username'), 'admin');\n  await user.type(screen.getByLabelText('Password'), 'admin1');\n  await user.press(screen.getByRole('button', { name: 'Sign In' }));\n\n  // Using await as sign in operation is asynchronous\n  expect(await screen.findByRole('header', { name: 'Welcome admin!' })).toBeOnTheScreen();\n\n  // Follow-up assertions do not need to be async, as we already waited for sign in operation to complete\n  expect(\n    screen.queryByRole('header', { name: 'Sign in to Hello World App' })\n  ).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Username')).not.toBeOnTheScreen();\n  expect(screen.queryByLabelText('Password')).not.toBeOnTheScreen();\n});\n```\n\n## Async utilities\n\nThere are several asynchronous utilities you might use in your tests.\n\n### `findBy*` queries\n\nThe most common are the [`findBy*` queries](). These are useful when waiting for a matching element to appear. They can be understood as a [`getBy*` queries]() used in conjunction with a [`waitFor` function]().\n\nThey accept the same predicates as `getBy*` queries like `findByRole`, `findByTest`, etc. They also have a multiple elements variant called [`findAllBy*`]().\n\n```typescript\nfunction findByRole: (\n  role: TextMatch,\n  queryOptions?: {\n    // Query specific options\n  }\n  waitForOptions?: {\n    timeout?: number;\n    interval?: number;\n    // ..\n  }\n): Promise<HostElement>;\n```\n\nEach query has a default `timeout` value of 1000 ms and a default `interval` of 50 ms. Custom timeout and check intervals can be specified if needed, as shown below:\n\n#### Example\n\n```typescript\nconst button = await screen.findByRole(\n  'button',\n  { name: 'Start' },\n  { timeout: 1000, interval: 50 }\n);\n```\n\nAlternatively, a default global `timeout` value can be set using the [`configure` function]():\n\n```typescript\nconfigure({ asyncUtilTimeout: timeout });\n```\n\n### `waitFor` function\n\nThe `waitFor` function is another option, serving as a lower-level utility in more advanced cases.\n\n```typescript\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T>;\n```\n\nIt accepts an `expectation` to be validated and repeats the check every defined interval until it no longer throws an error. Similarly to `findBy*` queries they accept `timeout` and `interval` options and have the same default values of 1000ms for timeout, and a checking interval of 50 ms.\n\n#### Example\n\n```typescript\nawait waitFor(() => expect(mockAPI).toHaveBeenCalledTimes(1));\n```\n\nIf you want to use it with `getBy*` queries, use the `findBy*` queries instead, as they essentially do the same, but offer better developer experience.\n\n### `waitForElementToBeRemoved` function\n\nA specialized function, [`waitForElementToBeRemoved`](), is used to verify that a matching element was present but has since been removed.\n\n```typescript\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: {\n    timeout: number;\n    interval: number;\n  }\n): Promise<T> {}\n```\n\nThis function is, in a way, the negation of `waitFor` as it expects the initial expectation to be true (not throw an error), only to turn invalid (start throwing errors) on subsequent runs. It operates using the same `timeout` and `interval` parameters as `findBy*` queries and `waitFor`.\n\n#### Example\n\n```typescript\nawait waitForElementToBeRemoved(() => getByText('Hello World'));\n```\n\n## Fake Timers\n\nAsynchronous tests can take long to execute due to the delays introduced by asynchronous operations. To mitigate this, fake timers can be used. These are particularly useful when delays are mere waits, such as the 130 milliseconds wait introduced by the UserEvent `press()` event due to React Native runtime behavior or simulated 1000 wait in a API call mock. Fake timers allow for precise fast-forwarding through these wait periods.\n\nHere are the basics of using [Jest fake timers]():\n\n- Enable fake timers with: `jest.useFakeTimers()`\n- Disable fake timers with: `jest.useRealTimers()`\n- Advance fake timers forward with: `jest.advanceTimersByTime(interval)`\n- Run **all timers** to completion with: `jest.runAllTimers()`\n- Run **currently pending timers** to completion with: `jest.runOnlyPendingTimers()`\n\nBe cautious when running all timers to completion as it might create an infinite loop if these timers schedule follow-up timers. In such cases, it's safer to use `jest.runOnlyPendingTimers()` to avoid ending up in an infinite loop of scheduled tasks.\n\nYou can use both built-in Jest fake timers, as well as [Sinon.JS fake timers]().\n\nNote: you do not need to advance timers by hand when using User Event API, as it's automatically.\n","routePath":"/14.x/cookbook/basics/async-events","lang":"en","toc":[{"id":"summary","text":"Summary","depth":2,"charIndex":0},{"id":"example","text":"Example","depth":3,"charIndex":670},{"id":"async-utilities","text":"Async utilities","depth":2,"charIndex":1821},{"id":"findby-queries","text":"`findBy*` queries","depth":3,"charIndex":1912},{"id":"example-1","text":"Example","depth":4,"charIndex":3548},{"id":"waitfor-function","text":"`waitFor` function","depth":3,"charIndex":2992},{"id":"example-2","text":"Example","depth":4,"charIndex":4429},{"id":"waitforelementtoberemoved-function","text":"`waitForElementToBeRemoved` function","depth":3,"charIndex":3797},{"id":"example-3","text":"Example","depth":4,"charIndex":-1},{"id":"fake-timers","text":"Fake Timers","depth":2,"charIndex":4527}],"frontmatter":{},"version":"14.x"},{"title":"Custom `render` function","content":"### Summary\n\nRNTL exposes the `render` function as the primary entry point for tests. If you make complex, repeating setups for your tests, consider creating a custom render function. The idea is to encapsulate common setup steps and test wiring inside a render function suitable for your tests.\n\n### Example\n\n```tsx title=test-utils.ts\n// ...\n\ninterface RenderWithProvidersProps {\n  user?: User | null;\n  theme?: Theme;\n}\n\nexport async function renderWithProviders<T>(\n  ui: React.ReactElement<T>,\n  options?: RenderWithProvidersProps\n) {\n  return await render(\n    <UserProvider.Provider value={options?.user ?? null}>\n      <ThemeProvider.Provider value={options?.theme ?? 'light'}>{ui}</ThemeProvider.Provider>\n    </UserProvider.Provider>\n  );\n}\n```\n\n```tsx title=custom-render/index.test.tsx\n\n\n// ...\n\ntest('renders WelcomeScreen with user', async () => {\n  await renderWithProviders(<WelcomeScreen />, { user: { name: 'Jar-Jar' } });\n  expect(screen.getByText(/hello Jar-Jar/i)).toBeOnTheScreen();\n});\n\ntest('renders WelcomeScreen without user', async () => {\n  await renderWithProviders(<WelcomeScreen />, { user: null });\n  expect(screen.getByText(/hello stranger/i)).toBeOnTheScreen();\n});\n```\n\nExample [full source code]().\n\n### More info\n\n#### Additional params\n\nA custom render function might accept additional parameters to allow for setting up different start conditions for a test, e.g., the initial state for global state management.\n\n```tsx title=SomeScreen.test.tsx\ntest('renders SomeScreen for logged in user', async () => {\n  await renderScreen(<SomeScreen />, { state: loggedInState });\n  // ...\n});\n```\n\n#### Multiple functions\n\nDepending on the situation, you may declare more than one custom render function. For example, you have one function for testing application flows and a second for testing individual screens.\n\n```tsx title=test-utils.tsx\nfunction renderNavigator(ui, options);\nfunction renderScreen(ui, options);\n```\n\n#### Async setup\n\nSince `render` is async, your custom render function should be marked as `async` and use `await render()`. This pattern also makes it easy to add additional async setup if needed:\n\n```tsx title=SomeScreen.test.tsx\nasync function renderWithData<T>(ui: React.ReactElement<T>) {\n  const data = await fetchTestData();\n  return await render(<DataProvider value={data}>{ui}</DataProvider>);\n}\n\ntest('renders SomeScreen', async () => {\n  await renderWithData(<SomeScreen />);\n  // ...\n});\n```\n","routePath":"/14.x/cookbook/basics/custom-render","lang":"en","toc":[{"id":"summary","text":"Summary","depth":3,"charIndex":0},{"id":"example","text":"Example","depth":3,"charIndex":297},{"id":"more-info","text":"More info","depth":3,"charIndex":1236},{"id":"additional-params","text":"Additional params","depth":4,"charIndex":1251},{"id":"multiple-functions","text":"Multiple functions","depth":4,"charIndex":1627},{"id":"async-setup","text":"Async setup","depth":4,"charIndex":1953}],"frontmatter":{},"version":"14.x","description":"Summary RNTL exposes the render function as the primary entry point for tests. If you make complex, repeating setups for your tests, consider creating a custom render function. The idea is to encapsulate common setup steps and test wiring inside a render function suitable for your tests. Example Example full source code. More info Additional params A custom render function might accept additional parameters to allow for setting up different start conditions for a test, e.g., the initial state for global state management. Multiple functions Depending on the situation, you may declare more than one custom render function. For example, you have one function for testing application flows and a second for testing individual screens. Async setup Since render is async, your custom render function should be marked as async and use await render(). This pattern also makes it easy to add additional async setup if needed:"},{"title":"Introduction","content":"Welcome to the **React Native Testing Library (RNTL) Cookbook**!\nThis app is your go-to resource for learning how to effectively test React Native applications.\nIt provides a collection of **best practices**, **ready-made recipes**, and **tips & tricks** to\nsimplify and improve your testing workflow. Whether you’re a beginner just getting started or a\nseasoned developer looking to sharpen your\nskills, the Cookbook has something for everyone.\n\n## What's Inside the Cookbook?\n\nThe Cookbook is currently organized into **three main chapters**:\n\n- **Basic Recipes**: A great starting point, covering essential testing scenarios such as async\n  operations and custom render functions.\n- **Advanced Recipes**: More complex scenarios like network requests and in the future, navigation\n  testing and more.\n- **State Management Recipes**: Best practices for testing state management libraries\n\nEach recipe includes a clear explanation along with a corresponding code example to help you get\nhands-on with testing. Checkout\nthe [Cookbook App]() to see the\nrecipes in action.\n\n## What's Next?\n\nJoin the conversation\non [GitHub]() here to discuss\nideas, ask questions, or provide feedback.\n","routePath":"/14.x/cookbook/","lang":"en","toc":[{"id":"whats-inside-the-cookbook","text":"What's Inside the Cookbook?","depth":2,"charIndex":447},{"id":"whats-next","text":"What's Next?","depth":2,"charIndex":1071}],"frontmatter":{},"version":"14.x","description":"Welcome to the React Native Testing Library (RNTL) Cookbook!\nThis app is your go-to resource for learning how to effectively test React Native applications.\nIt provides a collection of best practices, ready-made recipes, and tips & tricks to\nsimplify and improve your testing workflow. Whether you’re a beginner just getting started or a\nseasoned developer looking to sharpen your\nskills, the Cookbook has something for everyone."},{"title":"Jotai","content":"## Introduction\n\nJotai is a global state management library for React that uses an atomic approach to optimize\nrenders and solve issues like extra re-renders and the need for memoization. It scales from simple\nstate management to complex enterprise applications, offering utilities and extensions to enhance\nthe developer experience.\n\n## Task List Example\n\nLet's assume we have a simple task list component that uses Jotai for state management. The\ncomponent has a list of tasks, a text input for typing new task name and a button to add a new task to the list.\n\n```tsx title=state-management/jotai/TaskList.tsx\n\n\n\n\n\n\nexport function TaskList() {\n  const [tasks, setTasks] = useAtom(tasksAtom);\n  const [newTaskTitle, setNewTaskTitle] = useAtom(newTaskTitleAtom);\n\n  const handleAddTask = () => {\n    setTasks((tasks) => [\n      ...tasks,\n      {\n        id: nanoid(),\n        title: newTaskTitle,\n      },\n    ]);\n    setNewTaskTitle('');\n  };\n\n  return (\n    <View>\n      {tasks.map((task) => (\n        <Text key={task.id} testID=\"task-item\">\n          {task.title}\n        </Text>\n      ))}\n\n      {!tasks.length ? <Text>No tasks, start by adding one...</Text> : null}\n\n      <TextInput\n        accessibilityLabel=\"New Task\"\n        placeholder=\"New Task...\"\n        value={newTaskTitle}\n        onChangeText={(text) => setNewTaskTitle(text)}\n      />\n\n      <Pressable accessibilityRole=\"button\" onPress={handleAddTask}>\n        <Text>Add Task</Text>\n      </Pressable>\n    </View>\n  );\n}\n```\n\n## Starting with a Simple Test\n\nWe can test our `TaskList` component using React Native Testing Library's (RNTL) regular `render`\nfunction. Although it is sufficient to test the empty state of the `TaskList` component, it is not\nenough to test the component with initial tasks present in the list.\n\n```tsx title=state-management/jotai/__tests__/TaskList.test.tsx\n\n\n\n\n\n\n\njest.useFakeTimers();\n\ntest('renders an empty task list', async () => {\n  await render(<TaskList />);\n  expect(screen.getByText(/no tasks, start by adding one/i)).toBeOnTheScreen();\n});\n```\n\n## Custom Render Function to populate Jotai Atoms with Initial Values\n\nTo test the `TaskList` component with initial tasks, we need to be able to populate the `tasksAtom` with\ninitial values. We can create a custom render function that uses Jotai's `useHydrateAtoms` hook to\nhydrate the atoms with initial values. This function will accept the initial atoms and their\ncorresponding values as an argument.\n\n```tsx title=state-management/jotai/__tests__/test-utils.tsx\n\n\n\n\n\n// Jotai types are not well exported, so we will make our life easier by using `any`.\nexport type AtomInitialValueTuple<T> = [PrimitiveAtom<T>, T];\n\nexport interface RenderWithAtomsOptions {\n  initialValues: AtomInitialValueTuple<any>[];\n}\n\n/**\n * Renders a React component with Jotai atoms for testing purposes.\n *\n * @param component - The React component to render.\n * @param options - The render options including the initial atom values.\n * @returns The render result from `@testing-library/react-native`.\n */\nexport async function renderWithAtoms<T>(\n  component: React.ReactElement,\n  options: RenderWithAtomsOptions\n) {\n  return await render(\n    <HydrateAtomsWrapper initialValues={options.initialValues}>{component}</HydrateAtomsWrapper>\n  );\n}\n\nexport type HydrateAtomsWrapperProps = React.PropsWithChildren<{\n  initialValues: AtomInitialValueTuple<unknown>[];\n}>;\n\n/**\n * A wrapper component that hydrates Jotai atoms with initial values.\n *\n * @param initialValues - The initial values for the Jotai atoms.\n * @param children - The child components to render.\n * @returns The rendered children.\n\n */\nfunction HydrateAtomsWrapper({ initialValues, children }: HydrateAtomsWrapperProps) {\n  useHydrateAtoms(initialValues);\n  return children;\n}\n```\n\n## Testing the `TaskList` Component with initial tasks\n\nWe can now use the `renderWithAtoms` function to render the `TaskList` component with initial tasks. The\n`initialValues` property will contain the `tasksAtom`, `newTaskTitleAtom` and their initial values. We can then test the component to ensure that the initial tasks are rendered correctly.\n\n:::info\nIn our test, we populated only one atom and its initial value, but you can add other Jotai atoms and their corresponding values to the initialValues array as needed.\n:::\n\n```tsx title=state-management/jotai/__tests__/TaskList.test.tsx\nconst INITIAL_TASKS: Task[] = [{ id: '1', title: 'Buy bread' }];\n\ntest('renders a to do list with 1 items initially, and adds a new item', async () => {\n  await renderWithAtoms(<TaskList />, {\n    initialValues: [\n      [tasksAtom, INITIAL_TASKS],\n      [newTaskTitleAtom, ''],\n    ],\n  });\n\n  expect(screen.getByText(/buy bread/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(1);\n\n  const user = userEvent.setup();\n  await user.type(screen.getByPlaceholderText(/new task/i), 'Buy almond milk');\n  await user.press(screen.getByRole('button', { name: /add task/i }));\n\n  expect(screen.getByText(/buy almond milk/i)).toBeOnTheScreen();\n  expect(screen.getAllByTestId('task-item')).toHaveLength(2);\n});\n```\n\n## Modifying atom outside of React components\n\nIn several cases, you might need to change an atom's state outside a React component. In our case,\nwe have a set of functions to get tasks and set tasks, which change the state of the task list atom.\n\n```tsx title=state-management/jotai/state.ts\n\n\n\nexport const tasksAtom = atom<Task[]>([]);\nexport const newTaskTitleAtom = atom('');\n\n// Available for use outside React components\nexport const store = createStore();\n\n// Selectors\nexport function getAllTasks(): Task[] {\n  return store.get(tasksAtom);\n}\n\n// Actions\nexport function addTask(task: Task) {\n  store.set(tasksAtom, [...getAllTasks(), task]);\n}\n```\n\n## Testing atom outside of React components\n\nYou can test the `getAllTasks` and `addTask` functions outside the React component's scope by setting\nthe initial to-do items in the store and then checking if the functions work as expected.\nNo special setup is required to test these functions, as `store.set` is available by default by\nJotai.\n\n```tsx title=state-management/jotai/__tests__/TaskList.test.tsx\n\n\n//...\n\ntest('modify store outside of React component', () => {\n  // Set the initial to do items in the store\n  store.set(tasksAtom, INITIAL_TASKS);\n  expect(getAllTasks()).toEqual(INITIAL_TASKS);\n\n  const NEW_TASK = { id: '2', title: 'Buy almond milk' };\n  addTask(NEW_TASK);\n  expect(getAllTasks()).toEqual([...INITIAL_TASKS, NEW_TASK]);\n});\n```\n\n## Conclusion\n\nTesting a component or a function that depends on Jotai atoms is straightforward with the help of\nthe `useHydrateAtoms` hook. We've seen how to create a custom render function `renderWithAtoms` that\nsets up atoms and their initial values for testing purposes. We've also seen how to test functions\nthat change the state of atoms outside React components. This approach allows us to test components\nin different states and scenarios, ensuring they behave as expected.\n","routePath":"/14.x/cookbook/state-management/jotai","lang":"en","toc":[{"id":"introduction","text":"Introduction","depth":2,"charIndex":0},{"id":"task-list-example","text":"Task List Example","depth":2,"charIndex":335},{"id":"starting-with-a-simple-test","text":"Starting with a Simple Test","depth":2,"charIndex":1498},{"id":"custom-render-function-to-populate-jotai-atoms-with-initial-values","text":"Custom Render Function to populate Jotai Atoms with Initial Values","depth":2,"charIndex":2059},{"id":"testing-the-tasklist-component-with-initial-tasks","text":"Testing the `TaskList` Component with initial tasks","depth":2,"charIndex":3790},{"id":"modifying-atom-outside-of-react-components","text":"Modifying atom outside of React components","depth":2,"charIndex":5121},{"id":"testing-atom-outside-of-react-components","text":"Testing atom outside of React components","depth":2,"charIndex":5779},{"id":"conclusion","text":"Conclusion","depth":2,"charIndex":6534}],"frontmatter":{},"version":"14.x"},{"title":"Testing environment","content":":::info\n\nThis document is intended for a more advanced audience who want to understand the internals of our testing environment better, e.g., to contribute to the codebase. You should be able to write integration or component tests without reading this.\n\n:::\n\nReact Native Testing Library lets you write integration and component tests for your React Native app or library. While the JSX code in tests closely resembles your React Native app, the underlying environment differs. This document describes the key elements of our testing environment and highlights things to be aware of when writing advanced tests or diagnosing issues.\n\n## React renderers\n\nReact allows you to write declarative code using JSX, write function or class components, or use hooks like `useState`. You need to use a renderer to output the results of your components. Every React app uses some renderer:\n\n- React Native is a renderer for mobile apps,\n- React DOM is a renderer for web apps,\n- There are other more [specialized renderers]() that can e.g., render to console or HTML canvas.\n\nWhen you run your tests in the React Native Testing Library, somewhat contrary to what the name suggests, they are actually **not** using React Native renderer. This is because this renderer needs to be run on an iOS or Android operating system, so it would need to run on a device or simulator.\n\n## Test Renderer\n\nInstead, RNTL uses [Test Renderer](), a modern, actively maintained renderer that renders to pure JavaScript objects without access to mobile OS and runs in a Node.js environment using Jest (or any other JavaScript test runner). Test Renderer replaces the deprecated `react-test-renderer` package and has better compatibility with React 19 and improved type safety.\n\nUsing Test Renderer has trade-offs:\n\nBenefits:\n\n- Tests run on most CIs (Linux, etc) without a mobile device or emulator\n- Faster test execution\n- Light runtime environment\n\nLimitations:\n\n- Tests don't execute native code\n- Tests are unaware of view state managed by native components, e.g., focus, unmanaged text boxes, etc.\n- Assertions don't operate on native view hierarchy\n- Runtime behaviors are simulated, sometimes imperfectly\n\nIt's worth noting that the React Testing Library (web one) works a bit differently. While RTL also runs in Jest, it has access to a simulated browser DOM environment from the `jsdom` package, which allows it to use a regular React DOM renderer. Unfortunately, there is no similar React Native runtime environment package. This is probably because while the browser environment is well-defined and highly standardized, the React Native environment constantly evolves in sync with the evolution of underlying OS-es. Maintaining such an environment would require duplicating countless React Native behaviors and keeping them in sync as React Native develops.\n\n## Element tree\n\nCalling the `render()` function creates an element tree. This is done internally by invoking the `createRoot()` function from Test Renderer. The output tree represents your React Native component tree, containing only host elements. Each node of that tree corresponds to a host component that would have a counterpart in the native view hierarchy.\n\nThese tree elements are represented by `HostElement` type from Test Renderer:\n\n```tsx\ninterface HostElement {\n  type: ElementType;\n  props: { [propName: string]: any };\n  parent: HostElement | null;\n  children: Array<HostElement | string>;\n\n  // Other props and methods\n}\n```\n\nFor more details, see the [Test Renderer documentation]().\n\n## Host and composite components\n\nTo understand RNTL's element tree, it's important to know the difference between host and composite components in React Native:\n\n- [Host components]() have direct counterparts in the native view tree. Typical examples are `<View>`, `<Text>`, `<TextInput>`, and `<Image>` from React Native. You can think of these as an analog of `<div>`, `<span>` etc on the Web. You can also create custom host views as native modules or import them from 3rd party libraries, like React Navigation or React Native Gesture Handler.\n- [Composite components]() are React code organization units that exist only on the JavaScript side of your app. Typical examples are components you create (function and class components), components imported from React Native (`View`, `Text`, etc.), or 3rd party packages.\n\nThat might initially sound confusing since we put React Native's `View` in both categories. There are two `View` components: composite and host. The relation between them is as follows:\n\n- Composite `View` is the type imported from the `react-native` package. It is a JavaScript component that renders the host `View` as its only child.\n- Host `View`, which you do not render directly. React Native takes the props you pass to the composite `View`, does some processing on them and passes them to the host `View`.\n\nIn a full React tree, this would look like:\n\n```jsx\n* <View> (composite)\n  * <View> (host)\n    * children prop passed in JSX\n```\n\nA similar relation exists between other composite and host pairs: e.g. `Text`, `TextInput`, and `Image` components.\n\nNot all React Native components are organized this way, e.g., when you use `Pressable` (or `TouchableOpacity`), there is no host `Pressable`, but composite `Pressable` is rendering a host `View` with specific props being set:\n\n```jsx\n* <Pressable> (composite)\n  * <View accessible={true} {...}> (host)\n    * children prop passed in JSX\n```\n\n### Host-only element tree\n\nIn RNTL v14, [Test Renderer]() only exposes host elements in the element tree. Composite components aren't visible in the tree—you only see their host element output. This aligns with Testing Library's philosophy: tests should focus on what users can see and interact with (host elements), not implementation details (composite components).\n\nFor a `HostElement`, the `type` prop is always a string value representing the host component name, e.g., `\"View\"`, `\"Text\"`, `\"TextInput\"`.\n\n## Tree nodes\n\nRNTL v14 queries and the element tree only expose host elements. Tests assert on what users can see and interact with. Host elements represent the actual UI controls users interact with, while composite components exist purely in the JavaScript domain.\n\n### Understanding props\n\nWhen asserting props on host elements, you're verifying what actually reaches the native view. This is important because composite components may process, transform, or even forget to pass props to their host children.\n\n```jsx\nfunction ForgotToPassPropsButton({ title, onPress, style }) {\n  return (\n    <Pressable>\n      <Text>{title}</Text>\n    </Pressable>\n  );\n}\n```\n\nIn the above example, the component accepts `onPress` and `style` props but doesn't pass them to host views, so they won't affect the user interface. By testing host elements, RNTL helps you catch these issues: if a prop doesn't reach a host element, users won't see or interact with it.\n\n## Tree navigation\n\n:::caution\nYou should avoid navigating over the element tree, as this makes your testing code fragile and may result in false positives. This section is more relevant for people who want to contribute to our codebase.\n:::\n\nYou can navigate the tree of host elements using `parent` or `children` props of a `HostElement`. Be careful when doing this, as the tree structure for third-party components can change independently from your code and cause unexpected test failures.\n\n## Queries\n\nAll Testing Library queries return host components to encourage the best practices described above. Since v14, RNTL uses [Test Renderer](), which only renders host elements, making it impossible to query composite components directly.\n","routePath":"/14.x/docs/advanced/testing-env","lang":"en","toc":[{"id":"react-renderers","text":"React renderers","depth":2,"charIndex":635},{"id":"test-renderer","text":"Test Renderer","depth":2,"charIndex":1363},{"id":"element-tree","text":"Element tree","depth":2,"charIndex":2841},{"id":"host-and-composite-components","text":"Host and composite components","depth":2,"charIndex":3544},{"id":"host-only-element-tree","text":"Host-only element tree","depth":3,"charIndex":5471},{"id":"tree-nodes","text":"Tree nodes","depth":2,"charIndex":5983},{"id":"understanding-props","text":"Understanding props","depth":3,"charIndex":6252},{"id":"tree-navigation","text":"Tree navigation","depth":2,"charIndex":6938},{"id":"queries","text":"Queries","depth":2,"charIndex":7433}],"frontmatter":{},"version":"14.x","description":":::info This document is intended for a more advanced audience who want to understand the internals of our testing environment better, e.g., to contribute to the codebase. You should be able to write integration or component tests without reading this. ::: React Native Testing Library lets you write integration and component tests for your React Native app or library. While the JSX code in tests closely resembles your React Native app, the underlying environment differs. This document describes the key elements of our testing environment and highlights things to be aware of when writing advanced tests or diagnosing issues."},{"title":"Third-Party Library Integration","content":"The React Native Testing Library is designed to simulate the core behaviors of React Native. However, it does not replicate the internal logic of third-party libraries. This guide explains how to integrate your library with RNTL.\n\n## Handling Events in Third-Party Libraries\n\nRNTL provides two subsystems to simulate events:\n\n- **Fire Event**: A lightweight simulation system that can trigger event handlers defined on both host and composite components.\n- **User Event**: A more realistic interaction simulation system that can trigger event handlers defined only on host components.\n\nIn many third-party libraries, event handling involves native code, which means RNTL cannot fully simulate the event flow, as it runs only JavaScript code. To address this limitation, you can use `testOnly_on*` props on host components to expose custom events to RNTL’s event subsystems. Both subsystems will first attempt to locate the standard `on*` event handlers; if these are not available, they fall back to the `testOnly_on*` handlers.\n\n### Example: React Native Gesture Handler\n\nReact Native Gesture Handler (RNGH) provides a composite [Pressable]() component with `onPress*` props. These event handlers are not exposed on the rendered host views; instead, they are invoked via RNGH’s internal event flow, which involves native modules. As a result, they are not accessible to RNTL’s event subsystems.\n\nTo enable RNTL to interact with RNGH’s `Pressable` component, the library exposes `testOnly_onPress*` props on the `NativeButton` host component rendered by `Pressable`. This adjustment allows RNTL to simulate interactions during testing.\n\n```tsx title=\"Simplified RNGH Pressable component\"\nfunction Pressable({ onPress, onPressIn, onPressOut, onLongPress, ... }) {\n\n  // Component logic...\n\n  const isTestEnv = process.env.NODE_ENV === 'test';\n\n  return (\n    <GestureDetector gesture={gesture}>\n      <NativeButton\n        /* Other props... */\n        testOnly_onPress={isTestEnv ? onPress : undefined}\n        testOnly_onPressIn={isTestEnv ? onPressIn : undefined}\n        testOnly_onPressOut={isTestEnv ? onPressOut : undefined}\n        testOnly_onLongPress={isTestEnv ? onLongPress : undefined}\n      />\n    </GestureDetector>\n  );\n}\n```\n","routePath":"/14.x/docs/advanced/third-party-integration","lang":"en","toc":[{"id":"handling-events-in-third-party-libraries","text":"Handling Events in Third-Party Libraries","depth":2,"charIndex":231},{"id":"example-react-native-gesture-handler","text":"Example: React Native Gesture Handler","depth":3,"charIndex":1030}],"frontmatter":{},"version":"14.x","description":"The React Native Testing Library is designed to simulate the core behaviors of React Native. However, it does not replicate the internal logic of third-party libraries. This guide explains how to integrate your library with RNTL."},{"title":"Understanding `act` function","content":"When writing RNTL tests, cryptic [`act()`]() function errors logged to console often confuse developers. This article explains the purpose and behavior of `act()` so you can write tests with more confidence.\n\n## `act` warning\n\nLet's start with a typical `act()` warning logged to console:\n\n```\nAn update to Root inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser.\nLearn more at https://react.dev/link/wrap-tests-with-act\n```\n\n## Understanding `act`\n\n### Responsibility\n\nThis function is intended only for using in automated tests and works only in development mode. Attempting to use it in production build will throw an error.\n\nThe responsibility for `act` function is to make React renders and updates work in tests in a similar way they work in real application by grouping and executing related units of interaction (e.g. renders, effects, etc) together.\n\nLet's demonstrate this with a small experiment. First, define a function component that uses `useEffect`:\n\n```jsx\nfunction TestComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n```\n\nIn the following tests we will directly use [Test Renderer]() instead of RNTL `render` function to render our component for tests. In order to expose familiar queries like `getByText` we will use `within` function from RNTL.\n\n```jsx\n\n\n\ntest('render without act', () => {\n  const renderer = createRoot();\n  renderer.render(<TestComponent />);\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 0')).toBeTruthy();\n});\n```\n\nWhen testing without `act` wrapping the render call, the assertion runs just after rendering but before `useEffect` effects are applied. This isn't what we expected.\n\n```jsx\n\n\n\ntest('render with act', async () => {\n  const renderer = createRoot();\n  await act(() => {\n    renderer.render(<TestComponent />);\n  });\n\n  // Bind RNTL queries for root element.\n  const view = within(renderer.container);\n  expect(view.getByText('Count 1')).toBeTruthy();\n});\n```\n\n**Note**: In v14, `act` is now async by default and always returns a Promise. You should always use `await act(...)`.\n\nWhen wrapping rendering call with `act` we see that the changes caused by `useEffect` hook have been applied as we would expect.\n\n### When to use act\n\nThe name `act` comes from [Arrange-Act-Assert]() unit testing pattern. Which means it's related to part of the test when we execute some actions on the component tree.\n\nSo far we learned that `act` function allows tests to wait for all pending React interactions to be applied before we make our assertions. When using `act` we get guarantee that any state updates will be executed as well as any enqueued effects will be executed.\n\nTherefore, we should use `act` whenever there is some action that causes element tree to render, particularly:\n\n- initial render call - `renderer.render` call\n- re-rendering of component - `renderer.render` call with updated element\n- triggering any event handlers that cause component tree render\n\nThankfully, for these basic cases RNTL has got you covered as our `render`, `rerender` and `fireEvent` methods already wrap their calls in `act` so that you do not have to do it explicitly. In v14, these functions are all async and should be awaited.\n\nNote that `act` calls can be safely nested and internally form a stack of calls.\n\n### Implementation\n\nThe `act` implementation is defined in the [ReactAct.js source file]() inside React repository. RNTL v14 requires React 19+, which provides the `act` function directly via `React.act`.\n\nRNTL exports `act` for convenience as defined in the [act.ts source file](). In v14, `act` is async by default and always returns a Promise. This works with async React features like `Suspense` boundaries and the `use()` hook. The underlying implementation wraps React's `act` function to ensure consistent async behavior.\n\n**Important**: You should always use `act` exported from `@testing-library/react-native` rather than the one from `react`. The RNTL version automatically ensures async behavior, whereas using `React.act` directly could still trigger synchronous act behavior if used improperly, leading to subtle test issues.\n\n## Asynchronous code\n\nIn v14, `act` is always async and returns a Promise. While the callback you pass to `act` can be synchronous (dealing with things like synchronous effects or mocks using already resolved promises), the `act` function itself should always be awaited. However, not all component code is synchronous. Frequently our components or mocks contain some asynchronous behaviours like `setTimeout` calls or network calls.\n\n### Handling asynchronous operations\n\nWhen the callback passed to `act` contains asynchronous operations, the Promise returned by `act` will resolve only after those operations complete.\n\nHere's a simple example with a component using `setTimeout` to simulate asynchronous behavior:\n\n```jsx\nfunction TestAsyncComponent() {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => {\n    setTimeout(() => {\n      setCount((c) => c + 1);\n    }, 50);\n  }, []);\n\n  return <Text>Count {count}</Text>;\n}\n```\n\n```jsx\n\n\ntest('render async natively', async () => {\n  await render(<TestAsyncComponent />);\n  expect(screen.getByText('Count 0')).toBeOnTheScreen();\n});\n```\n\nIf we test our component in a native way without handling its asynchronous behaviour we will end up with an act warning. This is because the `setTimeout` callback will trigger a state update after the test has finished.\n\n### Solution with fake timers\n\nUse Jest's fake timers:\n\n```jsx\ntest('render with fake timers', async () => {\n  jest.useFakeTimers();\n  await render(<TestAsyncComponent />);\n\n  await act(() => {\n    jest.runAllTimers();\n  });\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\n**Note**: In v14, both `render` and `act` are async by default, so you should await them.\n\nThat way we can wrap `jest.runAllTimers()` call which triggers the `setTimeout` updates inside an `act` call, hence resolving the act warning.\n\n### Solution with real timers\n\nWith real timers, things get more complex. Start with a simple solution: wrap an async `act()` call for the expected duration of component updates:\n\n```jsx\ntest('render with real timers - sleep', async () => {\n  await render(<TestAsyncComponent />);\n  await act(() => {\n    await sleep(100); // Wait a bit longer than setTimeout in `TestAsyncComponent`\n  });\n\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis works correctly as we use an explicit async `act()` call that resolves the console error. However, it relies on our knowledge of exact implementation details which is a bad practice.\n\nA better solution uses `waitFor` to wait for the desired state:\n\n```jsx\ntest('render with real timers - waitFor', async () => {\n  await render(<TestAsyncComponent />);\n\n  await waitFor(() => screen.getByText('Count 1'));\n  expect(screen.getByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis also works correctly, because `waitFor` call executes async `act()` call internally.\n\nThe above code can be simplified using `findBy` query:\n\n```jsx\ntest('render with real timers - findBy', async () => {\n  await render(<TestAsyncComponent />);\n\n  expect(await screen.findByText('Count 1')).toBeOnTheScreen();\n});\n```\n\nThis also works since `findByText` internally calls `waitFor` which uses async `act()`.\n\nNote that all of the above examples are async tests using & awaiting async `act()` function call.\n\n## References\n\n- [React `act` implementation source]()\n- [React testing documentation]()\n","routePath":"/14.x/docs/advanced/understanding-act","lang":"en","toc":[{"id":"act-warning","text":"`act` warning","depth":2,"charIndex":209},{"id":"understanding-act","text":"Understanding `act`","depth":2,"charIndex":666},{"id":"responsibility","text":"Responsibility","depth":3,"charIndex":690},{"id":"when-to-use-act","text":"When to use act","depth":3,"charIndex":2590},{"id":"implementation","text":"Implementation","depth":3,"charIndex":3677},{"id":"asynchronous-code","text":"Asynchronous code","depth":2,"charIndex":4517},{"id":"handling-asynchronous-operations","text":"Handling asynchronous operations","depth":3,"charIndex":4952},{"id":"solution-with-fake-timers","text":"Solution with fake timers","depth":3,"charIndex":5848},{"id":"solution-with-real-timers","text":"Solution with real timers","depth":3,"charIndex":6374},{"id":"references","text":"References","depth":2,"charIndex":7818}],"frontmatter":{},"version":"14.x","description":"When writing RNTL tests, cryptic act() function errors logged to console often confuse developers. This article explains the purpose and behavior of act() so you can write tests with more confidence."},{"title":"API Overview","content":"React Native Testing Library consists of following APIs:\n\n- [`render` function]() - render your UI components for testing purposes\n- [`screen` object]() - access rendered UI:\n  - [Queries]() - find relevant components by various predicates: role, text, test ids, etc\n  - Lifecycle methods: [`rerender`](), [`unmount`]()\n  - Helpers: [`debug`](), [`toJSON`](), [`root`]()\n- [Jest matchers]() - validate assumptions about your UI\n- [User Event]() - simulate common user interactions like [`press`]() or [`type`]() in a realistic way\n- [Fire Event]() - simulate any component event in a simplified way purposes\n- Misc APIs:\n  - [`renderHook` function]() - render hooks for testing\n  - [Async utils](): `findBy*` queries, `wait`, `waitForElementToBeRemoved`\n  - [Configuration](): `configure`, `resetToDefaults`\n  - [Accessibility](): `isHiddenFromAccessibility`\n  - [Other](): `within`, `act`, `cleanup`\n","routePath":"/14.x/docs/api","lang":"en","toc":[],"frontmatter":{"uri":"/api"},"version":"14.x","description":"React Native Testing Library consists of following APIs: render function - render your UI components for testing purposesscreen object - access rendered UI:Queries - find relevant components by various predicates: role, text, test ids, etcLifecycle methods: rerender, unmountHelpers: debug, toJSON, rootJest matchers - validate assumptions about your UIUser Event - simulate common user interactions like press or type in a realistic wayFire Event - simulate any component event in a simplified way purposesMisc APIs:renderHook function - render hooks for testingAsync utils: findBy* queries, wait, waitForElementToBeRemovedConfiguration: configure, resetToDefaultsAccessibility: isHiddenFromAccessibilityOther: within, act, cleanup"},{"title":"Fire Event API","content":"## `fireEvent` {#fire-event}\n\n:::note\nFor common events like `press` or `type`, use the [User Event API](). It simulates events more realistically by emitting a sequence of events with proper event objects that mimic React Native runtime behavior.\n\nUse Fire Event for cases not supported by User Event and for triggering event handlers on composite components.\n:::\n\n```ts\nfunction fireEvent(element: HostElement, eventName: string, ...data: unknown[]): Promise<unknown>;\n```\n\nThe `fireEvent` API triggers event handlers on both host and composite components. It traverses the component tree bottom-up from the passed element to find an enabled event handler named `onXxx` where `xxx` is the event name.\n\nUnlike User Event, this API does not automatically pass event object to event handler, this is responsibility of the user to construct such object.\n\nThis function uses async `act` internally to execute all pending React updates during event handling.\n\n```jsx\n\n\ntest('fire changeText event', async () => {\n  const onEventMock = jest.fn();\n  await render(\n    // MyComponent renders TextInput which has a placeholder 'Enter details'\n    // and with `onChangeText` bound to handleChangeText\n    <MyComponent handleChangeText={onEventMock} />\n  );\n\n  await fireEvent(screen.getByPlaceholderText('change'), 'onChangeText', 'ab');\n  expect(onEventMock).toHaveBeenCalledWith('ab');\n});\n```\n\n:::note\n`fireEvent` performs checks that should prevent events firing on disabled elements.\n:::\n\nAn example using `fireEvent` with native events that aren't already aliased by the `fireEvent` api.\n\n```jsx\n\n\n\nconst onBlurMock = jest.fn();\n\nawait render(\n  <View>\n    <TextInput placeholder=\"my placeholder\" onBlur={onBlurMock} />\n  </View>\n);\n\n// you can omit the `on` prefix\nawait fireEvent(screen.getByPlaceholderText('my placeholder'), 'blur');\n```\n\nFireEvent exposes convenience methods for common events like: `press`, `changeText`, `scroll`.\n\n### `fireEvent.press` {#press}\n\n:::note\nUse the User Event [`press()`]() helper instead. It simulates press interactions more realistically, including pressable support.\n:::\n\n```tsx\nfireEvent.press: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n```\n\nInvokes `press` event handler on the element or parent element in the tree.\n\n```jsx\n\n\n\nconst onPressMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    pageX: 20,\n    pageY: 30,\n  },\n};\n\nawait render(\n  <View>\n    <TouchableOpacity onPress={onPressMock}>\n      <Text>Press me</Text>\n    </TouchableOpacity>\n  </View>\n);\n\nawait fireEvent.press(screen.getByText('Press me'), eventData);\nexpect(onPressMock).toHaveBeenCalledWith(eventData);\n```\n\n### `fireEvent.changeText` {#change-text}\n\n:::note\nUse the User Event [`type()`]() helper instead. It simulates text change interactions more realistically, including key-by-key typing, element focus, and other editing events.\n:::\n\n```tsx\nfireEvent.changeText: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n```\n\nInvokes `changeText` event handler on the element or parent element in the tree.\n\n```jsx\n\n\n\nconst onChangeTextMock = jest.fn();\nconst CHANGE_TEXT = 'content';\n\nawait render(\n  <View>\n    <TextInput placeholder=\"Enter data\" onChangeText={onChangeTextMock} />\n  </View>\n);\n\nawait fireEvent.changeText(screen.getByPlaceholderText('Enter data'), CHANGE_TEXT);\n```\n\n### `fireEvent.scroll` {#scroll}\n\n:::note\nPrefer [`user.scrollTo`]() over `fireEvent.scroll` for `ScrollView`, `FlatList`, and `SectionList` components. User Event simulates events more realistically based on React Native runtime behavior.\n:::\n\n```tsx\nfireEvent.scroll: (\n  element: HostElement,\n  ...data: Array<any>,\n) => Promise<unknown>\n```\n\nInvokes `scroll` event handler on the element or parent element in the tree.\n\n#### On a `ScrollView`\n\n```jsx\n\n\n\nconst onScrollMock = jest.fn();\nconst eventData = {\n  nativeEvent: {\n    contentOffset: {\n      y: 200,\n    },\n  },\n};\n\nawait render(\n  <ScrollView testID=\"scroll-view\" onScroll={onScrollMock}>\n    <Text>Content</Text>\n  </ScrollView>\n);\n\nawait fireEvent.scroll(screen.getByTestId('scroll-view'), eventData);\n```\n","routePath":"/14.x/docs/api/events/fire-event","lang":"en","toc":[{"id":"fire-event","text":"`fireEvent`","depth":2,"charIndex":0},{"id":"press","text":"`fireEvent.press`","depth":3,"charIndex":1936},{"id":"change-text","text":"`fireEvent.changeText`","depth":3,"charIndex":2661},{"id":"scroll","text":"`fireEvent.scroll`","depth":3,"charIndex":3359},{"id":"on-a-scrollview","text":"On a `ScrollView`","depth":4,"charIndex":3783}],"frontmatter":{},"version":"14.x"},{"title":"User Event interactions","content":"## Comparison with Fire Event API\n\nFire Event is our original event simulation API. It can invoke **any event handler** declared on **either host or composite elements**. Suppose the element does not have `onEventName` event handler for the passed `eventName` event, or the element is disabled. In that case, Fire Event will traverse up the component tree, looking for an event handler on both host and composite elements along the way. By default, it will **not pass any event data**, but the user might provide it in the last argument.\n\nIn contrast, User Event provides realistic event simulation for user interactions like `press` or `type`. Each interaction will trigger a **sequence of events** corresponding to React Native runtime behavior. These events will be invoked **only on host elements**, and **will automatically receive event data** corresponding to each event.\n\nIf User Event supports a given interaction, prefer it over the Fire Event counterpart. It makes tests more realistic and reliable. When User Event doesn't support the event or you need to invoke event handlers on composite elements, use Fire Event.\n\n## `setup()`\n\n```ts\nuserEvent.setup(options?: {\n  delay?: number;\n  advanceTimers?: (delay: number) => Promise<void> | void;\n})\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\n```\n\nCreates a User Event object instance, which can be used to trigger events.\n\n### Options {#setup-options}\n\n- `delay` controls the default delay between subsequent events, e.g., keystrokes.\n- `advanceTimers` is a time advancement utility function that should be used for fake timers. The default setup handles both real timers and Jest fake timers.\n\n## `press()`\n\n```ts\npress(\n  element: HostElement,\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.press(element);\n```\n\nSimulates a press on any pressable element, e.g. `Pressable`, `TouchableOpacity`, `Text`, `TextInput`, etc. Unlike `fireEvent.press()`, which only calls the `onPress` prop, this function simulates the entire press interaction by reproducing the event sequence emitted by React Native runtime. It triggers additional events like `pressIn` and `pressOut`.\n\nThis event will take a minimum of 130 ms to run due to the internal React Native logic. Consider using fake timers to speed up test execution for tests involving `press` and `longPress` interactions.\n\n## `longPress()`\n\n```ts\nlongPress(\n  element: HostElement,\n  options?: { duration?: number }\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.longPress(element);\n```\n\nSimulates a long press user interaction. In React Native, the `longPress` event is emitted when the press duration exceeds the long press threshold (by default, 500 ms). In other aspects, this action behaves similarly to regular `press` action, e.g., by emitting `pressIn` and `pressOut` events. The press duration is customizable through the options, which is useful when using the `delayLongPress` prop.\n\nThis event will, by default, take 500 ms to run. Due to internal React Native logic, it will take at least 130 ms regardless of the duration option passed. Consider using fake timers to speed up test execution for tests involving `press` and `longPress` interactions.\n\n### Options {#longpress-options}\n\n- `duration` - duration of the press in milliseconds. The default value is 500 ms.\n\n## `type()`\n\n```ts\ntype(\n  element: HostElement,\n  text: string,\n  options?: {\n    skipPress?: boolean;\n    skipBlur?: boolean;\n    submitEditing?: boolean;\n  }\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.type(textInput, 'Hello world!');\n```\n\nSimulates focusing on a `TextInput` element, typing `text` one character at a time, and leaving the element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n:::note\nThis function will add text to the text already present in the text input (as specified by `value` or `defaultValue` props). To replace existing text, use [`clear()`]() helper first.\n:::\n\n### Options {#type-options}\n\n- `skipPress` - if true, `pressIn` and `pressOut` events will not be triggered.\n- `skipBlur` - if true, `endEditing` and `blur` events will not be triggered when typing is complete.\n- `submitEditing` - if true, `submitEditing` event will be triggered after typing the text.\n\n### Sequence of events {#type-sequence}\n\nThe sequence of events depends on the `multiline` prop and the passed options.\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `pressIn` (optional)\n- `focus`\n- `pressOut` (optional)\n\nThe `pressIn` and `pressOut` events are sent by default but can be skipped by passing the `skipPress: true` option.\n\n**Typing (for each character)**:\n\n- `keyPress`\n- `change`\n- `changeText`\n- `selectionChange`\n- `contentSizeChange` (only multiline)\n\n**Leaving the element**:\n\n- `submitEditing` (optional)\n- `endEditing`\n- `blur`\n\nThe `submitEditing` event is skipped by default. It can sent by setting the `submitEditing: true` option.\nThe `endEditing` and `blur` events can be skipped by passing the `skipBlur: true` option.\n\n## `clear()`\n\n```ts\nclear(\n  element: HostElement,\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.clear(textInput);\n```\n\nSimulates clearing the content of a `TextInput` element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n### Sequence of events {#clear-sequence}\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `focus`\n\n**Selecting all content**:\n\n- `selectionChange`\n\n**Pressing backspace**:\n\n- `keyPress`\n- `change`\n- `changeText`\n- `selectionChange`\n\n**Leaving the element**:\n\n- `endEditing`\n- `blur`\n\n## `paste()`\n\n```ts\npaste(\n  element: HostElement,\n  text: string,\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.paste(textInput, 'Text to paste');\n```\n\nSimulates pasting text into a `TextInput` element.\n\nThis function supports only host `TextInput` elements. Passing other element types will result in throwing an error.\n\n### Sequence of events {#paste-sequence}\n\nEvents will not be emitted if the `editable` prop is set to `false`.\n\n**Entering the element**:\n\n- `focus`\n\n**Selecting all content**:\n\n- `selectionChange`\n\n**Pasting the text**:\n\n- `change`\n- `changeText`\n- `selectionChange`\n- `contentSizeChange` (only multiline)\n\n**Leaving the element**:\n\n- `endEditing`\n- `blur`\n\n## `scrollTo()` {#scroll-to}\n\n```ts\nscrollTo(\n  element: HostElement,\n  options: {\n    y: number;\n    momentumY?: number;\n    contentSize?: { width: number; height: number };\n    layoutMeasurement?: { width: number; height: number };\n  } | {\n    x: number;\n    momentumX?: number;\n    contentSize?: { width: number; height: number };\n    layoutMeasurement?: { width: number; height: number };\n  }\n): Promise<void>\n```\n\nExample\n\n```ts\nconst user = userEvent.setup();\nawait user.scrollTo(scrollView, { y: 100, momentumY: 200 });\n```\n\nSimulates scrolling a host `ScrollView` element.\n\nThis function supports only host `ScrollView` elements, passing other element types will result in an error. Note that `FlatList` is accepted as it renders to a host `ScrollView` element.\n\nScroll interaction should match the `ScrollView` element direction:\n\n- for a vertical scroll view (default or `horizontal={false}`), you should pass only the `y` option (and optionally also `momentumY`).\n- for a horizontal scroll view (`horizontal={true}`), you should pass only the `x` option (and optionally `momentumX`).\n\nEach scroll interaction consists of a mandatory drag scroll part, which simulates the user dragging the scroll view with his finger (the `y` or `x` option). This may optionally be followed by a momentum scroll movement, which simulates the inertial movement of scroll view content after the user lifts his finger (`momentumY` or `momentumX` options).\n\n### Options {#scroll-to-options}\n\n- `y` - target vertical drag scroll offset\n- `x` - target horizontal drag scroll offset\n- `momentumY` - target vertical momentum scroll offset\n- `momentumX` - target horizontal momentum scroll offset\n- `contentSize` - passed to `ScrollView` events and enabling `FlatList` updates\n- `layoutMeasurement` - passed to `ScrollView` events and enabling `FlatList` updates\n\nUser Event will generate several intermediate scroll steps to simulate user scroll interaction. You should not rely on exact number or values of these scrolls steps as they might be change in the future version.\n\nThis function will remember where the last scroll ended, so subsequent scroll interaction will starts from that position. The initial scroll position will be assumed to be `{ y: 0, x: 0 }`.\n\nTo simulate a `FlatList` (and other controls based on `VirtualizedList`) scrolling, you should pass the `contentSize` and `layoutMeasurement` options, which enable the underlying logic to update the currently visible window.\n\n### Sequence of events {#scroll-sequence}\n\nThe sequence of events depends on whether the scroll includes an optional momentum scroll component.\n\n**Drag scroll**:\n\n- `contentSizeChange`\n- `scrollBeginDrag`\n- `scroll` (multiple events)\n- `scrollEndDrag`\n\n**Momentum scroll (optional)**:\n\n- `momentumScrollBegin`\n- `scroll` (multiple events)\n- `momentumScrollEnd`\n","routePath":"/14.x/docs/api/events/user-event","lang":"en","toc":[{"id":"comparison-with-fire-event-api","text":"Comparison with Fire Event API","depth":2,"charIndex":0},{"id":"setup","text":"`setup()`","depth":2,"charIndex":1130},{"id":"setup-options","text":"Options","depth":3,"charIndex":1391},{"id":"press","text":"`press()`","depth":2,"charIndex":1663},{"id":"longpress","text":"`longPress()`","depth":2,"charIndex":2371},{"id":"longpress-options","text":"Options","depth":3,"charIndex":1391},{"id":"type","text":"`type()`","depth":2,"charIndex":3363},{"id":"type-options","text":"Options","depth":3,"charIndex":1391},{"id":"type-sequence","text":"Sequence of events","depth":3,"charIndex":4370},{"id":"clear","text":"`clear()`","depth":2,"charIndex":5173},{"id":"clear-sequence","text":"Sequence of events","depth":3,"charIndex":4370},{"id":"paste","text":"`paste()`","depth":2,"charIndex":5838},{"id":"paste-sequence","text":"Sequence of events","depth":3,"charIndex":4370},{"id":"scroll-to","text":"`scrollTo()`","depth":2,"charIndex":6554},{"id":"scroll-to-options","text":"Options","depth":3,"charIndex":1391},{"id":"scroll-sequence","text":"Sequence of events","depth":3,"charIndex":4370}],"frontmatter":{},"version":"14.x"},{"title":"Jest matchers","content":"This guide covers the built-in Jest matchers. These matchers make your tests easier to read and work better with accessibility features.\n\n## Setup\n\nNo setup needed. Matchers are available when you import from `@testing-library/react-native`.\n\n## Checking element existence\n\n### `toBeOnTheScreen()`\n\n```ts\nexpect(element).toBeOnTheScreen();\n```\n\nChecks if an element is attached to the element tree. If you have a reference to an element and it gets unmounted during the test, this assertion will fail.\n\n## Element Content\n\n### `toHaveTextContent()`\n\n```ts\nexpect(element).toHaveTextContent(\n  text: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nChecks if an element has the specified text content. Accepts `string` or `RegExp`, with optional [text match options]() like `exact` and `normalizer`.\n\n### `toContainElement()`\n\n```ts\nexpect(container).toContainElement(\n  element: HostElement | null,\n)\n```\n\nChecks if a container element contains another element.\n\n### `toBeEmptyElement()`\n\n```ts\nexpect(element).toBeEmptyElement();\n```\n\nChecks if an element has no child elements or text content.\n\n## Checking element state\n\n### `toHaveDisplayValue()`\n\n```ts\nexpect(element).toHaveDisplayValue(\n  value: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nChecks if a `TextInput` has the specified display value. Accepts `string` or `RegExp`, with optional [text match options]() like `exact` and `normalizer`.\n\n### `toHaveAccessibilityValue()`\n\n```ts\nexpect(element).toHaveAccessibilityValue(\n  value: {\n    min?: number;\n    max?: number;\n    now?: number;\n    text?: string | RegExp;\n  },\n)\n```\n\nChecks if an element has the specified accessible value.\n\nThe matcher reads accessibility values from `aria-valuemin`, `aria-valuemax`, `aria-valuenow`, `aria-valuetext`, and `accessibilityValue` props. It only checks the values you specify, so the element can have other accessibility value entries and still match.\n\nFor the `text` entry, you can use a string or `RegExp`.\n\n### `toBeEnabled()` / `toBeDisabled` {#tobeenabled}\n\n```ts\nexpect(element).toBeEnabled();\nexpect(element).toBeDisabled();\n```\n\nChecks if an element is enabled or disabled from `aria-disabled` or `accessibilityState.disabled` props. An element is disabled if it or any ancestor is disabled.\n\n:::note\nThese matchers are opposites. Both are available so you can avoid double negations like `expect(element).not.toBeDisabled()`.\n:::\n\n### `toBeSelected()`\n\n```ts\nexpect(element).toBeSelected();\n```\n\nChecks if an element is selected from `aria-selected` or `accessibilityState.selected` props.\n\n### `toBeChecked()` / `toBePartiallyChecked()` {#tobechecked}\n\n```ts\nexpect(element).toBeChecked();\nexpect(element).toBePartiallyChecked();\n```\n\nChecks if an element is checked or partially checked from `aria-checked` or `accessibilityState.checked` props.\n\n:::note\n\n- `toBeChecked()` only works on `Switch` host elements and elements with `checkbox`, `radio`, or `switch` role.\n- `toBePartiallyChecked()` only works on elements with `checkbox` role.\n\n:::\n\n### `toBeExpanded()` / `toBeCollapsed()` {#tobeexpanded}\n\n```ts\nexpect(element).toBeExpanded();\nexpect(element).toBeCollapsed();\n```\n\nChecks if an element is expanded or collapsed from `aria-expanded` or `accessibilityState.expanded` props.\n\n:::note\nThese matchers are opposites for expandable elements (those with explicit `aria-expanded` or `accessibilityState.expanded` props). For non-expandable elements, neither matcher will pass.\n:::\n\n### `toBeBusy()`\n\n```ts\nexpect(element).toBeBusy();\n```\n\nChecks if an element is busy from `aria-busy` or `accessibilityState.busy` props.\n\n## Checking element style\n\n### `toBeVisible()`\n\n```ts\nexpect(element).toBeVisible();\n```\n\nChecks if an element is visible.\n\nAn element is invisible if it or any ancestor has `display: none` or `opacity: 0` styles, or if it's hidden from accessibility.\n\n### `toHaveStyle()`\n\n```ts\nexpect(element).toHaveStyle(\n  style: StyleProp<Style>,\n)\n```\n\nChecks if an element has specific styles.\n\n## Other matchers\n\n### `toHaveAccessibleName()`\n\n```ts\nexpect(element).toHaveAccessibleName(\n  name?: string | RegExp,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n  },\n)\n```\n\nChecks if an element has the specified accessible name. Accepts `string` or `RegExp`, with optional [text match options]() like `exact` and `normalizer`.\n\nThe accessible name comes from `aria-labelledby`, `accessibilityLabelledBy`, `aria-label`, and `accessibilityLabel` props. For `Image` elements, the `alt` prop is also used. If none are present, the element's text content is used.\n\nWithout a `name` parameter (or with `undefined`), it only checks whether the element has any accessible name.\n\n### `toHaveProp()`\n\n```ts\nexpect(element).toHaveProp(\n  name: string,\n  value?: unknown,\n)\n```\n\nChecks if an element has a prop. Without a `value` (or with `undefined`), it only checks if the prop exists. With a `value`, it checks if the prop's value matches.\n\n:::note\nUse this matcher as a last resort when other matchers don't fit your needs.\n:::\n","routePath":"/14.x/docs/api/jest-matchers","lang":"en","toc":[{"id":"setup","text":"Setup","depth":2,"charIndex":138},{"id":"checking-element-existence","text":"Checking element existence","depth":2,"charIndex":243},{"id":"tobeonthescreen","text":"`toBeOnTheScreen()`","depth":3,"charIndex":274},{"id":"element-content","text":"Element Content","depth":2,"charIndex":503},{"id":"tohavetextcontent","text":"`toHaveTextContent()`","depth":3,"charIndex":523},{"id":"tocontainelement","text":"`toContainElement()`","depth":3,"charIndex":858},{"id":"tobeemptyelement","text":"`toBeEmptyElement()`","depth":3,"charIndex":1021},{"id":"checking-element-state","text":"Checking element state","depth":2,"charIndex":1155},{"id":"tohavedisplayvalue","text":"`toHaveDisplayValue()`","depth":3,"charIndex":1182},{"id":"tohaveaccessibilityvalue","text":"`toHaveAccessibilityValue()`","depth":3,"charIndex":1524},{"id":"tobeenabled","text":"`toBeEnabled()` / `toBeDisabled`","depth":3,"charIndex":2086},{"id":"tobeselected","text":"`toBeSelected()`","depth":3,"charIndex":2516},{"id":"tobechecked","text":"`toBeChecked()` / `toBePartiallyChecked()`","depth":3,"charIndex":2676},{"id":"tobeexpanded","text":"`toBeExpanded()` / `toBeCollapsed()`","depth":3,"charIndex":3133},{"id":"tobebusy","text":"`toBeBusy()`","depth":3,"charIndex":3575},{"id":"checking-element-style","text":"Checking element style","depth":2,"charIndex":3715},{"id":"tobevisible","text":"`toBeVisible()`","depth":3,"charIndex":3742},{"id":"tohavestyle","text":"`toHaveStyle()`","depth":3,"charIndex":3968},{"id":"other-matchers","text":"Other matchers","depth":2,"charIndex":4101},{"id":"tohaveaccessiblename","text":"`toHaveAccessibleName()`","depth":3,"charIndex":4120},{"id":"tohaveprop","text":"`toHaveProp()`","depth":3,"charIndex":4808}],"frontmatter":{},"version":"14.x","description":"This guide covers the built-in Jest matchers. These matchers make your tests easier to read and work better with accessibility features."},{"title":"Accessibility","content":"## `isHiddenFromAccessibility`\n\n```ts\nfunction isHiddenFromAccessibility(element: HostElement | null): boolean {}\n```\n\nAlso available as `isInaccessible()` alias for React Testing Library compatibility.\n\nChecks if given element is hidden from assistive technology, e.g. screen readers.\n\n:::note\nLike [`isInaccessible`]() function from DOM Testing Library this function considers both accessibility elements and presentational elements (regular `View`s) to be accessible, unless they are hidden in terms of host platform.\n\nThis covers only part of [ARIA notion of Accessibility Tree](), as ARIA excludes both hidden and presentational elements from the Accessibility Tree.\n:::\n\nFor the scope of this function, element is inaccessible when it, or any of its ancestors, meets any of the following conditions:\n\n- it has `display: none` style\n- it has [`aria-hidden`]() prop set to `true`\n- it has [`accessibilityElementsHidden`]() prop set to `true`\n- it has [`importantForAccessibility`]() prop set to `no-hide-descendants`\n- it has sibling host element with either [`aria-modal`]() or [`accessibilityViewIsModal`]() prop set to `true`\n\nSpecifying `accessible={false}`, `role=\"none\"`, `accessibilityRole=\"none\"`, or `importantForAccessibility=\"no\"` props does not cause the element to become inaccessible.\n","routePath":"/14.x/docs/api/misc/accessibility","lang":"en","toc":[{"id":"ishiddenfromaccessibility","text":"`isHiddenFromAccessibility`","depth":2,"charIndex":0}],"frontmatter":{},"version":"14.x"},{"title":"Async utilities","content":"## `findBy*` queries\n\nThe `findBy*` queries are used to find elements that are not instantly available but will be added as a result of some asynchronous action. Learn more details [here]().\n\n## `waitFor`\n\n```tsx\nfunction waitFor<T>(\n  expectation: () => T,\n  options?: {\n    timeout?: number;\n    interval?: number;\n    onTimeout?: (error: Error) => Error;\n  }\n): Promise<T>;\n```\n\nWaits for the `expectation` callback to pass. `waitFor` runs the callback multiple times until timeout is reached, as specified by the `timeout` and `interval` options. The callback must throw an error when the expectation is not met. Returning any value, including a falsy one, is treated as meeting the expectation, and the callback result is returned to the caller.\n\n```tsx\nawait waitFor(() => expect(mockFunction).toHaveBeenCalledWith());\n```\n\n`waitFor` executes the `expectation` callback every `interval` (default: 50 ms) until `timeout` (default: 1000 ms) is reached. Execution stops as soon as the callback doesn't throw an error, and the callback's return value is returned to the caller. If timeout is reached, `waitFor` re-throws the final error thrown by `expectation`.\n\n```tsx\n// ❌ `waitFor` will return immediately because callback does not throw\nawait waitFor(() => false);\n```\n\n`waitFor` is an async function so you need to `await` the result to pause test execution.\n\n```jsx\n// ❌ missing `await`: `waitFor` will just return Promise that will be rejected when the timeout is reached\nwaitFor(() => expect(1).toBe(2));\n```\n\n:::note\nYou can enforce awaiting `waitFor` by using the [await-async-utils]() rule from [eslint-plugin-testing-library]().\n:::\n\nSince `waitFor` runs the `expectation` callback multiple times, [avoid performing side effects]() in `waitFor`.\n\n```jsx\nawait waitFor(async () => {\n  // ❌ button will be pressed on each waitFor iteration\n  await fireEvent.press(screen.getByText('press me'));\n  expect(mockOnPress).toHaveBeenCalled();\n});\n```\n\n:::note\nAvoiding side effects in `expectation` callback can be partially enforced with the [`no-wait-for-side-effects` rule]().\n:::\n\nUse a [single assertion per `waitFor`]() for consistency and faster failing tests. For multiple assertions, use separate `waitFor` calls. Often you won't need to wrap the second assertion in `waitFor` since the first one waits for the asynchronous change.\n\n`waitFor` checks whether Jest fake timers are enabled and adapts its behavior in such case. The following snippet is a simplified version of how it behaves when fake timers are enabled:\n\n```tsx\nlet fakeTimeRemaining = timeout;\nlet lastError;\n\nwhile (fakeTimeRemaining > 0) {\n  fakeTimeRemaining = fakeTimeRemaining - interval;\n  jest.advanceTimersByTime(interval);\n  try {\n    // resolve\n    return expectation();\n  } catch (error) {\n    lastError = error;\n  }\n}\n\n// reject\nthrow lastError;\n```\n\nIn the following example we test that a function is called after 10 seconds using fake timers. With fake timers, the test doesn't depend on real time passing, making it faster and more reliable. We don't need to advance fake timers through Jest's API because `waitFor` handles this.\n\n```tsx\n// in component\nsetTimeout(() => {\n  someFunction();\n}, 10000);\n\n// in test\njest.useFakeTimers();\n\nawait waitFor(\n  () => {\n    expect(someFunction).toHaveBeenCalledWith();\n  },\n  { timeout: 10000 }\n);\n```\n\n:::note\nIf you receive warnings related to `act()` function consult our [Understanding Act]() function document.\n:::\n\n### Options\n\n- `timeout`: How long to wait for, in ms. Defaults to 1000 ms (configured by `asyncUtilTimeout` option).\n- `interval`: How often to check, in ms. Defaults to 50 ms.\n- `onTimeout`: Callback to transform the error before it's thrown. Useful for debugging, e.g., `onTimeout: () => { screen.debug(); }`.\n\n## `waitForElementToBeRemoved`\n\n```ts\nfunction waitForElementToBeRemoved<T>(\n  expectation: () => T,\n  options?: {\n    timeout?: number;\n    interval?: number;\n    onTimeout?: (error: Error) => Error;\n  }\n): Promise<T>;\n```\n\nWaits for non-deterministic periods of time until queried element is removed or times out. `waitForElementToBeRemoved` periodically calls `expectation` every `interval` milliseconds to determine whether the element has been removed or not.\n\n```jsx\n\n\ntest('waiting for an Banana to be removed', async () => {\n  await render(<Banana />);\n\n  await waitForElementToBeRemoved(() => screen.getByText('Banana ready'));\n});\n```\n\nThis method expects that the element is initially present in the render tree and then is removed from it. If the element is not present when you call this method it throws an error.\n\nYou can use any of `getBy`, `getAllBy`, `queryBy` and `queryAllBy` queries for `expectation` parameter.\n\n:::note\nIf you receive warnings related to `act()` function consult our [Understanding Act]() function document.\n:::\n","routePath":"/14.x/docs/api/misc/async","lang":"en","toc":[{"id":"findby-queries","text":"`findBy*` queries","depth":2,"charIndex":0},{"id":"waitfor","text":"`waitFor`","depth":2,"charIndex":192},{"id":"options","text":"Options","depth":3,"charIndex":3460},{"id":"waitforelementtoberemoved","text":"`waitForElementToBeRemoved`","depth":2,"charIndex":3774}],"frontmatter":{},"version":"14.x"},{"title":"Configuration","content":"## `configure`\n\n```ts\ntype Config = {\n  /** Default timeout, in ms, for `waitFor` and `findBy*` queries. */\n  asyncUtilTimeout: number;\n\n  /** Default value for `includeHiddenElements` query option. */\n  defaultIncludeHiddenElements: boolean;\n\n  /** Default options for `debug` helper. */\n  defaultDebugOptions?: Partial<DebugOptions>;\n};\n\ntype ConfigAliasOptions = {\n  /** RTL-compatibility alias for `defaultIncludeHiddenElements`. */\n  defaultHidden: boolean;\n};\n\nfunction configure(options: Partial<Config & ConfigAliasOptions>) {}\n```\n\n### `asyncUtilTimeout` option\n\nDefault timeout, in ms, for async helper functions (`waitFor`, `waitForElementToBeRemoved`) and `findBy*` queries. Defaults to 1000 ms.\n\n### `defaultIncludeHiddenElements` option\n\nDefault value for [includeHiddenElements]() query option for all queries. The default value is set to `false`, so all queries will not match [elements hidden from accessibility](). This is because the users of the app would not be able to see such elements.\n\nThis option is also available as `defaultHidden` alias for compatibility with [React Testing Library]().\n\n### `defaultDebugOptions` option\n\nDefault [debug options]() to be used when calling `debug()`. These default options will be overridden by the ones you specify directly when calling `debug()`.\n\n## `resetToDefaults()`\n\n```ts\nfunction resetToDefaults() {}\n```\n\n## Environment variables\n\n### `RNTL_SKIP_AUTO_CLEANUP`\n\nSet to `true` to disable automatic `cleanup()` after each test. It works the same as importing `react-native-testing-library/dont-cleanup-after-each` or using `react-native-testing-library/pure`.\n\n```shell\n$ RNTL_SKIP_AUTO_CLEANUP=true jest\n```\n\n### `RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`\n\nSet to `true` to disable auto-detection of fake timers. This might be useful in rare cases when you want to use non-Jest fake timers. See [issue #886]() for more details.\n\n```shell\n$ RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS=true jest\n```\n","routePath":"/14.x/docs/api/misc/config","lang":"en","toc":[{"id":"configure","text":"`configure`","depth":2,"charIndex":0},{"id":"asyncutiltimeout-option","text":"`asyncUtilTimeout` option","depth":3,"charIndex":541},{"id":"defaultincludehiddenelements-option","text":"`defaultIncludeHiddenElements` option","depth":3,"charIndex":709},{"id":"defaultdebugoptions-option","text":"`defaultDebugOptions` option","depth":3,"charIndex":1117},{"id":"resettodefaults","text":"`resetToDefaults()`","depth":2,"charIndex":1311},{"id":"environment-variables","text":"Environment variables","depth":2,"charIndex":1376},{"id":"rntl_skip_auto_cleanup","text":"`RNTL_SKIP_AUTO_CLEANUP`","depth":3,"charIndex":1402},{"id":"rntl_skip_auto_detect_fake_timers","text":"`RNTL_SKIP_AUTO_DETECT_FAKE_TIMERS`","depth":3,"charIndex":1678}],"frontmatter":{},"version":"14.x"},{"title":"Other helpers","content":"## `within` {#within}\n\n```jsx\nfunction within(element: HostElement): Queries {}\n```\n\n`within` performs [queries]() scoped to given element.\n\n:::note\nPlease note that additional `render` specific operations like `rerender`, `unmount`, `debug`, `toJSON` are *not* included.\n:::\n\n```jsx\nconst detailsScreen = within(screen.getByHintText('Details Screen'));\nexpect(detailsScreen.getByText('Some Text')).toBeOnTheScreen();\nexpect(detailsScreen.getByDisplayValue('Some Value')).toBeOnTheScreen();\nexpect(detailsScreen.queryByLabelText('Some Label')).toBeOnTheScreen();\nawait expect(detailsScreen.findByHintText('Some Label')).resolves.toBeOnTheScreen();\n```\n\nUse cases for scoped queries include:\n\n- queries scoped to a single item inside a FlatList containing many items\n- queries scoped to a single screen in tests involving screen transitions (e.g. with react-navigation)\n\n## `act`\n\n```ts\nfunction act<T>(callback: () => T | Promise<T>): Promise<T>;\n```\n\nWraps code that causes React state updates to ensure all updates are processed before assertions. By default any `render`, `rerender`, `fireEvent`, and `waitFor` calls are wrapped by this function, so there is no need to wrap it manually.\n\n**In v14, `act` is now async by default and always returns a Promise**. This works with async React features like `Suspense` boundaries and the `use()` hook. All pending React updates are executed before the Promise resolves.\n\n```ts\n\n\nit('should update state', async () => {\n  await act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n```\n\n**Note**: Even if your callback is synchronous, you should still use `await act(...)` as `act` now always returns a Promise.\n\nConsult our [Understanding Act function]() document for more understanding of its intricacies.\n\n## `cleanup`\n\n```ts\nfunction cleanup(): Promise<void>;\n```\n\nUnmounts React trees that were mounted with `render` and clears `screen` variable that holds latest `render` output.\n\n:::info\nPlease note that this is done automatically if the testing framework you're using supports the `afterEach` global (like mocha, Jest, and Jasmine). If not, you will need to do manual cleanups after each test.\n:::\n\nFor example, if you're using the `jest` testing framework, then you would need to use the `afterEach` hook like so:\n\n```jsx\n\n\n\nafterEach(async () => {\n  await cleanup();\n});\n\nit('renders a view', async () => {\n  await render(<View />);\n  // ...\n});\n```\n\nThe `afterEach(cleanup)` call also works in `describe` blocks:\n\n```jsx\ndescribe('when logged in', () => {\n  afterEach(async () => {\n    await cleanup();\n  });\n\n  it('renders the user', async () => {\n    await render(<SiteHeader />);\n    // ...\n  });\n});\n```\n\nFailing to call `cleanup` when you've called `render` could result in a memory leak and tests which are not \"idempotent\" (which can lead to difficult to debug errors in your tests).\n","routePath":"/14.x/docs/api/misc/other","lang":"en","toc":[{"id":"within","text":"`within`","depth":2,"charIndex":0},{"id":"act","text":"`act`","depth":2,"charIndex":870},{"id":"cleanup","text":"`cleanup`","depth":2,"charIndex":1786}],"frontmatter":{},"version":"14.x"},{"title":"`renderHook` function","content":"## `renderHook`\n\n```ts\nasync function renderHook<Result, Props>(\n  hookFn: (props: Props) => Result,\n  options?: RenderHookOptions<Props>\n): Promise<RenderHookResult<Result, Props>>;\n```\n\nRenders a test component that calls the provided `callback` (and any hooks it uses) on each render. Returns a Promise that resolves to a [`RenderHookResult`]() object.\n\n**This is the recommended default API** for testing hooks. It uses async `act` internally to ensure all pending React updates are executed during rendering. This makes it compatible with async React features like `Suspense` boundaries and the `use()` hook.\n\n- **Returns a Promise**: Should be awaited\n- **Async methods**: Both `rerender` and `unmount` return Promises and should be awaited\n- **Suspense support**: Compatible with `Suspense` boundaries and `use()` hook\n\n```ts\n\n\n\nit('should increment count', async () => {\n  const { result } = await renderHook(() => useCount());\n\n  expect(result.current.count).toBe(0);\n  await act(() => {\n    // Note that you should wrap the calls to functions your hook returns with `act` if they trigger an update of your hook's state to ensure pending useEffects are run before your next assertion.\n    result.current.increment();\n  });\n  expect(result.current.count).toBe(1);\n});\n```\n\n```ts\n// useCount.js\n\n\nexport const useCount = () => {\n  const [count, setCount] = useState(0);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  return { count, increment };\n};\n```\n\nThe `renderHook` function accepts the following arguments:\n\n**Callback**: A function called on each render of the test component. This function should call one or more hooks for testing.\n\nThe callback receives `props` from the `initialProps` option, or from a subsequent `rerender` call if provided.\n\n### `options`\n\nA `RenderHookOptions<Props>` object with the following properties:\n\n#### `initialProps` {#initial-props}\n\nThe initial values to pass as `props` to the `callback` function of `renderHook`. The `Props` type is determined by the type passed to or inferred by the `renderHook` call.\n\n#### `wrapper`\n\nA React component that wraps the test component. Use this to add context providers so hooks can access them with `useContext`.\n\n### Result\n\n```ts\ninterface RenderHookResult<Result, Props> {\n  result: { current: Result };\n  rerender: (props: Props) => Promise<void>;\n  unmount: () => Promise<void>;\n}\n```\n\nThe `renderHook` function returns a Promise that resolves to an object with the following properties:\n\n#### `result`\n\nThe `current` value contains whatever the `callback` returned from `renderHook`. The `Result` type is determined by the type passed to or inferred by the `renderHook` call.\n\n**Note:** When using React Suspense, `result.current` will be `null` while the hook is suspended.\n\n#### `rerender`\n\nAn async function that rerenders the test component and recalculates hooks. If `newProps` are passed, they replace the `callback` function's `initialProps` for subsequent rerenders. The `Props` type is determined by the type passed to or inferred by the `renderHook` call.\n\n**Note**: This method returns a Promise and should be awaited.\n\n#### `unmount`\n\nAn async function to unmount the test component. This is commonly used to trigger cleanup effects for `useEffect` hooks.\n\n**Note**: This method returns a Promise and should be awaited.\n\n### Examples\n\nAdditional examples of using `renderHook`:\n\n#### With `initialProps`\n\n```ts\n\n\n\nconst useCount = (initialCount: number) => {\n  const [count, setCount] = useState(initialCount);\n  const increment = () => setCount((previousCount) => previousCount + 1);\n\n  useEffect(() => {\n    setCount(initialCount);\n  }, [initialCount]);\n\n  return { count, increment };\n};\n\nit('should increment count', async () => {\n  const { result, rerender } = await renderHook((initialCount: number) => useCount(initialCount), {\n    initialProps: 1,\n  });\n\n  expect(result.current.count).toBe(1);\n\n  await act(() => {\n    result.current.increment();\n  });\n\n  expect(result.current.count).toBe(2);\n  await rerender(5);\n  expect(result.current.count).toBe(5);\n});\n```\n\n#### With `wrapper`\n\n```tsx\nit('should use context value', async () => {\n  function Wrapper({ children }: { children: ReactNode }) {\n    return <Context.Provider value=\"provided\">{children}</Context.Provider>;\n  }\n\n  const { result } = await renderHook(() => useHook(), { wrapper: Wrapper });\n  // ...\n});\n```\n\n#### With React Suspense\n\n```tsx\n\n\n\nfunction useSuspendingHook(promise: Promise<string>) {\n  return React.use(promise);\n}\n\nit('handles hook with suspense', async () => {\n  let resolvePromise: (value: string) => void;\n  const promise = new Promise<string>((resolve) => {\n    resolvePromise = resolve;\n  });\n\n  const { result } = await renderHook(useSuspendingHook, {\n    initialProps: promise,\n    wrapper: ({ children }) => (\n      <React.Suspense fallback={<Text>Loading...</Text>}>{children}</React.Suspense>\n    ),\n  });\n\n  // Initially suspended, result should not be available\n  expect(result.current).toBeNull();\n\n  await act(() => resolvePromise('resolved'));\n  expect(result.current).toBe('resolved');\n});\n```\n","routePath":"/14.x/docs/api/misc/render-hook","lang":"en","toc":[{"id":"renderhook","text":"`renderHook`","depth":2,"charIndex":0},{"id":"options","text":"`options`","depth":3,"charIndex":1792},{"id":"initial-props","text":"`initialProps`","depth":4,"charIndex":1875},{"id":"wrapper","text":"`wrapper`","depth":4,"charIndex":2087},{"id":"result","text":"Result","depth":3,"charIndex":2231},{"id":"result-1","text":"`result`","depth":4,"charIndex":-1},{"id":"rerender","text":"`rerender`","depth":4,"charIndex":2799},{"id":"unmount","text":"`unmount`","depth":4,"charIndex":3154},{"id":"examples","text":"Examples","depth":3,"charIndex":3356},{"id":"with-initialprops","text":"With `initialProps`","depth":4,"charIndex":3414},{"id":"with-wrapper","text":"With `wrapper`","depth":4,"charIndex":4108},{"id":"with-react-suspense","text":"With React Suspense","depth":4,"charIndex":4419}],"frontmatter":{},"version":"14.x"},{"title":"Queries","content":"Queries are one of the main building blocks for the React Native Testing Library. They enable you to find relevant elements in the element tree, which represents your application's user interface when running under tests.\n\n## Accessing queries\n\nAll queries described below are accessible in two main ways: through the `screen` object or by capturing the `render` function call result.\n\n### Using `screen` object\n\n```tsx\n\n\ntest('accessing queries using \"screen\" object', async () => {\n  await render(...);\n\n  screen.getByRole(\"button\", { name: \"Start\" });\n})\n```\n\nUse the `screen` object exported by `@testing-library/react-native` to access queries. This object contains all available query methods bound to the most recently rendered UI.\n\n### Using `render` result\n\n```tsx\n\n\ntest('accessing queries using \"render\" result', async () => {\n  const { getByRole } = await render(...);\n  getByRole(\"button\", { name: \"Start\" });\n})\n```\n\nYou can also capture query functions from the `render` function return value. This provides the same query functions as the `screen` object.\n\n## Query parts\n\nEach query is composed of two parts: variant and predicate, which are separated by the `by` word in the middle of the name.\n\nConsider the following query:\n\n```\ngetByRole()\n```\n\nFor this query, `getBy*` is the query variant, and `*ByRole` is the predicate.\n\n## Query variant\n\nThe query variants describe the expected number (and timing) of matching elements, so they differ in their return type.\n\n| Variant           | Assertion                     | Return type                      | Is Async? |\n| ----------------- | ----------------------------- | -------------------------------- | --------- |\n| [`getBy*`]()      | Exactly one matching element  | `HostElement`                    | No        |\n| [`getAllBy*`]()   | At least one matching element | `Array<HostElement>`             | No        |\n| [`queryBy*`]()    | Zero or one matching element  | <code>HostElement \\| null</code> | No        |\n| [`queryAllBy*`]() | No assertion                  | `Array<HostElement>`             | No        |\n| [`findBy*`]()     | Exactly one matching element  | `Promise<HostElement>`           | Yes       |\n| [`findAllBy*`]()  | At least one matching element | `Promise<Array<HostElement>>`    | Yes       |\n\nQueries work as implicit assertions on the number of matching elements and will throw an error when the assertion fails.\n\n### `getBy*` queries {#get-by}\n\n```ts\ngetByX(...): HostElement\n```\n\n`getBy*` queries return the single matching element for a query, and throw an error if no elements match or if more than one match is found. If you need to find more than one element, then use `getAllBy`.\n\n### `getAllBy*` queries {#get-all-by}\n\n```ts\ngetAllByX(...): HostElement[]\n```\n\n`getAllBy*` queries return an array of all matching elements for a query and throw an error if no elements match.\n\n### `queryBy*` queries {#query-by}\n\n```ts\nqueryByX(...): HostElement | null\n```\n\n`queryBy*` queries return the first matching node for a query, or `null` if no elements match. Use these to assert that an element is not present. They throw if more than one match is found (use `queryAllBy` instead).\n\n### `queryAllBy*` queries {#query-all-by}\n\n```ts\nqueryAllByX(...): HostElement[]\n```\n\n`queryAllBy*` queries return an array of all matching nodes for a query and return an empty array (`[]`) when no elements match.\n\n### `findBy*` queries {#find-by}\n\n```ts\nfindByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<HostElement>\n```\n\n`findBy*` queries return a promise which resolves when a matching element is found. The promise is rejected if no elements match or if more than one match is found after a default timeout of 1000 ms. If you need to find more than one element use `findAllBy*` queries.\n\n### `findAllBy*` queries {#find-all-by}\n\n```ts\nfindAllByX(\n  ...,\n  waitForOptions?: {\n    timeout?: number,\n    interval?: number,\n  },\n): Promise<HostElement[]>\n```\n\n`findAllBy*` queries return a promise which resolves to an array of matching elements. The promise is rejected if no elements match after a default timeout of 1000 ms.\n\n:::info\n`findBy*` and `findAllBy*` queries accept optional `waitForOptions` object arguments, which can contain `timeout`, `interval` and `onTimeout` properties which have the same meaning as respective options for [`waitFor`]() function.\n:::\n\n:::info\nIn cases when your `findBy*` and `findAllBy*` queries throw when unable to find matching elements, it is helpful to pass `onTimeout: () => { screen.debug(); }` callback using the `waitForOptions` parameter.\n:::\n\n## Query predicates\n\n*Note: most methods like this one return a [`HostElement`]() with following properties that you may be interested in:*\n\n```typescript\ntype HostElement = {\n  type: string;\n  props: { [propName: string]: any };\n  parent: HostElement | null;\n  children: Array<HostElement | string>;\n};\n```\n\n### `*ByRole` {#by-role}\n\n> getByRole, getAllByRole, queryByRole, queryAllByRole, findByRole, findAllByRole\n\n```ts\ngetByRole(\n  role: TextMatch,\n  options?: {\n    name?: TextMatch\n    disabled?: boolean,\n    selected?: boolean,\n    checked?: boolean | 'mixed',\n    busy?: boolean,\n    expanded?: boolean,\n    value: {\n      min?: number;\n      max?: number;\n      now?: number;\n      text?: TextMatch;\n    },\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n```\n\nReturns a `HostElement` with matching `role` or `accessibilityRole` prop.\n\n:::info\nIn order for `*ByRole` queries to match an element it needs to be considered an accessibility element:\n\n1. `Text`, `TextInput` and `Switch` elements are these by default.\n2. `View` elements need an explicit [`accessible`]() prop set to `true`\n3. Some React Native composite components like `Pressable` & `TouchableOpacity` render host `View` element with `accessible` prop already set.\n\n:::\n\n```jsx\n\n\nawait render(\n  <Pressable accessibilityRole=\"button\" disabled>\n    <Text>Hello</Text>\n  </Pressable>\n);\nconst element = screen.getByRole('button');\nconst element2 = screen.getByRole('button', { name: 'Hello' });\nconst element3 = screen.getByRole('button', { name: 'Hello', disabled: true });\n```\n\n#### Options {#by-role-options}\n\n- `name`: Finds an element with given `role`/`accessibilityRole` and an accessible name (= accessability label or text content).\n\n- `disabled`: You can filter elements by their disabled state (coming either from `aria-disabled` prop or `accessbilityState.disabled` prop). The possible values are `true` or `false`. Querying `disabled: false` will also match elements with `disabled: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `disabled` state.\n  - This option can alternatively be expressed using the [`toBeEnabled()` / `toBeDisabled()`]() Jest matchers.\n\n- `selected`: You can filter elements by their selected state (coming either from `aria-selected` prop or `accessbilityState.selected` prop). The possible values are `true` or `false`. Querying `selected: false` will also match elements with `selected: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `selected` state.\n  - This option can alternatively be expressed using the [`toBeSelected()`]() Jest matcher.\n\n* `checked`: You can filter elements by their checked state (coming either from `aria-checked` prop or `accessbilityState.checked` prop). The possible values are `true`, `false`, or `\"mixed\"`.\n  - See [React Native's accessibilityState]() docs to learn more about the `checked` state.\n  - This option can alternatively be expressed using the [`toBeChecked()` / `toBePartiallyChecked()`]() Jest matchers.\n\n* `busy`: You can filter elements by their busy state (coming either from `aria-busy` prop or `accessbilityState.busy` prop). The possible values are `true` or `false`. Querying `busy: false` will also match elements with `busy: undefined` (see the [wiki]() for more details).\n  - See [React Native's accessibilityState]() docs to learn more about the `busy` state.\n  - This option can alternatively be expressed using the [`toBeBusy()`]() Jest matcher.\n\n* `expanded`: You can filter elements by their expanded state (coming either from `aria-expanded` prop or `accessbilityState.expanded` prop). The possible values are `true` or `false`.\n  - See [React Native's accessibilityState]() docs to learn more about the `expanded` state.\n  - This option can alternatively be expressed using the [`toBeExpanded()` / `toBeCollapsed()`]() Jest matchers.\n\n* `value`: Filter elements by their accessibility value, based on either `aria-valuemin`, `aria-valuemax`, `aria-valuenow`, `aria-valuetext` or `accessibilityValue` props. Accessiblity value conceptually consists of numeric `min`, `max` and `now` entries, as well as string `text` entry.\n  - See React Native [accessibilityValue]() docs to learn more about the accessibility value concept.\n  - This option can alternatively be expressed using the [`toHaveAccessibilityValue()`]() Jest matcher.\n\n### `*ByLabelText` {#by-label-text}\n\n> getByLabelText, getAllByLabelText, queryByLabelText, queryAllByLabelText, findByLabelText, findAllByLabelText\n\n```ts\ngetByLabelText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n```\n\nReturns a `HostElement` with matching label:\n\n- either by matching [`aria-label`]()/[`accessibilityLabel`]() prop\n- or by matching text content of view referenced by [`aria-labelledby`]()/[`accessibilityLabelledBy`]() prop\n- or by matching the [`alt`]() prop on `Image` elements\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByLabelText('my-label');\n```\n\n### `*ByPlaceholderText` {#by-placeholder-text}\n\n> getByPlaceholderText, getAllByPlaceholderText, queryByPlaceholderText, queryAllByPlaceholderText, findByPlaceholderText, findAllByPlaceholderText\n\n```ts\ngetByPlaceholderText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n```\n\nReturns a `HostElement` for a `TextInput` with a matching placeholder – may be a string or regular expression.\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByPlaceholderText('username');\n```\n\n### `*ByDisplayValue` {#by-display-value}\n\n> getByDisplayValue, getAllByDisplayValue, queryByDisplayValue, queryAllByDisplayValue, findByDisplayValue, findAllByDisplayValue\n\n```ts\ngetByDisplayValue(\n  value: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n```\n\nReturns a `HostElement` for a `TextInput` with a matching display value – may be a string or regular expression.\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByDisplayValue('username');\n```\n\n### `*ByText` {#by-text}\n\n> getByText, getAllByText, queryByText, queryAllByText, findByText, findAllByText\n\n```ts\ngetByText(\n  text: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  }\n): HostElement;\n```\n\nReturns a `HostElement` with matching text – may be a string or regular expression.\n\nThis method will join `<Text>` siblings to find matches, similarly to [how React Native handles these components](). This will allow for querying for strings that will be visually rendered together, but may be semantically separate React components.\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByText('banana');\n```\n\n### `*ByHintText` {#by-hint-text}\n\n> getByA11yHint, getAllByA11yHint, queryByA11yHint, queryAllByA11yHint, findByA11yHint, findAllByA11yHint\n> getByAccessibilityHint, getAllByAccessibilityHint, queryByAccessibilityHint, queryAllByAccessibilityHint, findByAccessibilityHint, findAllByAccessibilityHint\n> getByHintText, getAllByHintText, queryByHintText, queryAllByHintText, findByHintText, findAllByHintText\n\n```ts\ngetByHintText(\n  hint: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n```\n\nReturns a `HostElement` with matching `accessibilityHint` prop.\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByHintText('Plays a song');\n```\n\n:::info\nPlease consult [Apple guidelines on how `accessibilityHint` should be used]().\n:::\n\n### `*ByTestId` {#by-test-id}\n\n> getByTestId, getAllByTestId, queryByTestId, queryAllByTestId, findByTestId, findAllByTestId\n\n```ts\ngetByTestId(\n  testId: TextMatch,\n  options?: {\n    exact?: boolean;\n    normalizer?: (text: string) => string;\n    includeHiddenElements?: boolean;\n  },\n): HostElement;\n```\n\nReturns a `HostElement` with matching `testID` prop. `testID` – may be a string or a regular expression.\n\n```jsx\n\n\nawait render(<MyComponent />);\nconst element = screen.getByTestId('unique-id');\n```\n\n:::info\nFollowing [the guiding principles](), use this only when other queries don't work for your use case. `testID` attributes don't resemble how your software is used and should be avoided when possible. They're useful for end-to-end testing on real devices, e.g. with Detox. Learn more from the blog post [\"Making your UI tests resilient to change\"]().\n:::\n\n### Common options\n\nUsually query first argument can be a **string** or a **regex**. All queries take at least the [`hidden`]() option as an optionnal second argument and some queries accept more options which change string matching behaviour. See [TextMatch]() for more info.\n\n#### `includeHiddenElements` option\n\nAll queries have the `includeHiddenElements` option which affects whether [elements hidden from accessibility]() are matched by the query. By default queries will not match hidden elements, because the users of the app would not be able to see such elements.\n\nYou can configure the default value with the [`configure` function]().\n\nThis option is also available as `hidden` alias for compatibility with [React Testing Library]().\n\n**Examples**\n\n```tsx\nawait render(<Text style={{ display: 'none' }}>Hidden from accessibility</Text>);\n\n// Exclude hidden elements\nexpect(\n  screen.queryByText('Hidden from accessibility', {\n    includeHiddenElements: false,\n  })\n).not.toBeOnTheScreen();\n\n// Include hidden elements\nexpect(screen.getByText('Hidden from accessibility')).toBeOnTheScreen();\nexpect(\n  screen.getByText('Hidden from accessibility', { includeHiddenElements: true })\n).toBeOnTheScreen();\n```\n\n## TextMatch type\n\n```ts\ntype TextMatch = string | RegExp;\n```\n\nMost of the query APIs take a `TextMatch` as an argument, which means the argument can be either a *string* or *regex*.\n\n### Examples\n\nGiven the following render:\n\n```jsx\nawait render(<Text>Hello World</Text>);\n```\n\nWill **find a match**:\n\n```js\n// Matching a string:\nscreen.getByText('Hello World'); // full string match\nscreen.getByText('llo Worl', { exact: false }); // substring match\nscreen.getByText('hello world', { exact: false }); // ignore case-sensitivity\n\n// Matching a regex:\nscreen.getByText(/World/); // substring match\nscreen.getByText(/world/i); // substring match, ignore case\nscreen.getByText(/^hello world$/i); // full string match, ignore case-sensitivity\nscreen.getByText(/Hello W?oRlD/i); // advanced regex\n```\n\nWill **NOT find a match**\n\n```js\n// substring does not match\nscreen.getByText('llo Worl');\n// full string does not match\nscreen.getByText('Goodbye World');\n\n// case-sensitive regex with different case\nscreen.getByText(/hello world/);\n```\n\n### Options {#text-match-options}\n\n#### Precision\n\n```typescript\ntype TextMatchOptions = {\n  exact?: boolean;\n  normalizer?: (text: string) => string;\n};\n```\n\nQueries that take a `TextMatch` also accept an object as the second argument that can contain options that affect the precision of string matching:\n\n- `exact`: Defaults to `true`; matches full strings, case-sensitive. When false, matches substrings and is not case-sensitive.\n  - `exact` has no effect on regex argument.\n  - In most cases using a `regex` instead of a string gives you more control over fuzzy matching and should be preferred over `{ exact: false }`.\n- `normalizer`: An optional function which overrides normalization behavior. See [Normalization]().\n\n`exact` option defaults to `true` but if you want to search for a text slice or make text matching case-insensitive you can override it. That being said we advise you to use regex in more complex scenarios.\n\n#### Normalization\n\nBefore running any matching logic against text, it is automatically normalized. By default, normalization consists of trimming whitespace from the start and end of text, and collapsing multiple adjacent whitespace characters into a single space.\n\nIf you want to prevent that normalization, or provide alternative normalization (e.g. to remove Unicode control characters), you can provide a `normalizer` function in the options object. This function will be given a string and is expected to return a normalized version of that string.\n\n:::info\nSpecifying a value for `normalizer` replaces the built-in normalization, but you can call `getDefaultNormalizer` to obtain a built-in normalizer, either to adjust that normalization or to call it from your own normalizer.\n:::\n\n`getDefaultNormalizer` take options object which allows the selection of behaviour:\n\n- `trim`: Defaults to `true`. Trims leading and trailing whitespace.\n- `collapseWhitespace`: Defaults to `true`. Collapses inner whitespace (newlines, tabs repeated spaces) into a single space.\n\n##### Normalization Examples\n\nTo perform a match against text without trimming:\n\n```typescript\nscreen.getByText('text', {\n  normalizer: getDefaultNormalizer({ trim: false }),\n});\n```\n\nTo override normalization to remove some Unicode characters whilst keeping some (but not all) of the built-in normalization behavior:\n\n```typescript\nscreen.getByText('text', {\n  normalizer: (str) => getDefaultNormalizer({ trim: false })(str).replace(/[\\u200E-\\u200F]*/g, ''),\n});\n```\n","routePath":"/14.x/docs/api/queries","lang":"en","toc":[{"id":"accessing-queries","text":"Accessing queries","depth":2,"charIndex":223},{"id":"using-screen-object","text":"Using `screen` object","depth":3,"charIndex":386},{"id":"using-render-result","text":"Using `render` result","depth":3,"charIndex":740},{"id":"query-parts","text":"Query parts","depth":2,"charIndex":1073},{"id":"query-variant","text":"Query variant","depth":2,"charIndex":1346},{"id":"get-by","text":"`getBy*` queries","depth":3,"charIndex":2416},{"id":"get-all-by","text":"`getAllBy*` queries","depth":3,"charIndex":2690},{"id":"query-by","text":"`queryBy*` queries","depth":3,"charIndex":2885},{"id":"query-all-by","text":"`queryAllBy*` queries","depth":3,"charIndex":3185},{"id":"find-by","text":"`findBy*` queries","depth":3,"charIndex":3401},{"id":"find-all-by","text":"`findAllBy*` queries","depth":3,"charIndex":3826},{"id":"query-predicates","text":"Query predicates","depth":2,"charIndex":4627},{"id":"by-role","text":"`*ByRole`","depth":3,"charIndex":4936},{"id":"by-role-options","text":"Options","depth":4,"charIndex":6189},{"id":"by-label-text","text":"`*ByLabelText`","depth":3,"charIndex":9092},{"id":"by-placeholder-text","text":"`*ByPlaceholderText`","depth":3,"charIndex":9800},{"id":"by-display-value","text":"`*ByDisplayValue`","depth":3,"charIndex":10399},{"id":"by-text","text":"`*ByText`","depth":3,"charIndex":10972},{"id":"by-hint-text","text":"`*ByHintText`","depth":3,"charIndex":11682},{"id":"by-test-id","text":"`*ByTestId`","depth":3,"charIndex":12527},{"id":"common-options","text":"Common options","depth":3,"charIndex":13396},{"id":"includehiddenelements-option","text":"`includeHiddenElements` option","depth":4,"charIndex":13674},{"id":"textmatch-type","text":"TextMatch type","depth":2,"charIndex":14613},{"id":"examples","text":"Examples","depth":3,"charIndex":14798},{"id":"text-match-options","text":"Options","depth":3,"charIndex":6190},{"id":"precision","text":"Precision","depth":4,"charIndex":15686},{"id":"normalization","text":"Normalization","depth":4,"charIndex":16586}],"frontmatter":{},"version":"14.x","description":"Queries are one of the main building blocks for the React Native Testing Library. They enable you to find relevant elements in the element tree, which represents your application's user interface when running under tests."},{"title":"`render` API","content":"## `render` function {#render}\n\n```ts\nasync function render<T>(\n  element: React.ReactElement<T>,\n  options?: RenderOptions\n): Promise<RenderResult>;\n```\n\nThe `render` function is the entry point for writing React Native Testing Library tests. It deeply renders the given React element and returns helpers to query the output. The function is async and uses async `act` internally, so all pending React updates run before it resolves. This works with async React features like `Suspense` boundaries and the `use()` hook.\n\n```jsx\n\n\ntest('basic test', async () => {\n  await render(<MyApp />);\n  expect(screen.getAllByRole('button', { name: 'start' })).toBeOnTheScreen();\n});\n```\n\n> When using React context providers like Redux Provider, you'll likely want to wrap the rendered component with them. In such cases, create your own custom `render` method. [Follow this guide on how to set it up]().\n\n### Options\n\nYou can customize the `render` method by passing options as the second argument:\n\n#### `wrapper`\n\n```ts\nwrapper?: React.ComponentType<any>,\n```\n\nWraps the tested component in an additional wrapper component. Use this to create custom render functions for common React Context providers.\n\n#### `createNodeMock` {#create-node-mock}\n\n```ts\ncreateNodeMock?: (element: React.ReactElement) => object,\n```\n\nPasses `createNodeMock` to the renderer's `create()` method for custom mock refs. This option is passed through to [Test Renderer]().\n\n:::note Text string validation\n\nTest Renderer enforces React Native's requirement that text strings must be rendered within a `<Text>` component. If you render a `string` value under components other than `<Text>` (e.g., under `<View>`), it throws an `Invariant Violation: Text strings must be rendered within a <Text> component` error. This matches React Native's runtime behavior.\n\nThis validation is always enabled and cannot be disabled. Your tests will catch the same text rendering errors that would occur in production.\n\n:::\n\n### Result\n\nThe `render` function returns a promise that resolves to the same queries and utilities as the [`screen`]() object. Use `screen` for queries and the lifecycle methods from the render result when needed.\n\nSee [this article]() from Kent C. Dodds for more details.\n\n:::note Type information\n\nQuery results and element references use the `HostElement` type from [Test Renderer](). If you need to type element variables, import this type directly from `test-renderer`.\n\n:::\n","routePath":"/14.x/docs/api/render","lang":"en","toc":[{"id":"render","text":"`render` function","depth":2,"charIndex":0},{"id":"options","text":"Options","depth":3,"charIndex":896},{"id":"wrapper","text":"`wrapper`","depth":4,"charIndex":991},{"id":"create-node-mock","text":"`createNodeMock`","depth":4,"charIndex":1197},{"id":"result","text":"Result","depth":3,"charIndex":1977}],"frontmatter":{},"version":"14.x"},{"title":"`screen` object","content":"```ts\nlet screen: {\n  ...queries;\n  rerender(element: React.Element<unknown>): Promise<void>;\n  unmount(): Promise<void>;\n  debug(options?: DebugOptions): void\n  toJSON(): JsonElement | null;\n  container: HostElement;\n  root: HostElement | null;\n};\n```\n\nThe `screen` object provides access to queries and utilities for the currently rendered UI.\n\nThis object is assigned after the `render` call and cleared after each test by calling [`cleanup`](). If no `render` call has been made in a given test, then it holds a special object and throws a helpful error on each property and method access.\n\n### `...queries`\n\nThe main feature of `screen` is its queries for finding elements in the view hierarchy.\n\nSee [Queries]() for a complete list.\n\n#### Example\n\n```jsx\n\n\ntest('example', async () => {\n  await render(<MyComponent />);\n  const buttonStart = screen.getByRole('button', { name: 'start' });\n});\n```\n\n### `rerender`\n\n```ts\nfunction rerender(element: React.Element<unknown>): Promise<void>;\n```\n\nRe-render the in-memory tree with a new root element. This simulates a React update render at the root. If the new element has the same type (and `key`) as the previous element, the tree will be updated; otherwise, it will re-mount a new tree, in both cases triggering the appropriate lifecycle events.\n\nThis method is async and uses async `act` internally to execute all pending React updates during updating. This works with async React features like `Suspense` boundaries and the `use()` hook.\n\n```jsx\n\n\ntest('async rerender test', async () => {\n  await render(<MyComponent initialData=\"first\" />);\n\n  await screen.rerender(<MyComponent initialData=\"updated\" />);\n  expect(screen.getByText('updated')).toBeOnTheScreen();\n});\n```\n\n### `unmount`\n\n```ts\nfunction unmount(): Promise<void>;\n```\n\nUnmount the in-memory tree, triggering the appropriate lifecycle events.\n\nThis method is async and uses async `act` internally to execute all pending React updates during unmounting. This works with async React features like `Suspense` boundaries and the `use()` hook.\n\n:::note\n\nUsually you should not need to call `unmount` as it is done automatically if your test runner supports `afterEach` hook (like Jest, mocha, Jasmine).\n\n:::\n\n### `debug`\n\n```ts\nfunction debug(options?: { message?: string; mapProps?: MapPropsFunction }): void;\n```\n\nPretty prints deeply rendered component passed to `render`.\n\n#### `message` option {#debug-message-option}\n\nYou can provide a message that will be printed on top.\n\n```jsx\nawait render(<Component />);\nscreen.debug({ message: 'optional message' });\n```\n\nlogs optional message and colored JSX:\n\n```jsx\noptional message\n\n<View\n  onPress={[Function bound fn]}\n>\n  <Text>Press me</Text>\n</View>\n```\n\n#### `mapProps` option {#debug-map-props-option}\n\n```ts\nfunction debug({ mapProps: (props) => ({}) });\n```\n\nYou can use the `mapProps` option to transform the props that will be printed :\n\n```jsx\nawait render(<View style={{ backgroundColor: 'red' }} />);\nscreen.debug({ mapProps: ({ style, ...props }) => ({ props }) });\n```\n\nThis will log the rendered JSX without the `style` props.\n\nThe `children` prop cannot be filtered out so the following will print all rendered components with all props but `children` filtered out.\n\nThis option can be used to target specific props when debugging a query (for instance, keeping only the `children` prop when debugging a `getByText` query).\n\nYou can also transform prop values so that they are more readable (e.g., flatten styles).\n\n```ts\n\n\nscreen.debug({\n  mapProps: ({ style, ...props }) => ({ style: StyleSheet.flatten(style), ...props }),\n});\n```\n\nOr remove props that have little value when debugging tests, e.g. path prop for svgs\n\n```ts\nscreen.debug({ mapProps: ({ path, ...props }) => ({ ...props }) });\n```\n\n### `toJSON`\n\n```ts\nfunction toJSON(): JsonElement | null;\n```\n\nGet the rendered component JSON representation, e.g. for snapshot testing.\n\n### `container`\n\n```ts\nconst container: HostElement;\n```\n\nReturns a pseudo-element container whose children are the elements you asked to render. This is the root container element from [Test Renderer]().\n\nThe `container` provides access to the entire rendered tree. Use it to query or manipulate the rendered output, similar to how `container` works in [React Testing Library]().\n\n```jsx\n\n\ntest('example', async () => {\n  await render(<MyComponent />);\n  // container contains the entire rendered tree\n  const container = screen.container;\n  expect(container).toBeTruthy();\n});\n```\n\n### `root`\n\n```ts\nconst root: HostElement | null;\n```\n\nReturns the rendered root [host element](), or `null` if nothing was rendered. This is the first child of the `container`, which represents the actual root element you rendered.\n\nThis API is useful for component tests where you need to access the root host view without using `*ByTestId` queries or similar methods.\n\n:::note\n\nIn rare cases where your root element is a `React.Fragment` with multiple children, the `container` will have more than one child, and `root` will return only the first one. In such cases, use `container.children` to access all rendered elements.\n\n:::\n\n```jsx\n\n\ntest('example', async () => {\n  await render(\n    <View testID=\"root-view\">\n      <Text>Hello</Text>\n    </View>\n  );\n  // root is the View element you rendered\n  expect(screen.root.props.testID).toBe('root-view');\n});\n```\n","routePath":"/14.x/docs/api/screen","lang":"en","toc":[{"id":"queries","text":"`...queries`","depth":3,"charIndex":595},{"id":"example","text":"Example","depth":4,"charIndex":740},{"id":"rerender","text":"`rerender`","depth":3,"charIndex":904},{"id":"unmount","text":"`unmount`","depth":3,"charIndex":1731},{"id":"debug","text":"`debug`","depth":3,"charIndex":2226},{"id":"debug-message-option","text":"`message` option","depth":4,"charIndex":2394},{"id":"debug-map-props-option","text":"`mapProps` option","depth":4,"charIndex":2727},{"id":"tojson","text":"`toJSON`","depth":3,"charIndex":3785},{"id":"container","text":"`container`","depth":3,"charIndex":3925},{"id":"root","text":"`root`","depth":3,"charIndex":4509}],"frontmatter":{},"version":"14.x","description":"The screen object provides access to queries and utilities for the currently rendered UI. This object is assigned after the render call and cleared after each test by calling cleanup. If no render call has been made in a given test, then it holds a special object and throws a helpful error on each property and method access. ...queries The main feature of screen is its queries for finding elements in the view hierarchy. See Queries for a complete list. Example rerender Re-render the in-memory tree with a new root element. This simulates a React update render at the root. If the new element has the same type (and key) as the previous element, the tree will be updated; otherwise, it will re-mount a new tree, in both cases triggering the appropriate lifecycle events. This method is async and uses async act internally to execute all pending React updates during updating. This works with async React features like Suspense boundaries and the use() hook. unmount Unmount the in-memory tree, triggering the appropriate lifecycle events. This method is async and uses async act internally to execute all pending React updates during unmounting. This works with async React features like Suspense boundaries and the use() hook. :::note Usually you should not need to call unmount as it is done automatically if your test runner supports afterEach hook (like Jest, mocha, Jasmine). ::: debug Pretty prints deeply rendered component passed to render. message option {#debug-message-option} You can provide a message that will be printed on top. logs optional message and colored JSX: mapProps option {#debug-map-props-option} You can use the mapProps option to transform the props that will be printed : This will log the rendered JSX without the style props. The children prop cannot be filtered out so the following will print all rendered components with all props but children filtered out. This option can be used to target specific props when debugging a query (for instance, keeping only the children prop when debugging a getByText query). You can also transform prop values so that they are more readable (e.g., flatten styles). Or remove props that have little value when debugging tests, e.g. path prop for svgs toJSON Get the rendered component JSON representation, e.g. for snapshot testing. container Returns a pseudo-element container whose children are the elements you asked to render. This is the root container element from Test Renderer. The container provides access to the entire rendered tree. Use it to query or manipulate the rendered output, similar to how container works in React Testing Library. root Returns the rendered root host element, or null if nothing was rendered. This is the first child of the container, which represents the actual root element you rendered. This API is useful for component tests where you need to access the root host view without using *ByTestId queries or similar methods. :::note In rare cases where your root element is a React.Fragment with multiple children, the container will have more than one child, and root will return only the first one. In such cases, use container.children to access all rendered elements. :::"},{"title":"Common Mistakes with React Native Testing Library","content":"> **Note:** This guide is adapted from Kent C. Dodds' article [\"Common mistakes with React Testing Library\"]() for React Native Testing Library v14. The original article focuses on web React, but the principles apply to React Native as well. This adaptation includes React Native-specific examples, async API usage (v14), and ARIA-compatible accessibility attributes.\n\nReact Native Testing Library guiding principle is:\n\n> \"The more your tests resemble the way your software is used, the more confidence they can give you.\"\n\nThis guide outlines some common mistakes people make when using React Native Testing Library and how to avoid them.\n\n## Using the wrong query {#using-the-wrong-query}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nReact Native Testing Library provides several query types. Here's the priority order:\n\n1. **Queries that reflect user experience:**\n   - `getByRole` - most accessible\n   - `getByLabelText` - accessible label\n   - `getByPlaceholderText` - `TextInput` placeholder text\n   - `getByText` - text content\n   - `getByDisplayValue` - `TextInput` input value\n\n2. **Semantic queries:**\n   - `getByTestId` - only if nothing else works\n\nHere's an example of using the right query:\n\n```tsx\n\n\n\ntest('finds input by label', async () => {\n  await render(\n    <View>\n      <TextInput aria-label=\"Username\" placeholder=\"Enter username\" value=\"\" />\n    </View>\n  );\n\n  // ✅ Good - uses accessible label\n  const input = screen.getByLabelText('Username');\n\n  // ✅ Also good - uses placeholder\n  const inputByPlaceholder = screen.getByPlaceholderText('Enter username');\n\n  // ❌ Bad - uses testID when accessible queries work\n  // const input = screen.getByTestId('username-input');\n});\n```\n\n## Not using `*ByRole` query most of the time {#not-using-byrole-most-of-the-time}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\n`getByRole` is the most accessible query and should be your first choice. It queries elements by their semantic role:\n\n```tsx\n\n\n\ntest('uses role queries', async () => {\n  await render(\n    <View>\n      <Pressable role=\"button\">\n        <Text>Submit</Text>\n      </Pressable>\n      <TextInput role=\"searchbox\" aria-label=\"Search\" placeholder=\"Search...\" />\n    </View>\n  );\n\n  // ✅ Good - uses role query\n  const button = screen.getByRole('button', { name: 'Submit' });\n  const searchbox = screen.getByRole('searchbox', { name: 'Search' });\n\n  expect(button).toBeOnTheScreen();\n  expect(searchbox).toBeOnTheScreen();\n});\n```\n\nCommon roles in React Native include:\n\n- `button` - pressable elements\n- `text` - static text\n- `header` / `heading` - headers\n- `searchbox` - search inputs\n- `switch` - toggle switches\n- `checkbox` - checkboxes\n- `radio` - radio buttons\n- And more...\n\nNote: React Native supports both ARIA-compatible (`role`) and legacy (`accessibilityRole`) props. Prefer `role` for consistency with web standards.\n\n## Using the wrong assertion {#using-the-wrong-assertion}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nReact Native Testing Library provides built-in Jest matchers. Make sure you're using the right ones:\n\n```tsx\n\n\n\ntest('button is disabled', async () => {\n  await render(\n    <Pressable role=\"button\" aria-disabled>\n      <Text>Submit</Text>\n    </Pressable>\n  );\n\n  const button = screen.getByRole('button', { name: 'Submit' });\n\n  // ✅ Good - uses RNTL matcher\n  expect(button).toBeDisabled();\n\n  // ❌ Bad - doesn't use RNTL matcher\n  expect(button.props['aria-disabled']).toBe(true);\n});\n```\n\nCommon matchers include:\n\n- `toBeOnTheScreen()` - checks if element is rendered (replaces `toBeInTheDocument()`)\n- `toBeDisabled()` - checks if element is disabled\n- `toHaveTextContent()` - checks text content\n- `toHaveAccessibleName()` - checks accessible name\n- And more...\n\n## Using `query*` variants for anything except checking for non-existence {#using-query-variants-for-anything-except-checking-for-non-existence}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nUse `queryBy*` only when checking that an element doesn't exist:\n\n```tsx\n\n\n\ntest('checks non-existence', async () => {\n  await render(\n    <View>\n      <Text>Hello</Text>\n    </View>\n  );\n\n  // ✅ Good - uses queryBy for non-existence check\n  expect(screen.queryByText('Goodbye')).not.toBeOnTheScreen();\n\n  // ❌ Bad - uses queryBy when element should exist\n  // const element = screen.queryByText('Hello');\n  // expect(element).toBeOnTheScreen();\n\n  // ✅ Good - uses getBy when element should exist\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n```\n\n## Using `waitFor` to wait for elements that can be queried with `find*` {#using-waitfor-to-wait-for-elements-that-can-be-queried-with-find}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nUse `findBy*` queries instead of `waitFor` + `getBy*`:\n\n```tsx\n\n\n\ntest('waits for element', async () => {\n  const Component = () => {\n    const [show, setShow] = React.useState(false);\n\n    React.useEffect(() => {\n      setTimeout(() => setShow(true), 100);\n    }, []);\n\n    return <View>{show && <Text>Loaded</Text>}</View>;\n  };\n\n  await render(<Component />);\n\n  // ✅ Good - uses findBy query\n  const element = await screen.findByText('Loaded');\n  expect(element).toBeOnTheScreen();\n\n  // ❌ Bad - uses waitFor + getBy\n  // await waitFor(() => {\n  //   expect(screen.getByText('Loaded')).toBeOnTheScreen();\n  // });\n});\n```\n\n## Performing side-effects in `waitFor` {#performing-side-effects-in-waitfor}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nDon't perform side-effects in `waitFor` callbacks:\n\n```tsx\n\n\n\ntest('avoids side effects in waitFor', async () => {\n  const Component = () => {\n    const [count, setCount] = React.useState(0);\n    return (\n      <View>\n        <Pressable role=\"button\" onPress={() => setCount(count + 1)}>\n          <Text>Increment</Text>\n        </Pressable>\n        <Text>Count: {count}</Text>\n      </View>\n    );\n  };\n\n  await render(<Component />);\n\n  const button = screen.getByRole('button');\n\n  // ❌ Bad - side effect in waitFor\n  // await waitFor(async () => {\n  //   await fireEvent.press(button);\n  //   expect(screen.getByText('Count: 1')).toBeOnTheScreen();\n  // });\n\n  // ✅ Good - side effect outside waitFor\n  await fireEvent.press(button);\n  await waitFor(() => {\n    expect(screen.getByText('Count: 1')).toBeOnTheScreen();\n  });\n});\n```\n\n## Using `container` to query for elements {#using-container-to-query-for-elements}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nReact Native Testing Library provides a `container` object that has a `queryAll` method, but you should avoid using it directly:\n\n```tsx\n\n\n\ntest('finds element incorrectly', async () => {\n  const { container } = await render(\n    <View>\n      <Text testID=\"message\">Hello</Text>\n    </View>\n  );\n\n  // ❌ Bad - using container.queryAll directly\n  const element = container.queryAll((node) => node.props.testID === 'message')[0];\n\n  // ✅ Good - use proper queries\n  // const element = screen.getByTestId('message');\n});\n```\n\nInstead, use the proper query methods from `screen` or the `render` result. The `container` is a low-level API that you rarely need.\n\n## Passing an empty callback to `waitFor` {#passing-an-empty-callback-to-waitfor}\n\n\\<span style={{ color: '#a94442', fontWeight: 'bold' }}>Importance: high</span>\n\nDon't pass an empty callback to `waitFor`:\n\n```tsx\n\n\n\ntest('waits correctly', async () => {\n  await render(<View testID=\"test\" />);\n\n  // ❌ Bad - empty callback\n  // await waitFor(() => {});\n\n  // ✅ Good - meaningful assertion\n  await waitFor(() => {\n    expect(screen.getByTestId('test')).toBeOnTheScreen();\n  });\n});\n```\n\n## Not using `screen` {#not-using-screen}\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\nYou can get all the queries from the `render` result:\n\n```tsx\n\n\n\ntest('renders component', async () => {\n  const { getByText } = await render(\n    <View>\n      <Text>Hello</Text>\n    </View>\n  );\n\n  expect(getByText('Hello')).toBeOnTheScreen();\n});\n```\n\nBut you can also get them from the `screen` object:\n\n```tsx\n\n\n\ntest('renders component', async () => {\n  await render(\n    <View>\n      <Text>Hello</Text>\n    </View>\n  );\n\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n```\n\nUsing `screen` has several benefits:\n\n1. You don't need to destructure `getByText` from `render`\n2. It's more consistent with the Testing Library ecosystem\n\n## Wrapping things in `act` unnecessarily {#wrapping-things-in-act-unnecessarily}\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\nReact Native Testing Library's `render`, `renderHook`, `userEvent`, and `fireEvent` are already wrapped in `act`, so you don't need to wrap them yourself:\n\n```tsx\n\n\n\ntest('updates on press', async () => {\n  const Component = () => {\n    const [count, setCount] = React.useState(0);\n    return (\n      <View>\n        <Pressable role=\"button\" onPress={() => setCount(count + 1)}>\n          <Text>Count: {count}</Text>\n        </Pressable>\n      </View>\n    );\n  };\n\n  await render(<Component />);\n\n  const button = screen.getByRole('button');\n\n  // ✅ Good - fireEvent is already wrapped in act\n  await fireEvent.press(button);\n\n  expect(screen.getByText('Count: 1')).toBeOnTheScreen();\n\n  // ❌ Bad - unnecessary act wrapper\n  // await act(async () => {\n  //   await fireEvent.press(button);\n  // });\n});\n```\n\n## Not using User Event API\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\n`userEvent` provides a more realistic way to simulate user interactions:\n\n```tsx\n\n\n\ntest('uses userEvent', async () => {\n  const user = userEvent.setup();\n\n  const Component = () => {\n    const [value, setValue] = React.useState('');\n    return (\n      <View>\n        <TextInput aria-label=\"Name\" value={value} onChangeText={setValue} />\n        <Pressable role=\"button\" onPress={() => setValue('')}>\n          <Text>Clear</Text>\n        </Pressable>\n      </View>\n    );\n  };\n\n  await render(<Component />);\n\n  const input = screen.getByLabelText('Name');\n  const button = screen.getByRole('button', { name: 'Clear' });\n\n  // ✅ Good - uses userEvent for realistic interactions\n  await user.type(input, 'John');\n  expect(input).toHaveValue('John');\n\n  await user.press(button);\n  expect(input).toHaveValue('');\n});\n```\n\n`userEvent` methods are async and must be awaited. Available methods include:\n\n- `press()` - simulates a press\n- `longPress()` - simulates long press\n- `type()` - simulates typing\n- `clear()` - clears text input\n- `paste()` - simulates pasting\n- `scrollTo()` - simulates scrolling\n\n## Not querying by text {#not-querying-by-text}\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\nIn React Native, text is rendered in `<Text>` components. You should query by the text content that users see:\n\n```tsx\n\n\n\ntest('finds text correctly', async () => {\n  await render(\n    <View>\n      <Text>Hello World</Text>\n    </View>\n  );\n\n  // ✅ Good - queries by visible text\n  expect(screen.getByText('Hello World')).toBeOnTheScreen();\n\n  // ❌ Bad - queries by testID when text is available\n  // expect(screen.getByTestId('greeting')).toBeOnTheScreen();\n});\n```\n\n## Not using Testing Library ESLint plugins {#not-using-testing-library-eslint-plugins}\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\nThere's an ESLint plugin for Testing Library: [`eslint-plugin-testing-library`](). This plugin can help you avoid common mistakes and will automatically fix your code in many cases.\n\nYou can install it with:\n\n```bash\nyarn add --dev eslint-plugin-testing-library\n```\n\nAnd configure it in your `eslint.config.js` (flat config):\n\n```js\n\n\nexport default [testingLibrary.configs['flat/react']];\n```\n\nNote: Unlike React Testing Library, React Native Testing Library has built-in Jest matchers, so you don't need `eslint-plugin-jest-dom`.\n\n## Using `cleanup` {#using-cleanup}\n\n\\<span style={{ color: '#8a6d3b', fontWeight: 'bold' }}>Importance: medium</span>\n\nReact Native Testing Library automatically cleans up after each test. You don't need to call `cleanup()` manually unless you're using the `pure` export (which doesn't include automatic cleanup).\n\nIf you want to disable automatic cleanup for a specific test, you can use:\n\n```tsx\n\n\ntest('does not cleanup', async () => {\n  // This test won't cleanup automatically\n  await render(<MyComponent />);\n  // ... your test\n});\n```\n\nBut in most cases, you don't need to worry about cleanup at all - it's handled automatically.\n\n## Using `get*` variants as assertions {#using-get-variants-as-assertions}\n\n\\<span style={{ color: '#3c763d', fontWeight: 'bold' }}>Importance: low</span>\n\n`getBy*` queries throw errors when elements aren't found, so they work as assertions. However, for better error messages, you might want to combine them with explicit matchers:\n\n```tsx\n\n\n\ntest('uses getBy as assertion', async () => {\n  await render(\n    <View>\n      <Text>Hello</Text>\n    </View>\n  );\n\n  // ✅ Good - getBy throws if not found, so it's an assertion\n  const element = screen.getByText('Hello');\n  expect(element).toBeOnTheScreen();\n\n  // ✅ Also good - more explicit\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n\n  // ❌ Bad - redundant assertion\n  // const element = screen.getByText('Hello');\n  // expect(element).not.toBeNull(); // getBy already throws if null\n});\n```\n\n## Having multiple assertions in a single `waitFor` callback {#having-multiple-assertions-in-a-single-waitfor-callback}\n\n\\<span style={{ color: '#3c763d', fontWeight: 'bold' }}>Importance: low</span>\n\nKeep `waitFor` callbacks focused on a single assertion:\n\n```tsx\n\n\n\ntest('waits with single assertion', async () => {\n  const Component = () => {\n    const [count, setCount] = React.useState(0);\n\n    React.useEffect(() => {\n      setTimeout(() => setCount(1), 100);\n    }, []);\n\n    return (\n      <View>\n        <Text>Count: {count}</Text>\n      </View>\n    );\n  };\n\n  await render(<Component />);\n\n  // ✅ Good - single assertion per waitFor\n  await waitFor(() => {\n    expect(screen.getByText('Count: 1')).toBeOnTheScreen();\n  });\n\n  // If you need multiple assertions, do them after waitFor\n  expect(screen.getByText('Count: 1')).toHaveTextContent('Count: 1');\n\n  // ❌ Bad - multiple assertions in waitFor\n  // await waitFor(() => {\n  //   expect(screen.getByText('Count: 1')).toBeOnTheScreen();\n  //   expect(screen.getByText('Count: 1')).toHaveTextContent('Count: 1');\n  // });\n});\n```\n\n## Using `wrapper` as the variable name {#using-wrapper-as-the-variable-name}\n\n\\<span style={{ color: '#3c763d', fontWeight: 'bold' }}>Importance: low</span>\n\nThis is not really a \"mistake\" per se, but it's a common pattern that can be improved. When you use the `wrapper` option in `render`, you might be tempted to name your wrapper component `Wrapper`:\n\n```tsx\n\n\n\ntest('renders with wrapper', async () => {\n  const Wrapper = ({ children }: { children: React.ReactNode }) => (\n    <View testID=\"wrapper\">{children}</View>\n  );\n\n  await render(<View testID=\"content\">Content</View>, {\n    wrapper: Wrapper,\n  });\n\n  expect(screen.getByTestId('content')).toBeOnTheScreen();\n});\n```\n\nThis works fine, but it's more conventional to name it something more descriptive like `ThemeProvider` or `AllTheProviders` (if you're wrapping with multiple providers). This makes it clearer what the wrapper is doing.\n\n## Summary\n\nThe key principles to remember:\n\n1. **Use the right query** - Prefer `getByRole` as your first choice, use `findBy*` for async elements, and `queryBy*` only for checking non-existence\n2. **Use proper assertions** - Use RNTL's built-in matchers (`toBeOnTheScreen()`, `toBeDisabled()`, etc.) instead of asserting on props directly\n3. **Handle async operations correctly** - Always `await` `render()`, `renderHook`, `fireEvent`,and `userEvent` methods\n4. **Use `waitFor` correctly** - Avoid side-effects in callbacks, use `findBy*` instead when possible, and keep callbacks focused\n5. **Follow accessibility best practices** - Prefer ARIA attributes (`role`, `aria-label`) over `accessibility*` props\n6. **Organize code well** - Use `screen` over destructuring, prefer `userEvent` over `fireEvent`, and don't use `cleanup()`\n\nBy following these principles, your tests will be more maintainable, accessible, and reliable.\n","routePath":"/14.x/docs/guides/common-mistakes","lang":"en","toc":[{"id":"using-the-wrong-query","text":"Using the wrong query","depth":2,"charIndex":642},{"id":"not-using-byrole-most-of-the-time","text":"Not using `*ByRole` query most of the time","depth":2,"charIndex":1743},{"id":"using-the-wrong-assertion","text":"Using the wrong assertion","depth":2,"charIndex":2935},{"id":"using-query-variants-for-anything-except-checking-for-non-existence","text":"Using `query*` variants for anything except checking for non-existence","depth":2,"charIndex":3845},{"id":"using-waitfor-to-wait-for-elements-that-can-be-queried-with-find","text":"Using `waitFor` to wait for elements that can be queried with `find*`","depth":2,"charIndex":4634},{"id":"performing-side-effects-in-waitfor","text":"Performing side-effects in `waitFor`","depth":2,"charIndex":5484},{"id":"using-container-to-query-for-elements","text":"Using `container` to query for elements","depth":2,"charIndex":6481},{"id":"passing-an-empty-callback-to-waitfor","text":"Passing an empty callback to `waitFor`","depth":2,"charIndex":7304},{"id":"not-using-screen","text":"Not using `screen`","depth":2,"charIndex":7792},{"id":"wrapping-things-in-act-unnecessarily","text":"Wrapping things in `act` unnecessarily","depth":2,"charIndex":8566},{"id":"not-using-user-event-api","text":"Not using User Event API","depth":2,"charIndex":9539},{"id":"not-querying-by-text","text":"Not querying by text","depth":2,"charIndex":10753},{"id":"not-using-testing-library-eslint-plugins","text":"Not using Testing Library ESLint plugins","depth":2,"charIndex":11352},{"id":"using-cleanup","text":"Using `cleanup`","depth":2,"charIndex":12057},{"id":"using-get-variants-as-assertions","text":"Using `get*` variants as assertions","depth":2,"charIndex":12696},{"id":"having-multiple-assertions-in-a-single-waitfor-callback","text":"Having multiple assertions in a single `waitFor` callback","depth":2,"charIndex":13549},{"id":"using-wrapper-as-the-variable-name","text":"Using `wrapper` as the variable name","depth":2,"charIndex":14641},{"id":"summary","text":"Summary","depth":2,"charIndex":15544}],"frontmatter":{},"version":"14.x","description":"Note: This guide is adapted from Kent C. Dodds' article \"Common mistakes with React Testing Library\" for React Native Testing Library v14. The original article focuses on web React, but the principles apply to React Native as well. This adaptation includes React Native-specific examples, async API usage (v14), and ARIA-compatible accessibility attributes. React Native Testing Library guiding principle is: \"The more your tests resemble the way your software is used, the more confidence they can give you.\" This guide outlines some common mistakes people make when using React Native Testing Library and how to avoid them."},{"title":"Community resources","content":"## Recommended content\n\n- [The Testing Trophy and Testing Classifications]() by Kent C. Dodds (2021) - classic article explaining testing philosophy behind all Testing Library implementations.\n- [Common mistakes with React Testing Library]() by Kent C. Dodds (2020) - classic article explaining React Testing Library best practices, highly applicable to RNTL as well.\n- [React Native — UI Testing (Ultimate Guide)]() by Anisur Rahman - comprehensive guide to RNTL testing\n- [React Native Testing examples repo]() by Steve Galili - extensive repo with RN testing examples for RNTL and Maestro\n\n## Older, potentially outdated content\n\n- [Where and how to start testing 🧪 your react-native app ⚛️ and how to keep on testin’]() by Steve Galili (2020) - article referencing Steve's examples repo.\n- [Intro to React Native Testing Library & Jest Native]() by Alireza Ghamkhar (2020) - video tutorial on RNTL setup and testing.\n","routePath":"/14.x/docs/guides/community-resources","lang":"en","toc":[{"id":"recommended-content","text":"Recommended content","depth":2,"charIndex":0},{"id":"older-potentially-outdated-content","text":"Older, potentially outdated content","depth":2,"charIndex":593}],"frontmatter":{},"version":"14.x"},{"title":"FAQ","content":"## Can I test the native features of React Native apps?\n\nShort answer: no.\n\nReact Native Testing Library does not provide an entire React Native runtime since that would require running on a physical device\nor iOS simulator/Android emulator to provision the underlying OS and platform APIs.\n\nInstead of using React Native renderer, it simulates only the JavaScript part of its runtime\nusing [Test Renderer]() while providing queries\nand event APIs ([User Event](), [Fire Event]()) that mimicking certain behaviors from the actual runtime.\n\nYou can learn more about our testing environment [here]().\n\nThis approach has benefits and limitations:\n\nBenefits:\n\n- Tests most of the logic of regular React Native apps\n- Runs tests on any OS supported by Jest or other test runners, e.g., on CI\n- Uses fewer resources than full runtime simulation\n- Works with Jest fake timers\n\nLimitations:\n\n- Cannot test native features\n- May not perfectly simulate certain JavaScript features, but we're working on it\n\nThe [User Event interactions]() solve some simulation issues by handling events more realistically than the basic [Fire Event API]().\n\n## Should I use/migrate to `screen` queries?\n\nThere is no need to migrate existing test code to use `screen`-bases queries. You can still use\nqueries and other functions returned by `render`. The `screen` object captures the latest `render` result.\n\nFor new code, use `screen`. [This article]() by Kent C. Dodds explains why.\n\n## Should I use/migrate to User Event interactions?\n\nMigrate existing tests to use the [User Event interactions](), which handle events more realistically than the basic [Fire Event API](). This provides more confidence in your code quality.\n","routePath":"/14.x/docs/guides/faq","lang":"en","toc":[{"id":"can-i-test-the-native-features-of-react-native-apps","text":"Can I test the native features of React Native apps?","depth":2,"charIndex":0},{"id":"should-i-usemigrate-to-screen-queries","text":"Should I use/migrate to `screen` queries?","depth":2,"charIndex":1132},{"id":"should-i-usemigrate-to-user-event-interactions","text":"Should I use/migrate to User Event interactions?","depth":2,"charIndex":1459}],"frontmatter":{},"version":"14.x"},{"title":"How should I query?","content":"React Native Testing Library provides various query types for finding views in tests. The number of queries can be confusing. This guide helps you pick the right queries for your test scenarios.\n\n## Query parts\n\nEach query is composed of two parts: variant and predicate, which are separated by the `by` word in the middle of the query.\n\nConsider the following query:\n\n```ts\ngetByRole();\n```\n\nFor this query, `getBy*` is the query variant, and `*ByRole` is the predicate.\n\n## Query variant\n\nThe query variants describe the expected number (and timing) of matching elements, so they differ in their return type.\n\n| Variant           | Assertion                     | Return type                      | Is Async? |\n| ----------------- | ----------------------------- | -------------------------------- | --------- |\n| [`getBy*`]()      | Exactly one matching element  | `HostElement`                    | No        |\n| [`getAllBy*`]()   | At least one matching element | `Array<HostElement>`             | No        |\n| [`queryBy*`]()    | Zero or one matching element  | <code>HostElement \\| null</code> | No        |\n| [`queryAllBy*`]() | No assertion                  | `Array<HostElement>`             | No        |\n| [`findBy*`]()     | Exactly one matching element  | `Promise<HostElement>`           | Yes       |\n| [`findAllBy*`]()  | At least one matching element | `Promise<Array<HostElement>>`    | Yes       |\n\nQueries work as implicit assertions on the number of matching elements and will throw an error when the assertion fails.\n\n### Idiomatic query variants\n\nIdiomatic query variants clarify test intent and the expected number of matching elements. They will also throw helpful errors if assertions fail to help diagnose the issues.\n\nHere are general guidelines for picking idiomatic query variants:\n\n1. Use `getBy*` in the most common case when you expect a **single matching element**. Use other queries only in more specific cases.\n2. Use `findBy*` when an element is not yet in the element tree, but you expect it to be there as a **result of some asynchronous action**.\n3. Use `getAllBy*` (and `findAllBy*` for async) if you expect **more than one matching element**, e.g. in a list.\n4. Use `queryBy*` only when element **should not exist** to use it together with e.g. [`not.toBeOnTheScreen()`]() matcher.\n\nAvoid using `queryAllBy*` in regular tests, as it provides no assertions on the number of matching elements. You may still find it useful when building reusable custom testing tools.\n\n## Query predicate\n\nThe query predicate describes how you decide whether to match the given element.\n\n| Predicate                | Supported elements | Inspected props                                                                                                   |\n| ------------------------ | ------------------ | ----------------------------------------------------------------------------------------------------------------- |\n| [`*ByRole`]()            | all host elements  | `role`, `accessibilityRole`,<br /> optional: accessible name, accessibility state and value                       |\n| [`*ByLabelText`]()       | all host elements  | `aria-label`, `aria-labelledby`,<br /> `accessibilityLabel`, `accessibilityLabelledBy`,<br /> `alt` (for `Image`) |\n| [`*ByDisplayValue`]()    | `TextInput`        | `value`, `defaultValue`                                                                                           |\n| [`*ByPlaceholderText`]() | `TextInput`        | `placeholder`                                                                                                     |\n| [`*ByText`]()            | `Text`             | `children` (text content)                                                                                         |\n| [`*ByHintText`]()        | all host elements  | `accessibilityHint`                                                                                               |\n| [`*ByTestId`]()          | all host elements  | `testID`                                                                                                          |\n\n### Idiomatic query predicates\n\nChoosing the right query predicate helps express test intent and makes tests resemble how users interact with your code (components, screens, etc.), following our [Guiding Principles](). Most predicates also promote proper accessibility props, which add a semantic layer on top of an element tree composed primarily of [`View`]() elements.\n\nUse query predicates in the following order of priority:\n\n### 1. By Role query {#by-role-query}\n\nThe [`*ByRole`]() predicate starts with the semantic role of the element and can be narrowed down with additional options. React Native has two role systems: the web/ARIA-compatible one based on [`role`]() prop and the traditional one based on [`accessibilityRole`]() prop. You can use either.\n\nIn most cases, you need to set accessibility roles explicitly (or your component library can set some of them for you). These roles allow assistive technologies (like screen readers) and testing code to understand your view hierarchy better.\n\nSome frequently used roles include:\n\n- `alert` - important text to be presented to the user, e.g., error message\n- `button`\n- `checkbox` & `switch` - on/off controls\n- `heading` (`header`) - header for content section, e.g., the title of navigation bar\n- `img` (`image`)\n- `link`\n- `menu` & `menuitem`\n- `progressbar`\n- `radiogroup` & `radio`\n- `searchbox` (`search`)\n- `slider` (`adjustable`)\n- `summary`\n- `tablist` & `tab`\n- `text` - static text that cannot change\n- `toolbar` - container for action buttons\n\n#### Name option {#by-role-query-name-option}\n\nFrequently, you will want to add the [`name`]() option, which will match both the element's role and its accessible name (= element's accessibility label or text content).\n\nHere are a couple of examples:\n\n- start button: `getByRole(\"button\", { name: \"Start\" })`\n- silent mode switch: `getByRole(\"switch\", { name: \"Silent Mode\" })`\n- screen header: `getByRole(\"header\", { name: \"Settings\" })`\n- undo menu item: `getByRole(\"menuitem\", { name: \"Undo\" })`\n- error messages: `getByRole(\"alert\", { name: /Not logged in/ })`\n\n### 2. Text input queries {#text-input-queries}\n\nQuerying [`TextInput`]() elements presents a unique challenge as there is no separate role for `TextInput` elements. There is a `searchbox`/`search` role, which can be assigned to `TextInput`, but it should be only used in the context of search inputs, leaving other text inputs without a role to query with.\n\nTherefore, you can use the following queries to find relevant text inputs:\n\n1. [`*ByLabelText`]() - will match the accessibility label of the element. This query will match any host elements, including `TextInput` elements.\n2. [`*ByPlaceholderText`]() - will match the placeholder of `TextInput` element. This query will match only `TextInput` elements.\n3. [`*ByDisplayValue`]() - will the current (or default) value of `TextInput` element. This query will match only `TextInput` elements.\n\n### 3. Other accessible queries {#other-accessible-queries}\n\nThese queries reflect the apps' user experience, both visual and through assistive technologies (e.g. screen reader).\n\nThese queries include:\n\n- [`*ByText`]() - will match the text content of the element. This query will match only `Text` elements.\n- [`*ByLabelText`]() - will match the accessibility label of the element.\n- [`*ByHintText`]() - will match the accessibility hint of the element.\n\n### 4. Test ID query {#test-id-query}\n\nAs a final predicate, you can use the `testID` prop to find relevant views. Using the [`*ByTestId`]() predicate offers the most flexibility, but at the same time, it does not represent the user experience, as users are not aware of test IDs.\n\nNote that using test IDs is common in end-to-end testing due to various issues with querying views through other means **in that specific context**. For integration and component tests, use the recommended RNTL queries to make tests more reliable and resilient.\n","routePath":"/14.x/docs/guides/how-to-query","lang":"en","toc":[{"id":"query-parts","text":"Query parts","depth":2,"charIndex":196},{"id":"query-variant","text":"Query variant","depth":2,"charIndex":473},{"id":"idiomatic-query-variants","text":"Idiomatic query variants","depth":3,"charIndex":1543},{"id":"query-predicate","text":"Query predicate","depth":2,"charIndex":2512},{"id":"idiomatic-query-predicates","text":"Idiomatic query predicates","depth":3,"charIndex":4109},{"id":"by-role-query","text":"1. By Role query","depth":3,"charIndex":4540},{"id":"by-role-query-name-option","text":"Name option","depth":4,"charIndex":5629},{"id":"text-input-queries","text":"2. Text input queries","depth":3,"charIndex":6195},{"id":"other-accessible-queries","text":"3. Other accessible queries","depth":3,"charIndex":7045},{"id":"test-id-query","text":"4. Test ID query","depth":3,"charIndex":7502}],"frontmatter":{},"version":"14.x","description":"React Native Testing Library provides various query types for finding views in tests. The number of queries can be confusing. This guide helps you pick the right queries for your test scenarios."},{"title":"LLM Guidelines for React Native Testing Library","content":"Actionable guidelines for writing tests with React Native Testing Library (RNTL) v14.\n\n## Core APIs\n\n### render\n\n```tsx\nconst result = await render(<Component />, options?);\n```\n\n| Option           | Description                                                      |\n| ---------------- | ---------------------------------------------------------------- |\n| `wrapper`        | React component to wrap the rendered component (e.g., providers) |\n| `createNodeMock` | Function to create mock refs                                     |\n\n| Return                | Description                                      |\n| --------------------- | ------------------------------------------------ |\n| `rerender(component)` | Re-render with a new component (async)           |\n| `unmount()`           | Unmount the rendered component (async)           |\n| `toJSON()`            | Get JSON representation for snapshots            |\n| `debug(options?)`     | Print the component tree to console              |\n| `container`           | Root host element of the rendered tree           |\n| `root`                | First child host element (your component's root) |\n\n### screen\n\n**Prefer `screen`** over destructuring from `render()`. Provides all query methods after `render()` is called.\n\n```tsx\nawait render(<Component />);\nscreen.getByRole('button'); // Access queries via screen\n```\n\n### renderHook\n\n```tsx\nconst { result, rerender, unmount } = await renderHook(() => useMyHook(), options?);\n```\n\n| Option         | Description                                        |\n| -------------- | -------------------------------------------------- |\n| `initialProps` | Initial props passed to the hook                   |\n| `wrapper`      | React component to wrap the hook (e.g., providers) |\n\n| Return             | Description                           |\n| ------------------ | ------------------------------------- |\n| `result.current`   | Current return value of the hook      |\n| `rerender(props?)` | Re-render hook with new props (async) |\n| `unmount()`        | Unmount the hook (async)              |\n\n## Query Selection\n\n- **Prefer `getByRole`** as first choice for querying elements\n- **Query priority**: `getByRole` → `getByLabelText` → `getByPlaceholderText` → `getByText` → `getByDisplayValue` → `getByTestId` (last resort)\n- **Use `findBy*`** for elements that appear asynchronously (after API calls, timeouts, state updates)\n- **Use `queryBy*` ONLY** for checking non-existence (with `.not.toBeOnTheScreen()`)\n- **Never use `getBy*`** for non-existence checks\n- **Avoid `container.queryAll()`** - use `screen` queries instead\n- **Query by visible text**, not `testID` when text is available\n\n## Assertions\n\n- **Use RNTL matchers** - prefer semantic matchers over prop assertions\n- **Combine queries with matchers**: `expect(screen.getByText('Hello')).toBeOnTheScreen()`\n- **No redundant null checks** - `getBy*` already throws if not found\n\n## Jest Matchers Reference\n\n| Matcher                           | Description                                                                                 |\n| --------------------------------- | ------------------------------------------------------------------------------------------- |\n| `toBeOnTheScreen()`               | Element is present in the element tree                                                      |\n| `toBeVisible()`                   | Element is visible (checks style, `aria-hidden`, `accessibilityElementsHidden`, ancestors)  |\n| `toBeEmptyElement()`              | Element has no children or text content                                                     |\n| `toContainElement(element)`       | Element contains another element                                                            |\n| `toBeEnabled()`                   | Element is not disabled (checks `aria-disabled`, `accessibilityState`, ancestors)           |\n| `toBeDisabled()`                  | Element has `aria-disabled` or `accessibilityState={{ disabled: true }}` (checks ancestors) |\n| `toBeBusy()`                      | Element has `aria-busy` or `accessibilityState={{ busy: true }}`                            |\n| `toBeChecked()`                   | Element has `aria-checked` or `accessibilityState={{ checked: true }}`                      |\n| `toBePartiallyChecked()`          | Element has `aria-checked=\"mixed\"` or `accessibilityState={{ checked: 'mixed' }}`           |\n| `toBeSelected()`                  | Element has `aria-selected` or `accessibilityState={{ selected: true }}`                    |\n| `toBeExpanded()`                  | Element has `aria-expanded` or `accessibilityState={{ expanded: true }}`                    |\n| `toBeCollapsed()`                 | Element has `aria-expanded={false}` or `accessibilityState={{ expanded: false }}`           |\n| `toHaveTextContent(text)`         | Element has matching text content                                                           |\n| `toHaveDisplayValue(value)`       | TextInput has matching display value                                                        |\n| `toHaveAccessibleName(name?)`     | Element has matching `aria-label`, `accessibilityLabel`, or text content                    |\n| `toHaveAccessibilityValue(value)` | Element has matching `aria-value*` or `accessibilityValue`                                  |\n| `toHaveStyle(style)`              | Element has matching style                                                                  |\n| `toHaveProp(name, value?)`        | Element has prop (use semantic matchers when possible)                                      |\n\n## User Interactions\n\n**Prefer `userEvent`** over `fireEvent` for realistic user interaction simulation. `userEvent` triggers the complete event sequence that real users would produce.\n\n### userEvent (Preferred)\n\n```tsx\nconst user = userEvent.setup();\n```\n\n| Method                               | Description                                                                         |\n| ------------------------------------ | ----------------------------------------------------------------------------------- |\n| `user.press(element)`                | Press an element (triggers `pressIn`, `pressOut`, `press`)                          |\n| `user.longPress(element, options?)`  | Long press with optional `{ duration }`                                             |\n| `user.type(element, text, options?)` | Type into TextInput (triggers `focus`, `keyPress`, `change`, `changeText` per char) |\n| `user.clear(element)`                | Clear TextInput (select all + backspace)                                            |\n| `user.paste(element, text)`          | Paste text into TextInput                                                           |\n| `user.scrollTo(element, options)`    | Scroll a ScrollView with `{ y }` or `{ x }` offset                                  |\n\n### fireEvent (Low-level)\n\nUse only when `userEvent` doesn't support the event or when you need direct control.\n\n| Method                                   | Description                                   |\n| ---------------------------------------- | --------------------------------------------- |\n| `fireEvent(element, eventName, ...data)` | Fire any event by name                        |\n| `fireEvent.press(element)`               | Fire `onPress` only (no `pressIn`/`pressOut`) |\n| `fireEvent.changeText(element, text)`    | Fire `onChangeText` directly                  |\n| `fireEvent.scroll(element, eventData)`   | Fire `onScroll` with event data               |\n\n## Async/Await (v14)\n\n- **Always `await`**: `render()`, `fireEvent.*`, `renderHook()`, `userEvent.*`\n- **Make test functions `async`**: `test('name', async () => { ... })`\n- **Don't wrap in `act()`** - `render` and `fireEvent` handle it internally\n\n## waitFor Usage\n\n- **Use `findBy*`** instead of `waitFor` + `getBy*` when waiting for elements\n- **Never perform side-effects** (like `fireEvent.press()`) inside `waitFor` callbacks\n- **One assertion per `waitFor`** callback\n- **Never pass empty callbacks** - always include a meaningful assertion\n- **Place side-effects before `waitFor`** - perform actions, then wait for result\n\n## Code Organization\n\n- **Use `screen`** instead of destructuring from `render()`: `screen.getByText()` not `const { getByText } = render()`\n- **Prefer `userEvent`** over `fireEvent` for realistic interactions\n- **Don't use `cleanup()`** - handled automatically\n- **Name wrappers descriptively**: `ThemeProvider` not `Wrapper`\n- **Install ESLint plugin**: `eslint-plugin-testing-library`\n\n## Quick Checklist\n\n- ✅ Using `getByRole` as first choice?\n- ✅ Using `await` for all async operations?\n- ✅ Using `findBy*` for async elements (not `waitFor` + `getBy*`)?\n- ✅ Using `queryBy*` only for non-existence?\n- ✅ Using RNTL matchers (`toBeOnTheScreen()`, `toBeDisabled()`, etc.)?\n- ✅ Using `screen` not destructuring from `render()`?\n- ✅ Avoiding side-effects in `waitFor`?\n- ✅ Using `userEvent` when appropriate?\n\n## Example: Good Pattern\n\n```tsx\n\n\n\n\ntest('user can submit form', async () => {\n  const user = userEvent.setup();\n\n  const Component = () => {\n    const [name, setName] = React.useState('');\n    const [submitted, setSubmitted] = React.useState(false);\n\n    return (\n      <View>\n        <TextInput role=\"textbox\" aria-label=\"Name\" value={name} onChangeText={setName} />\n        <Pressable role=\"button\" aria-label=\"Submit\" onPress={() => setSubmitted(true)}>\n          <Text>Submit</Text>\n        </Pressable>\n        {submitted && <Text role=\"alert\">Form submitted!</Text>}\n      </View>\n    );\n  };\n\n  await render(<Component />);\n\n  // ✅ getByRole as first choice\n  const input = screen.getByRole('textbox', { name: 'Name' });\n  const button = screen.getByRole('button', { name: 'Submit' });\n\n  // ✅ userEvent for realistic interactions\n  await user.type(input, 'John Doe');\n  await user.press(button);\n\n  // ✅ findBy* for async elements\n  const successMessage = await screen.findByRole('alert');\n\n  // ✅ RNTL matchers\n  expect(successMessage).toBeOnTheScreen();\n  expect(successMessage).toHaveTextContent('Form submitted!');\n});\n```\n\n## Example: Anti-Patterns\n\n```tsx\n// ❌ Missing await\ntest('bad', () => {\n  render(<Component />);\n  fireEvent.press(screen.getByText('Submit'));\n});\n\n// ❌ getBy* for non-existence\nexpect(screen.getByText('Error')).not.toBeOnTheScreen();\n\n// ❌ waitFor + getBy* instead of findBy*\nawait waitFor(() => {\n  expect(screen.getByText('Loaded')).toBeOnTheScreen();\n});\n\n// ❌ Side-effect in waitFor\nawait waitFor(async () => {\n  await fireEvent.press(button);\n  expect(screen.getByText('Result')).toBeOnTheScreen();\n});\n\n// ❌ accessibility* props instead of ARIA\n<Pressable accessibilityRole=\"button\" accessibilityLabel=\"Submit\" />;\n\n// ❌ Destructuring from render\nconst { getByText } = await render(<Component />);\n```\n\nBy following these guidelines, your tests will be more maintainable, accessible, and reliable.\n","routePath":"/14.x/docs/guides/llm-guidelines","lang":"en","toc":[{"id":"core-apis","text":"Core APIs","depth":2,"charIndex":87},{"id":"render","text":"render","depth":3,"charIndex":101},{"id":"screen","text":"screen","depth":3,"charIndex":1149},{"id":"renderhook","text":"renderHook","depth":3,"charIndex":1371},{"id":"query-selection","text":"Query Selection","depth":2,"charIndex":2089},{"id":"assertions","text":"Assertions","depth":2,"charIndex":2686},{"id":"jest-matchers-reference","text":"Jest Matchers Reference","depth":2,"charIndex":2935},{"id":"user-interactions","text":"User Interactions","depth":2,"charIndex":5604},{"id":"userevent-preferred","text":"userEvent (Preferred)","depth":3,"charIndex":5790},{"id":"fireevent-low-level","text":"fireEvent (Low-level)","depth":3,"charIndex":6878},{"id":"asyncawait-v14","text":"Async/Await (v14)","depth":2,"charIndex":7550},{"id":"waitfor-usage","text":"waitFor Usage","depth":2,"charIndex":7799},{"id":"code-organization","text":"Code Organization","depth":2,"charIndex":8181},{"id":"quick-checklist","text":"Quick Checklist","depth":2,"charIndex":8570},{"id":"example-good-pattern","text":"Example: Good Pattern","depth":2,"charIndex":8991},{"id":"example-anti-patterns","text":"Example: Anti-Patterns","depth":2,"charIndex":10129}],"frontmatter":{},"version":"14.x","description":"Actionable guidelines for writing tests with React Native Testing Library (RNTL) v14."},{"title":"Troubleshooting","content":"This guide describes common issues found by users when integrating React Native Test Library to their projects:\n\n## Example repository\n\nWe maintain an [example repository]() with a React Native Testing Library setup using TypeScript.\n\nIf something doesn't work in your setup, check this repository for configuration examples.\n\n## Undefined component error\n\n> Warning: React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: undefined.\n\nThis frequently happens when you mock a complex module incorrectly, e.g.:\n\n```ts\njest.mock('@react-navigation/native', () => {\n  return {\n    useNavigation: jest.fn(),\n  };\n});\n```\n\nThe above mock will mock `useNavigation` hook as intended, but at the same time all other exports from `@react-navigation/native` package are now `undefined`. If you want to use `NavigationContainer` component from the same package it will be `undefined` and result in the error above.\n\nTo mock only part of a package, re-export all other exports using `jest.requireActual`:\n\n```ts\njest.mock('@react-navigation/native', () => {\n  return {\n    ...jest.requireActual('@react-navigation/native'),\n    useNavigation: jest.fn(),\n  };\n});\n```\n\nThat way the mock will re-export all of the `@react-navigation/native` members and overwrite only the `useNavigation` hook.\n\nAlternatively, you can use `jest.spyOn` to mock package exports selectively.\n\n### Mocking React Native\n\nWhen mocking the `react-native` package, don't mock the whole package at once, as this has issues with `jest.requireActual`. Mock specific library paths inside the package instead, e.g.:\n\n```ts title=jest-setup.ts\njest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');\n```\n\n## Act warnings\n\nWhen writing tests you may encounter warnings connected with `act()` function. There are two kinds of these warnings:\n\n- sync `act()` warning - `Warning: An update to Component inside a test was not wrapped in act(...)`\n- async `act()` warning - `Warning: You called act(async () => ...) without await`\n\nYou can read more about `act()` function in our [understanding `act` function guide]().\n\nNormally, you should not encounter sync `act()` warnings, but if that happens this probably indicate an issue with your test and should be investigated.\n\nIn case of async `act()` function this might happen more or less randomly, especially if your components contain async logic. So far this warning does not seem to affect test correctness.\n","routePath":"/14.x/docs/guides/troubleshooting","lang":"en","toc":[{"id":"example-repository","text":"Example repository","depth":2,"charIndex":113},{"id":"undefined-component-error","text":"Undefined component error","depth":2,"charIndex":327},{"id":"mocking-react-native","text":"Mocking React Native","depth":3,"charIndex":1433},{"id":"act-warnings","text":"Act warnings","depth":2,"charIndex":1747}],"frontmatter":{},"version":"14.x","description":"This guide describes common issues found by users when integrating React Native Test Library to their projects:"},{"title":"Introduction","content":":::warning Alpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter.\n\n:::\n\n## The problem\n\nYou want to write maintainable tests for your React Native components. As a part of this goal, you want your tests to avoid including implementation details of your components and focus on making your tests give you the confidence they are intended. As part of this, you want your tests to be maintainable in the long run so refactors of your components (changes to implementation but not functionality) don't break your tests and slow you and your team down.\n\n## This solution\n\nThe React Native Testing Library (RNTL) is a comprehensive solution for testing React Native components. It provides React Native runtime simulation on top of [Test Renderer](), in a way that encourages better testing practices. Its primary guiding principle is:\n\n> The more your tests resemble how your software is used, the more confidence they can give you.\n\nThis project is inspired by [React Testing Library](). It is tested to work with Jest, but it should work with other test runners as well.\n\n## Example\n\n```jsx\n\n\n\ntest('form submits two answers', async () => {\n  const questions = ['q1', 'q2'];\n  const onSubmit = jest.fn();\n\n  const user = userEvent.setup();\n  await render(<QuestionsBoard questions={questions} onSubmit={onSubmit} />);\n\n  const answerInputs = screen.getAllByLabelText('answer input');\n  await user.type(answerInputs[0], 'a1');\n  await user.type(answerInputs[1], 'a2');\n  await user.press(screen.getByRole('button', { name: 'Submit' }));\n\n  expect(onSubmit).toHaveBeenCalledWith({\n    1: { q: 'q1', a: 'a1' },\n    2: { q: 'q2', a: 'a2' },\n  });\n});\n```\n\nYou can find the source of the `QuestionsBoard` component and this example [here]().\n","routePath":"/14.x/docs/start/intro","lang":"en","toc":[{"id":"the-problem","text":"The problem","depth":2,"charIndex":164},{"id":"this-solution","text":"This solution","depth":2,"charIndex":641},{"id":"example","text":"Example","depth":2,"charIndex":1161}],"frontmatter":{},"version":"14.x","description":":::warning Alpha Version This version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter. :::"},{"title":"Migration to 14.x","content":":::warning Alpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter.\n\n:::\n\nThis guide describes the migration to React Native Testing Library version 14 from version 13.x.\n\n## Overview\n\nRNTL v14 drops support for React 18 and adopts React 19's async rendering model. Here's what changed:\n\n- React 19.0.0+ and React Native 0.78+ are now required\n- `render`, `renderHook`, `fireEvent`, and `act` are now async\n- Switched from deprecated [React Test Renderer]() to [Test Renderer]()\n- Removed deprecated APIs: `update`, `getQueriesForElement`, `UNSAFE_root`, `concurrentRoot` option\n- Reintroduced `container` API, which is now safe to use\n\n:::info React 18 Users\n\nIf you need to support React 18, please continue using RNTL v13.x.\n\n:::\n\n## Quick Migration\n\nWe provide codemods to automate most of the migration:\n\n**Step 1: Update dependencies**\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-update-deps --target .\\nnpm install',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-update-deps --target .\\nyarn install',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-update-deps --target .\\npnpm install',\nbun: 'bunx codemod\\@latest rntl-v14-update-deps --target .\\nbun install',\n}}\n/>\n\n**Step 2: Update test code to async**\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-async-functions --target ./src',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-async-functions --target ./src',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-async-functions --target ./src',\nbun: 'bunx codemod\\@latest rntl-v14-async-functions --target ./src',\n}}\n/>\n\nAfter running the codemods, review the changes and run your tests.\n\n## Breaking Changes\n\n### Supported React and React Native versions\n\n**This version requires React 19+ and React Native 0.78+.** If you need to support React 18, please use the latest v13.x version.\n\n| RNTL Version | React Version | React Native Version |\n| ------------ | ------------- | -------------------- |\n| v14.x        | >= 19.0.0     | >= 0.78              |\n| v13.x        | >= 18.0.0     | >= 0.71              |\n\n### Test Renderer replaces React Test Renderer\n\nIn v14, React Native Testing Library uses [Test Renderer]() instead of the deprecated [React Test Renderer](). Test Renderer works with React 19 and has better TypeScript support.\n\n**What changed:**\n\n- The underlying renderer is now Test Renderer instead of React Test Renderer\n- This is mostly an internal change; your tests should work without modifications in most cases\n- Type definitions now use [`HostElement`]() from Test Renderer instead of `ReactTestInstance`\n\n**Migration:**\n\n#### 1. Update dependencies\n\nRun codemod for updating dependencies:\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-update-deps\\nnpm install',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-update-deps\\nyarn install',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-update-deps\\npnpm install',\nbun: 'bunx codemod\\@latest rntl-v14-update-deps\\nbun install',\n}}\n/>\n\n##### Manual changes\n\nRemove React Test Renderer and its type definitions from your dev dependencies, and add Test Renderer:\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npm uninstall react-test-renderer @types/react-test-renderer\\nnpm install -D test-renderer',\nyarn: 'yarn remove react-test-renderer @types/react-test-renderer\\nyarn add -D test-renderer',\npnpm: 'pnpm remove react-test-renderer @types/react-test-renderer\\npnpm add -D test-renderer',\nbun: 'bun remove react-test-renderer @types/react-test-renderer\\nbun add -D test-renderer',\n}}\n/>\n\n#### 2. Update type imports (if needed)\n\nIf you were directly importing types from React Test Renderer, you may need to update your imports:\n\n```ts\n// Before (v13)\n\n\n// After (v14)\n\n```\n\n**Note:** Most users won't need to update type imports, as React Native Testing Library now exports the necessary types directly.\n\nSee the [Test Renderer documentation]() for more.\n\n### Async APIs by Default\n\nWith React 18 support dropped, RNTL v14 uses React 19's async rendering model. The following functions are now async by default:\n\n- `render()` → returns `Promise<RenderResult>`\n- `rerender()` and `unmount()` → return `Promise<void>`\n- `renderHook()` → returns `Promise<RenderHookResult>`\n- `fireEvent()` and helpers (`press`, `changeText`, `scroll`) → return `Promise<void>`\n- `act()` → always returns `Promise<T>`\n\n:::tip Already using async APIs?\n\nIf you adopted the async APIs introduced in RNTL v13.3 (`renderAsync`, `fireEventAsync`, `renderHookAsync`), rename them to their non-async counterparts (`render`, `fireEvent`, `renderHook`). The async versions have been removed since the standard APIs are now async by default.\n\n:::\n\n#### `render` is now async {#render-async-default}\n\nIn v14, `render` is async by default and returns a Promise. This allows proper support for `Suspense` boundaries and the `use()` hook.\n\n**Before (v13):**\n\n```ts\n\n\nit('should render component', () => {\n  render(<MyComponent />);\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n```\n\n**After (v14):**\n\n```ts\n\n\nit('should render component', async () => {\n  await render(<MyComponent />);\n  expect(screen.getByText('Hello')).toBeOnTheScreen();\n});\n```\n\nSee the [`render` API documentation]().\n\n#### `renderHook` is now async\n\nIn v14, `renderHook` is async by default and returns a Promise.\n\n**Before (v13):**\n\n```ts\n\n\nit('should test hook', () => {\n  const { result, rerender } = renderHook(() => useMyHook());\n\n  rerender(newProps);\n  unmount();\n});\n```\n\n**After (v14):**\n\n```ts\n\n\nit('should test hook', async () => {\n  const { result, rerender } = await renderHook(() => useMyHook());\n\n  await rerender(newProps);\n  await unmount();\n});\n```\n\nSee the [`renderHook` API documentation]().\n\n#### `fireEvent` is now async\n\nIn v14, `fireEvent` and its helpers (`press`, `changeText`, `scroll`) are async by default and return a Promise.\n\n**Before (v13):**\n\n```ts\n\n\nit('should press button', () => {\n  render(<MyComponent />);\n  fireEvent.press(screen.getByText('Press me'));\n  expect(onPress).toHaveBeenCalled();\n});\n```\n\n**After (v14):**\n\n```ts\n\n\nit('should press button', async () => {\n  await render(<MyComponent />);\n  await fireEvent.press(screen.getByText('Press me'));\n  expect(onPress).toHaveBeenCalled();\n});\n```\n\n#### `act` is now async\n\nIn v14, `act` is async by default and always returns a Promise. You should always `await` the result of `act()`.\n\n**What changed:**\n\n- `act` now always returns `Promise<T>` instead of `T | Thenable<T>`\n- `act` should always be awaited\n\n:::note\n\nThe transition to async `act` may prevent testing very short transient states, as awaiting `act` will flush all pending updates before returning.\n\n:::\n\n**Before (v13):**\n\n```ts\n\n\nit('should update state', () => {\n  act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n```\n\n**After (v14):**\n\n```ts\n\n\nit('should update state', async () => {\n  await act(() => {\n    setState('new value');\n  });\n  expect(state).toBe('new value');\n});\n```\n\n**Note**: Even if your callback is synchronous, you should still use `await act(...)` as `act` now always returns a Promise.\n\nSee the [`act` API documentation]().\n\n#### Why async APIs?\n\nThe async APIs properly handle `Suspense` boundaries and the `use()` hook, and ensure all pending React updates complete before assertions run. This matches React 19's async rendering model.\n\n### Removed APIs\n\n#### `update` alias removed\n\nThe `update` alias for `rerender` has been removed. Use `rerender` instead:\n\n```ts\n// Before (v13)\nscreen.update(<MyComponent />);\nconst { update } = render(<MyComponent />);\nupdate(<MyComponent newProp />);\n\n// After (v14)\nawait screen.rerender(<MyComponent />);\nconst { rerender } = await render(<MyComponent />);\nawait rerender(<MyComponent newProp />);\n```\n\n#### `getQueriesForElement` export removed\n\nThe `getQueriesForElement` export alias for `within` has been removed. Use `within` instead:\n\n```ts\n// Before (v13)\n\n\nconst queries = getQueriesForElement(element);\n\n// After (v14)\n\n\nconst queries = within(element);\n```\n\n**Note:** `getQueriesForElement` was just an alias for `within`, so the functionality is identical - only the import needs to change.\n\n#### `UNSAFE_root` removed\n\n`UNSAFE_root` has been removed. Use `container` to access the pseudo-element container, or `root` to access the first rendered host element:\n\n```ts\n// Before (v13)\nconst unsafeRoot = screen.UNSAFE_root;\n\n// After (v14)\nconst container = screen.container; // pseudo-element container\nconst root = screen.root; // first rendered host element\n```\n\n#### Legacy `UNSAFE_*` queries removed\n\nThe legacy `UNSAFE_getAllByType`, `UNSAFE_getByType`, `UNSAFE_getAllByProps`, and `UNSAFE_getByProps` queries have been removed. These queries could return composite (user-defined) components, which is no longer supported with [Test Renderer]() as it only renders host elements.\n\nIf you were using these legacy queries, you should refactor your tests to use the standard queries (`getByRole`, `getByText`, `getByTestId`, etc.) which target host elements.\n\n```ts\n// Before (v13)\nconst buttons = screen.UNSAFE_getAllByType(Button);\nconst input = screen.UNSAFE_getByProps({ placeholder: 'Enter text' });\n\n// After (v14)\nconst buttons = screen.getAllByRole('button');\nconst input = screen.getByPlaceholderText('Enter text');\n```\n\n#### `concurrentRoot` option removed\n\nThe `concurrentRoot` option has been removed from both `render` options and `configure` function. In v14, concurrent rendering is always enabled, since it's the standard rendering mode for React 19 and React Native's New Architecture.\n\n```ts\n// Before (v13)\nrender(<MyComponent />, { concurrentRoot: true });  // Enable concurrent mode\nrender(<MyComponent />, { concurrentRoot: false }); // Disable concurrent mode\nconfigure({ concurrentRoot: false });               // Disable globally\n\n// After (v14)\nawait render(<MyComponent />); // Always uses concurrent rendering\n```\n\n**Migration:** Remove any `concurrentRoot` options from your `render` calls and `configure` function. If you were setting `concurrentRoot: true`, just remove the option. If you were setting `concurrentRoot: false` to disable concurrent rendering, this is no longer supported in v14.\n\n### `container` API reintroduced\n\nIn v14, the `container` API has been reintroduced and is now safe to use. Previously, `container` was renamed to `UNSAFE_root` in v12 due to behavioral differences from React Testing Library's `container`. Now `container` returns a pseudo-element container whose children are the elements you rendered, consistent with React Testing Library's behavior.\n\n**What changed:**\n\n- `screen.container` is now available and safe to use\n- `container` returns a pseudo-element container from Test Renderer\n- The container's children are the elements you rendered\n- `UNSAFE_root` has been removed\n\n**Before (v13):**\n\n```ts\n\n\nit('should access root', () => {\n  render(<MyComponent />);\n  // UNSAFE_root was the only way to access the container\n  const root = screen.UNSAFE_root;\n});\n```\n\n**After (v14):**\n\n```ts\n\n\nit('should access container', async () => {\n  await render(<MyComponent />);\n  // container is now safe and available\n  const container = screen.container;\n  // root is the first child of container\n  const root = screen.root;\n});\n```\n\nSee the [`screen` API documentation]().\n\n### Text string validation enforced by default\n\nIn v14, Test Renderer enforces React Native's requirement that text strings must be rendered within a `<Text>` component. The `unstable_validateStringsRenderedWithinText` option has been removed from `RenderOptions` since this validation is now always on.\n\n**What changed:**\n\n- Text string validation is now always enabled and cannot be disabled\n- The `unstable_validateStringsRenderedWithinText` option has been removed\n- Tests will now throw `Invariant Violation: Text strings must be rendered within a <Text> component` errors when attempting to render strings outside of `<Text>` components, matching React Native's runtime behavior\n\n**Migration:**\n\nIf you were using `unstable_validateStringsRenderedWithinText: true` in your render options, you can simply remove this option as the validation is now always enabled:\n\n```ts\n// Before (v13)\nrender(<MyComponent />, {\n  unstable_validateStringsRenderedWithinText: true,\n});\n\n// After (v14)\nawait render(<MyComponent />);\n// Validation is now always enabled\n```\n\nIf you were relying on the previous behavior where strings could be rendered outside of `<Text>` components, you'll need to fix your components to wrap strings in `<Text>` components, as this matches React Native's actual runtime behavior.\n\n## Codemods\n\nTwo codemods are available to automate the migration. Both are safe to run multiple times - they only transform code that hasn't been migrated yet.\n\n### `rntl-v14-update-deps`\n\nUpdates your `package.json`:\n\n- Removes React Test Renderer (`react-test-renderer` and `@types/react-test-renderer`)\n- Adds Test Renderer (`test-renderer`)\n- Updates `@testing-library/react-native` to alpha version\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-update-deps --target .\\nnpm install',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-update-deps --target .\\nyarn install',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-update-deps --target .\\npnpm install',\nbun: 'bunx codemod\\@latest rntl-v14-update-deps --target .\\nbun install',\n}}\n/>\n\n### `rntl-v14-async-functions`\n\nTransforms test files:\n\n- Adds `await` to `render()`, `act()`, `renderHook()`, `fireEvent()` calls\n- Makes test functions async when needed\n- Handles `screen.rerender()`, `screen.unmount()`, and renderer methods\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-async-functions --target ./src',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-async-functions --target ./src',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-async-functions --target ./src',\nbun: 'bunx codemod\\@latest rntl-v14-async-functions --target ./src',\n}}\n/>\n\n#### Custom render functions\n\nIf you have custom render helpers (like `renderWithProviders`), you can specify them using the `customRenderFunctions` parameter. The codemod will then also transform calls to these functions:\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npx codemod\\@latest rntl-v14-async-functions \\\\\\n  --target ./src \\\\\\n  --param customRenderFunctions=\"renderWithProviders,renderWithTheme\"',\nyarn: 'yarn dlx codemod\\@latest rntl-v14-async-functions \\\\\\n  --target ./src \\\\\\n  --param customRenderFunctions=\"renderWithProviders,renderWithTheme\"',\npnpm: 'pnpm dlx codemod\\@latest rntl-v14-async-functions \\\\\\n  --target ./src \\\\\\n  --param customRenderFunctions=\"renderWithProviders,renderWithTheme\"',\nbun: 'bunx codemod\\@latest rntl-v14-async-functions \\\\\\n  --target ./src \\\\\\n  --param customRenderFunctions=\"renderWithProviders,renderWithTheme\"',\n}}\n/>\n\nThis will add `await` to your custom render calls and make the containing test functions async, just like it does for the standard `render` function.\n\n#### Limitations\n\n- Helper functions defined in test files are not transformed by default\n- Namespace imports (`import * as RNTL`) are not handled\n\n## Full Changelog\n\n[https://github.com/callstack/react-native-testing-library/compare/v13.3.3...v14.0.0]()\n","routePath":"/14.x/docs/start/migration-v14","lang":"en","toc":[{"id":"overview","text":"Overview","depth":2,"charIndex":262},{"id":"quick-migration","text":"Quick Migration","depth":2,"charIndex":824},{"id":"breaking-changes","text":"Breaking Changes","depth":2,"charIndex":1710},{"id":"supported-react-and-react-native-versions","text":"Supported React and React Native versions","depth":3,"charIndex":1731},{"id":"test-renderer-replaces-react-test-renderer","text":"Test Renderer replaces React Test Renderer","depth":3,"charIndex":2134},{"id":"1-update-dependencies","text":"1. Update dependencies","depth":4,"charIndex":2668},{"id":"2-update-type-imports-if-needed","text":"2. Update type imports (if needed)","depth":4,"charIndex":3585},{"id":"async-apis-by-default","text":"Async APIs by Default","depth":3,"charIndex":3954},{"id":"render-async-default","text":"`render` is now async","depth":4,"charIndex":4716},{"id":"renderhook-is-now-async","text":"`renderHook` is now async","depth":4,"charIndex":5268},{"id":"fireevent-is-now-async","text":"`fireEvent` is now async","depth":4,"charIndex":5763},{"id":"act-is-now-async","text":"`act` is now async","depth":4,"charIndex":6293},{"id":"why-async-apis","text":"Why async APIs?","depth":4,"charIndex":7194},{"id":"removed-apis","text":"Removed APIs","depth":3,"charIndex":7408},{"id":"update-alias-removed","text":"`update` alias removed","depth":4,"charIndex":7426},{"id":"getqueriesforelement-export-removed","text":"`getQueriesForElement` export removed","depth":4,"charIndex":7817},{"id":"unsafe_root-removed","text":"`UNSAFE_root` removed","depth":4,"charIndex":8217},{"id":"legacy-unsafe_-queries-removed","text":"Legacy `UNSAFE_*` queries removed","depth":4,"charIndex":8590},{"id":"concurrentroot-option-removed","text":"`concurrentRoot` option removed","depth":4,"charIndex":9356},{"id":"container-api-reintroduced","text":"`container` API reintroduced","depth":3,"charIndex":10253},{"id":"text-string-validation-enforced-by-default","text":"Text string validation enforced by default","depth":3,"charIndex":11364},{"id":"codemods","text":"Codemods","depth":2,"charIndex":12668},{"id":"rntl-v14-update-deps","text":"`rntl-v14-update-deps`","depth":3,"charIndex":12830},{"id":"rntl-v14-async-functions","text":"`rntl-v14-async-functions`","depth":3,"charIndex":13420},{"id":"custom-render-functions","text":"Custom render functions","depth":4,"charIndex":13989},{"id":"limitations","text":"Limitations","depth":4,"charIndex":15008},{"id":"full-changelog","text":"Full Changelog","depth":2,"charIndex":15156}],"frontmatter":{},"version":"14.x","description":":::warning Alpha Version This version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter. ::: This guide describes the migration to React Native Testing Library version 14 from version 13.x."},{"title":"Quick Start","content":":::warning Alpha Version\n\nThis version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter.\n\n:::\n\n## Installation\n\nOpen a Terminal in your project's folder and run:\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npm install -D @testing-library/react-native\\@alpha',\nyarn: 'yarn add -D @testing-library/react-native\\@alpha',\npnpm: 'pnpm add -D @testing-library/react-native\\@alpha',\nbun: 'bun add -D @testing-library/react-native\\@alpha',\n}}\n/>\n\nThis library has a peer dependency on [Test Renderer](). Make sure to install it:\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npm install -D test-renderer',\nyarn: 'yarn add -D test-renderer',\npnpm: 'pnpm add -D test-renderer',\nbun: 'bun add -D test-renderer',\n}}\n/>\n\nTest Renderer has better compatibility with React 19 and improved type safety compared to the deprecated [React Test Renderer]().\n\n### Jest matchers\n\nRNTL automatically extends Jest with React Native-specific matchers. The only thing you need to do is to import anything from `@testing-library/react-native` which you already need to do to access the `render` function.\n\n### ESLint plugin\n\nSet up [`eslint-plugin-testing-library`]() to avoid common Testing Library mistakes and bad practices.\n\nInstall the plugin (assuming you already have `eslint` installed & configured):\n\n\\<PackageManagerTabs\ncommand={{\nnpm: 'npm install -D eslint-plugin-testing-library',\nyarn: 'yarn add -D eslint-plugin-testing-library',\npnpm: 'pnpm add -D eslint-plugin-testing-library',\nbun: 'bun add -D eslint-plugin-testing-library',\n}}\n/>\n\nThen, add this to your ESLint config (e.g., `.eslintrc.js`). Extend the `react` plugin:\n\n```js title=.eslintrc.js\nmodule.exports = {\n  overrides: [\n    {\n      // Test files only\n      files: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[jt]s?(x)'],\n      extends: ['plugin:testing-library/react'],\n    },\n  ],\n};\n```\n","routePath":"/14.x/docs/start/quick-start","lang":"en","toc":[{"id":"installation","text":"Installation","depth":2,"charIndex":164},{"id":"jest-matchers","text":"Jest matchers","depth":3,"charIndex":896},{"id":"eslint-plugin","text":"ESLint plugin","depth":3,"charIndex":1136}],"frontmatter":{},"version":"14.x","description":":::warning Alpha Version This version is currently in alpha. APIs and behavior may change before the stable release. Please report any issues you encounter. :::"}]